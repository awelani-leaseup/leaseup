
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Verification
 * 
 */
export type Verification = $Result.DefaultSelection<Prisma.$VerificationPayload>
/**
 * Model Tenant
 * 
 */
export type Tenant = $Result.DefaultSelection<Prisma.$TenantPayload>
/**
 * Model Property
 * 
 */
export type Property = $Result.DefaultSelection<Prisma.$PropertyPayload>
/**
 * Model Unit
 * 
 */
export type Unit = $Result.DefaultSelection<Prisma.$UnitPayload>
/**
 * Model Lease
 * 
 */
export type Lease = $Result.DefaultSelection<Prisma.$LeasePayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model RecurringBillable
 * 
 */
export type RecurringBillable = $Result.DefaultSelection<Prisma.$RecurringBillablePayload>
/**
 * Model Transactions
 * 
 */
export type Transactions = $Result.DefaultSelection<Prisma.$TransactionsPayload>
/**
 * Model TenantLease
 * 
 */
export type TenantLease = $Result.DefaultSelection<Prisma.$TenantLeasePayload>
/**
 * Model MaintenanceRequest
 * 
 */
export type MaintenanceRequest = $Result.DefaultSelection<Prisma.$MaintenanceRequestPayload>
/**
 * Model File
 * 
 */
export type File = $Result.DefaultSelection<Prisma.$FilePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const InvoiceCycle: {
  MONTHLY: 'MONTHLY'
};

export type InvoiceCycle = (typeof InvoiceCycle)[keyof typeof InvoiceCycle]


export const LeaseTermType: {
  MONTHLY: 'MONTHLY',
  FIXED_TERM: 'FIXED_TERM'
};

export type LeaseTermType = (typeof LeaseTermType)[keyof typeof LeaseTermType]


export const PropertyType: {
  SINGLE_UNIT: 'SINGLE_UNIT',
  MULTI_UNIT: 'MULTI_UNIT'
};

export type PropertyType = (typeof PropertyType)[keyof typeof PropertyType]


export const PropertyStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE'
};

export type PropertyStatus = (typeof PropertyStatus)[keyof typeof PropertyStatus]


export const InvoiceStatus: {
  PENDING: 'PENDING',
  PAID: 'PAID',
  CANCELLED: 'CANCELLED',
  OVERDUE: 'OVERDUE',
  PARTIALLY_PAID: 'PARTIALLY_PAID',
  DRAFT: 'DRAFT'
};

export type InvoiceStatus = (typeof InvoiceStatus)[keyof typeof InvoiceStatus]


export const LeaseStatus: {
  PENDING: 'PENDING',
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  EXPIRED: 'EXPIRED'
};

export type LeaseStatus = (typeof LeaseStatus)[keyof typeof LeaseStatus]


export const TenantIncomeType: {
  SALARY: 'SALARY',
  SELF_EMPLOYED: 'SELF_EMPLOYED',
  UNEMPLOYED: 'UNEMPLOYED',
  RETIRED: 'RETIRED',
  DISABILITY: 'DISABILITY',
  OTHER: 'OTHER'
};

export type TenantIncomeType = (typeof TenantIncomeType)[keyof typeof TenantIncomeType]


export const TenantRelationship: {
  SPOUSE: 'SPOUSE',
  PARENT: 'PARENT',
  GRANDPARENT: 'GRANDPARENT',
  GRANDCHILD: 'GRANDCHILD',
  SIBLING: 'SIBLING',
  CHILD: 'CHILD',
  AUNT_UNCLE: 'AUNT_UNCLE',
  COUSIN: 'COUSIN',
  NEPHEW_NIECE: 'NEPHEW_NIECE',
  OTHER: 'OTHER'
};

export type TenantRelationship = (typeof TenantRelationship)[keyof typeof TenantRelationship]


export const MaintenanceRequestStatus: {
  PENDING: 'PENDING',
  ASSIGNED: 'ASSIGNED',
  IN_PROGRESS: 'IN_PROGRESS',
  CANCELLED: 'CANCELLED',
  COMPLETE: 'COMPLETE'
};

export type MaintenanceRequestStatus = (typeof MaintenanceRequestStatus)[keyof typeof MaintenanceRequestStatus]


export const MaintenanceRequestPriority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH'
};

export type MaintenanceRequestPriority = (typeof MaintenanceRequestPriority)[keyof typeof MaintenanceRequestPriority]


export const InvoiceCategory: {
  DEPOSIT: 'DEPOSIT',
  RENT: 'RENT',
  MAINTENANCE: 'MAINTENANCE',
  UTILITY_BILL: 'UTILITY_BILL',
  LEVY: 'LEVY',
  RATES_AND_TAXES: 'RATES_AND_TAXES',
  SERVICE_CHARGE: 'SERVICE_CHARGE',
  WATER_ELECTRICITY: 'WATER_ELECTRICITY',
  OTHER: 'OTHER'
};

export type InvoiceCategory = (typeof InvoiceCategory)[keyof typeof InvoiceCategory]


export const PropertyAmenity: {
  BBQ_GRILL: 'BBQ_GRILL',
  POOL: 'POOL',
  FITNESS_CENTER: 'FITNESS_CENTER',
  PET_FRIENDLY: 'PET_FRIENDLY',
  GYM: 'GYM',
  LAUNDRY: 'LAUNDRY',
  PARKING: 'PARKING',
  STORAGE: 'STORAGE'
};

export type PropertyAmenity = (typeof PropertyAmenity)[keyof typeof PropertyAmenity]


export const PropertyFeature: {
  ALARM_SYSTEM: 'ALARM_SYSTEM',
  AIR_CONDITIONING: 'AIR_CONDITIONING',
  WIFI_INTERNET: 'WIFI_INTERNET',
  CABLE_TV: 'CABLE_TV',
  DISHWASHER: 'DISHWASHER',
  DRYER: 'DRYER',
  FRIDGE: 'FRIDGE',
  MICROWAVE: 'MICROWAVE',
  OVEN: 'OVEN',
  STOVE: 'STOVE',
  FIREPLACE: 'FIREPLACE'
};

export type PropertyFeature = (typeof PropertyFeature)[keyof typeof PropertyFeature]

}

export type InvoiceCycle = $Enums.InvoiceCycle

export const InvoiceCycle: typeof $Enums.InvoiceCycle

export type LeaseTermType = $Enums.LeaseTermType

export const LeaseTermType: typeof $Enums.LeaseTermType

export type PropertyType = $Enums.PropertyType

export const PropertyType: typeof $Enums.PropertyType

export type PropertyStatus = $Enums.PropertyStatus

export const PropertyStatus: typeof $Enums.PropertyStatus

export type InvoiceStatus = $Enums.InvoiceStatus

export const InvoiceStatus: typeof $Enums.InvoiceStatus

export type LeaseStatus = $Enums.LeaseStatus

export const LeaseStatus: typeof $Enums.LeaseStatus

export type TenantIncomeType = $Enums.TenantIncomeType

export const TenantIncomeType: typeof $Enums.TenantIncomeType

export type TenantRelationship = $Enums.TenantRelationship

export const TenantRelationship: typeof $Enums.TenantRelationship

export type MaintenanceRequestStatus = $Enums.MaintenanceRequestStatus

export const MaintenanceRequestStatus: typeof $Enums.MaintenanceRequestStatus

export type MaintenanceRequestPriority = $Enums.MaintenanceRequestPriority

export const MaintenanceRequestPriority: typeof $Enums.MaintenanceRequestPriority

export type InvoiceCategory = $Enums.InvoiceCategory

export const InvoiceCategory: typeof $Enums.InvoiceCategory

export type PropertyAmenity = $Enums.PropertyAmenity

export const PropertyAmenity: typeof $Enums.PropertyAmenity

export type PropertyFeature = $Enums.PropertyFeature

export const PropertyFeature: typeof $Enums.PropertyFeature

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verification`: Exposes CRUD operations for the **Verification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Verifications
    * const verifications = await prisma.verification.findMany()
    * ```
    */
  get verification(): Prisma.VerificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tenant`: Exposes CRUD operations for the **Tenant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tenants
    * const tenants = await prisma.tenant.findMany()
    * ```
    */
  get tenant(): Prisma.TenantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.property`: Exposes CRUD operations for the **Property** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Properties
    * const properties = await prisma.property.findMany()
    * ```
    */
  get property(): Prisma.PropertyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unit`: Exposes CRUD operations for the **Unit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Units
    * const units = await prisma.unit.findMany()
    * ```
    */
  get unit(): Prisma.UnitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lease`: Exposes CRUD operations for the **Lease** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leases
    * const leases = await prisma.lease.findMany()
    * ```
    */
  get lease(): Prisma.LeaseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.recurringBillable`: Exposes CRUD operations for the **RecurringBillable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecurringBillables
    * const recurringBillables = await prisma.recurringBillable.findMany()
    * ```
    */
  get recurringBillable(): Prisma.RecurringBillableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transactions`: Exposes CRUD operations for the **Transactions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transactions.findMany()
    * ```
    */
  get transactions(): Prisma.TransactionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tenantLease`: Exposes CRUD operations for the **TenantLease** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TenantLeases
    * const tenantLeases = await prisma.tenantLease.findMany()
    * ```
    */
  get tenantLease(): Prisma.TenantLeaseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.maintenanceRequest`: Exposes CRUD operations for the **MaintenanceRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MaintenanceRequests
    * const maintenanceRequests = await prisma.maintenanceRequest.findMany()
    * ```
    */
  get maintenanceRequest(): Prisma.MaintenanceRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.file`: Exposes CRUD operations for the **File** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Files
    * const files = await prisma.file.findMany()
    * ```
    */
  get file(): Prisma.FileDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.13.0
   * Query Engine version: 361e86d0ea4987e9f53a565309b3eed797a6bcbd
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Session: 'Session',
    Account: 'Account',
    Verification: 'Verification',
    Tenant: 'Tenant',
    Property: 'Property',
    Unit: 'Unit',
    Lease: 'Lease',
    Invoice: 'Invoice',
    RecurringBillable: 'RecurringBillable',
    Transactions: 'Transactions',
    TenantLease: 'TenantLease',
    MaintenanceRequest: 'MaintenanceRequest',
    File: 'File'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "session" | "account" | "verification" | "tenant" | "property" | "unit" | "lease" | "invoice" | "recurringBillable" | "transactions" | "tenantLease" | "maintenanceRequest" | "file"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Verification: {
        payload: Prisma.$VerificationPayload<ExtArgs>
        fields: Prisma.VerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findFirst: {
            args: Prisma.VerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findMany: {
            args: Prisma.VerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          create: {
            args: Prisma.VerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          createMany: {
            args: Prisma.VerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          delete: {
            args: Prisma.VerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          update: {
            args: Prisma.VerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          deleteMany: {
            args: Prisma.VerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          upsert: {
            args: Prisma.VerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          aggregate: {
            args: Prisma.VerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerification>
          }
          groupBy: {
            args: Prisma.VerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationCountAggregateOutputType> | number
          }
        }
      }
      Tenant: {
        payload: Prisma.$TenantPayload<ExtArgs>
        fields: Prisma.TenantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findFirst: {
            args: Prisma.TenantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findMany: {
            args: Prisma.TenantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          create: {
            args: Prisma.TenantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          createMany: {
            args: Prisma.TenantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          delete: {
            args: Prisma.TenantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          update: {
            args: Prisma.TenantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          deleteMany: {
            args: Prisma.TenantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TenantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          upsert: {
            args: Prisma.TenantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          aggregate: {
            args: Prisma.TenantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenant>
          }
          groupBy: {
            args: Prisma.TenantGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantCountArgs<ExtArgs>
            result: $Utils.Optional<TenantCountAggregateOutputType> | number
          }
        }
      }
      Property: {
        payload: Prisma.$PropertyPayload<ExtArgs>
        fields: Prisma.PropertyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          findFirst: {
            args: Prisma.PropertyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          findMany: {
            args: Prisma.PropertyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>[]
          }
          create: {
            args: Prisma.PropertyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          createMany: {
            args: Prisma.PropertyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>[]
          }
          delete: {
            args: Prisma.PropertyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          update: {
            args: Prisma.PropertyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          deleteMany: {
            args: Prisma.PropertyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>[]
          }
          upsert: {
            args: Prisma.PropertyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          aggregate: {
            args: Prisma.PropertyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProperty>
          }
          groupBy: {
            args: Prisma.PropertyGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyCountAggregateOutputType> | number
          }
        }
      }
      Unit: {
        payload: Prisma.$UnitPayload<ExtArgs>
        fields: Prisma.UnitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          findFirst: {
            args: Prisma.UnitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          findMany: {
            args: Prisma.UnitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          create: {
            args: Prisma.UnitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          createMany: {
            args: Prisma.UnitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UnitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          delete: {
            args: Prisma.UnitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          update: {
            args: Prisma.UnitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          deleteMany: {
            args: Prisma.UnitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UnitUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          upsert: {
            args: Prisma.UnitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          aggregate: {
            args: Prisma.UnitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnit>
          }
          groupBy: {
            args: Prisma.UnitGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitCountArgs<ExtArgs>
            result: $Utils.Optional<UnitCountAggregateOutputType> | number
          }
        }
      }
      Lease: {
        payload: Prisma.$LeasePayload<ExtArgs>
        fields: Prisma.LeaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeasePayload>
          }
          findFirst: {
            args: Prisma.LeaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeasePayload>
          }
          findMany: {
            args: Prisma.LeaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeasePayload>[]
          }
          create: {
            args: Prisma.LeaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeasePayload>
          }
          createMany: {
            args: Prisma.LeaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeasePayload>[]
          }
          delete: {
            args: Prisma.LeaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeasePayload>
          }
          update: {
            args: Prisma.LeaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeasePayload>
          }
          deleteMany: {
            args: Prisma.LeaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeaseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeasePayload>[]
          }
          upsert: {
            args: Prisma.LeaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeasePayload>
          }
          aggregate: {
            args: Prisma.LeaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLease>
          }
          groupBy: {
            args: Prisma.LeaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaseCountArgs<ExtArgs>
            result: $Utils.Optional<LeaseCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      RecurringBillable: {
        payload: Prisma.$RecurringBillablePayload<ExtArgs>
        fields: Prisma.RecurringBillableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecurringBillableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringBillablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecurringBillableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringBillablePayload>
          }
          findFirst: {
            args: Prisma.RecurringBillableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringBillablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecurringBillableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringBillablePayload>
          }
          findMany: {
            args: Prisma.RecurringBillableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringBillablePayload>[]
          }
          create: {
            args: Prisma.RecurringBillableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringBillablePayload>
          }
          createMany: {
            args: Prisma.RecurringBillableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecurringBillableCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringBillablePayload>[]
          }
          delete: {
            args: Prisma.RecurringBillableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringBillablePayload>
          }
          update: {
            args: Prisma.RecurringBillableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringBillablePayload>
          }
          deleteMany: {
            args: Prisma.RecurringBillableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecurringBillableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RecurringBillableUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringBillablePayload>[]
          }
          upsert: {
            args: Prisma.RecurringBillableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringBillablePayload>
          }
          aggregate: {
            args: Prisma.RecurringBillableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecurringBillable>
          }
          groupBy: {
            args: Prisma.RecurringBillableGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecurringBillableGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecurringBillableCountArgs<ExtArgs>
            result: $Utils.Optional<RecurringBillableCountAggregateOutputType> | number
          }
        }
      }
      Transactions: {
        payload: Prisma.$TransactionsPayload<ExtArgs>
        fields: Prisma.TransactionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload>
          }
          findFirst: {
            args: Prisma.TransactionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload>
          }
          findMany: {
            args: Prisma.TransactionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload>[]
          }
          create: {
            args: Prisma.TransactionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload>
          }
          createMany: {
            args: Prisma.TransactionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload>[]
          }
          delete: {
            args: Prisma.TransactionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload>
          }
          update: {
            args: Prisma.TransactionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload>
          }
          deleteMany: {
            args: Prisma.TransactionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload>[]
          }
          upsert: {
            args: Prisma.TransactionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload>
          }
          aggregate: {
            args: Prisma.TransactionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransactions>
          }
          groupBy: {
            args: Prisma.TransactionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionsCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionsCountAggregateOutputType> | number
          }
        }
      }
      TenantLease: {
        payload: Prisma.$TenantLeasePayload<ExtArgs>
        fields: Prisma.TenantLeaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantLeaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantLeasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantLeaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantLeasePayload>
          }
          findFirst: {
            args: Prisma.TenantLeaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantLeasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantLeaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantLeasePayload>
          }
          findMany: {
            args: Prisma.TenantLeaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantLeasePayload>[]
          }
          create: {
            args: Prisma.TenantLeaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantLeasePayload>
          }
          createMany: {
            args: Prisma.TenantLeaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantLeaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantLeasePayload>[]
          }
          delete: {
            args: Prisma.TenantLeaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantLeasePayload>
          }
          update: {
            args: Prisma.TenantLeaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantLeasePayload>
          }
          deleteMany: {
            args: Prisma.TenantLeaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantLeaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TenantLeaseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantLeasePayload>[]
          }
          upsert: {
            args: Prisma.TenantLeaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantLeasePayload>
          }
          aggregate: {
            args: Prisma.TenantLeaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenantLease>
          }
          groupBy: {
            args: Prisma.TenantLeaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantLeaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantLeaseCountArgs<ExtArgs>
            result: $Utils.Optional<TenantLeaseCountAggregateOutputType> | number
          }
        }
      }
      MaintenanceRequest: {
        payload: Prisma.$MaintenanceRequestPayload<ExtArgs>
        fields: Prisma.MaintenanceRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaintenanceRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaintenanceRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload>
          }
          findFirst: {
            args: Prisma.MaintenanceRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaintenanceRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload>
          }
          findMany: {
            args: Prisma.MaintenanceRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload>[]
          }
          create: {
            args: Prisma.MaintenanceRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload>
          }
          createMany: {
            args: Prisma.MaintenanceRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaintenanceRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload>[]
          }
          delete: {
            args: Prisma.MaintenanceRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload>
          }
          update: {
            args: Prisma.MaintenanceRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload>
          }
          deleteMany: {
            args: Prisma.MaintenanceRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaintenanceRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MaintenanceRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload>[]
          }
          upsert: {
            args: Prisma.MaintenanceRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload>
          }
          aggregate: {
            args: Prisma.MaintenanceRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaintenanceRequest>
          }
          groupBy: {
            args: Prisma.MaintenanceRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaintenanceRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaintenanceRequestCountArgs<ExtArgs>
            result: $Utils.Optional<MaintenanceRequestCountAggregateOutputType> | number
          }
        }
      }
      File: {
        payload: Prisma.$FilePayload<ExtArgs>
        fields: Prisma.FileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          findFirst: {
            args: Prisma.FileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          findMany: {
            args: Prisma.FileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          create: {
            args: Prisma.FileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          createMany: {
            args: Prisma.FileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          delete: {
            args: Prisma.FileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          update: {
            args: Prisma.FileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          deleteMany: {
            args: Prisma.FileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          upsert: {
            args: Prisma.FileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          aggregate: {
            args: Prisma.FileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFile>
          }
          groupBy: {
            args: Prisma.FileGroupByArgs<ExtArgs>
            result: $Utils.Optional<FileGroupByOutputType>[]
          }
          count: {
            args: Prisma.FileCountArgs<ExtArgs>
            result: $Utils.Optional<FileCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    session?: SessionOmit
    account?: AccountOmit
    verification?: VerificationOmit
    tenant?: TenantOmit
    property?: PropertyOmit
    unit?: UnitOmit
    lease?: LeaseOmit
    invoice?: InvoiceOmit
    recurringBillable?: RecurringBillableOmit
    transactions?: TransactionsOmit
    tenantLease?: TenantLeaseOmit
    maintenanceRequest?: MaintenanceRequestOmit
    file?: FileOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    property: number
    sessions: number
    tenant: number
    Invoice: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    property?: boolean | UserCountOutputTypeCountPropertyArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    tenant?: boolean | UserCountOutputTypeCountTenantArgs
    Invoice?: boolean | UserCountOutputTypeCountInvoiceArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPropertyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }


  /**
   * Count Type TenantCountOutputType
   */

  export type TenantCountOutputType = {
    files: number
    Invoice: number
    tenantLease: number
    recurringBillable: number
  }

  export type TenantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    files?: boolean | TenantCountOutputTypeCountFilesArgs
    Invoice?: boolean | TenantCountOutputTypeCountInvoiceArgs
    tenantLease?: boolean | TenantCountOutputTypeCountTenantLeaseArgs
    recurringBillable?: boolean | TenantCountOutputTypeCountRecurringBillableArgs
  }

  // Custom InputTypes
  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantCountOutputType
     */
    select?: TenantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountInvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountTenantLeaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantLeaseWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountRecurringBillableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecurringBillableWhereInput
  }


  /**
   * Count Type PropertyCountOutputType
   */

  export type PropertyCountOutputType = {
    files: number
    unit: number
    recurringBillable: number
  }

  export type PropertyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    files?: boolean | PropertyCountOutputTypeCountFilesArgs
    unit?: boolean | PropertyCountOutputTypeCountUnitArgs
    recurringBillable?: boolean | PropertyCountOutputTypeCountRecurringBillableArgs
  }

  // Custom InputTypes
  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCountOutputType
     */
    select?: PropertyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountUnitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountRecurringBillableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecurringBillableWhereInput
  }


  /**
   * Count Type UnitCountOutputType
   */

  export type UnitCountOutputType = {
    lease: number
  }

  export type UnitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lease?: boolean | UnitCountOutputTypeCountLeaseArgs
  }

  // Custom InputTypes
  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitCountOutputType
     */
    select?: UnitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountLeaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaseWhereInput
  }


  /**
   * Count Type LeaseCountOutputType
   */

  export type LeaseCountOutputType = {
    File: number
    invoice: number
    maintenanceRequest: number
    tenantLease: number
    transactions: number
    recurringBillable: number
  }

  export type LeaseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    File?: boolean | LeaseCountOutputTypeCountFileArgs
    invoice?: boolean | LeaseCountOutputTypeCountInvoiceArgs
    maintenanceRequest?: boolean | LeaseCountOutputTypeCountMaintenanceRequestArgs
    tenantLease?: boolean | LeaseCountOutputTypeCountTenantLeaseArgs
    transactions?: boolean | LeaseCountOutputTypeCountTransactionsArgs
    recurringBillable?: boolean | LeaseCountOutputTypeCountRecurringBillableArgs
  }

  // Custom InputTypes
  /**
   * LeaseCountOutputType without action
   */
  export type LeaseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaseCountOutputType
     */
    select?: LeaseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LeaseCountOutputType without action
   */
  export type LeaseCountOutputTypeCountFileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
  }

  /**
   * LeaseCountOutputType without action
   */
  export type LeaseCountOutputTypeCountInvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * LeaseCountOutputType without action
   */
  export type LeaseCountOutputTypeCountMaintenanceRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceRequestWhereInput
  }

  /**
   * LeaseCountOutputType without action
   */
  export type LeaseCountOutputTypeCountTenantLeaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantLeaseWhereInput
  }

  /**
   * LeaseCountOutputType without action
   */
  export type LeaseCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionsWhereInput
  }

  /**
   * LeaseCountOutputType without action
   */
  export type LeaseCountOutputTypeCountRecurringBillableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecurringBillableWhereInput
  }


  /**
   * Count Type InvoiceCountOutputType
   */

  export type InvoiceCountOutputType = {
    File: number
    transactions: number
  }

  export type InvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    File?: boolean | InvoiceCountOutputTypeCountFileArgs
    transactions?: boolean | InvoiceCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     */
    select?: InvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountFileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionsWhereInput
  }


  /**
   * Count Type RecurringBillableCountOutputType
   */

  export type RecurringBillableCountOutputType = {
    invoice: number
  }

  export type RecurringBillableCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | RecurringBillableCountOutputTypeCountInvoiceArgs
  }

  // Custom InputTypes
  /**
   * RecurringBillableCountOutputType without action
   */
  export type RecurringBillableCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringBillableCountOutputType
     */
    select?: RecurringBillableCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RecurringBillableCountOutputType without action
   */
  export type RecurringBillableCountOutputTypeCountInvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }


  /**
   * Count Type MaintenanceRequestCountOutputType
   */

  export type MaintenanceRequestCountOutputType = {
    File: number
  }

  export type MaintenanceRequestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    File?: boolean | MaintenanceRequestCountOutputTypeCountFileArgs
  }

  // Custom InputTypes
  /**
   * MaintenanceRequestCountOutputType without action
   */
  export type MaintenanceRequestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequestCountOutputType
     */
    select?: MaintenanceRequestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MaintenanceRequestCountOutputType without action
   */
  export type MaintenanceRequestCountOutputTypeCountFileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    numberOfProperties: number | null
    numberOfUnits: number | null
  }

  export type UserSumAggregateOutputType = {
    numberOfProperties: number | null
    numberOfUnits: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    idNumber: string | null
    paystackSplitGroupId: string | null
    paystackSubAccountId: string | null
    paystackSubscriptionId: string | null
    state: string | null
    zip: string | null
    onboardingCompleted: boolean | null
    businessName: string | null
    countryCode: string | null
    numberOfProperties: number | null
    numberOfUnits: number | null
    phone: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    idNumber: string | null
    paystackSplitGroupId: string | null
    paystackSubAccountId: string | null
    paystackSubscriptionId: string | null
    state: string | null
    zip: string | null
    onboardingCompleted: boolean | null
    businessName: string | null
    countryCode: string | null
    numberOfProperties: number | null
    numberOfUnits: number | null
    phone: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    image: number
    createdAt: number
    updatedAt: number
    addressLine1: number
    addressLine2: number
    city: number
    idNumber: number
    paystackSplitGroupId: number
    paystackSubAccountId: number
    paystackSubscriptionId: number
    state: number
    zip: number
    onboardingCompleted: number
    businessName: number
    countryCode: number
    numberOfProperties: number
    numberOfUnits: number
    phone: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    numberOfProperties?: true
    numberOfUnits?: true
  }

  export type UserSumAggregateInputType = {
    numberOfProperties?: true
    numberOfUnits?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    idNumber?: true
    paystackSplitGroupId?: true
    paystackSubAccountId?: true
    paystackSubscriptionId?: true
    state?: true
    zip?: true
    onboardingCompleted?: true
    businessName?: true
    countryCode?: true
    numberOfProperties?: true
    numberOfUnits?: true
    phone?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    idNumber?: true
    paystackSplitGroupId?: true
    paystackSubAccountId?: true
    paystackSubscriptionId?: true
    state?: true
    zip?: true
    onboardingCompleted?: true
    businessName?: true
    countryCode?: true
    numberOfProperties?: true
    numberOfUnits?: true
    phone?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    idNumber?: true
    paystackSplitGroupId?: true
    paystackSubAccountId?: true
    paystackSubscriptionId?: true
    state?: true
    zip?: true
    onboardingCompleted?: true
    businessName?: true
    countryCode?: true
    numberOfProperties?: true
    numberOfUnits?: true
    phone?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image: string | null
    createdAt: Date
    updatedAt: Date
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    idNumber: string | null
    paystackSplitGroupId: string | null
    paystackSubAccountId: string | null
    paystackSubscriptionId: string | null
    state: string | null
    zip: string | null
    onboardingCompleted: boolean
    businessName: string | null
    countryCode: string | null
    numberOfProperties: number | null
    numberOfUnits: number | null
    phone: string | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    idNumber?: boolean
    paystackSplitGroupId?: boolean
    paystackSubAccountId?: boolean
    paystackSubscriptionId?: boolean
    state?: boolean
    zip?: boolean
    onboardingCompleted?: boolean
    businessName?: boolean
    countryCode?: boolean
    numberOfProperties?: boolean
    numberOfUnits?: boolean
    phone?: boolean
    accounts?: boolean | User$accountsArgs<ExtArgs>
    property?: boolean | User$propertyArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    tenant?: boolean | User$tenantArgs<ExtArgs>
    Invoice?: boolean | User$InvoiceArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    idNumber?: boolean
    paystackSplitGroupId?: boolean
    paystackSubAccountId?: boolean
    paystackSubscriptionId?: boolean
    state?: boolean
    zip?: boolean
    onboardingCompleted?: boolean
    businessName?: boolean
    countryCode?: boolean
    numberOfProperties?: boolean
    numberOfUnits?: boolean
    phone?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    idNumber?: boolean
    paystackSplitGroupId?: boolean
    paystackSubAccountId?: boolean
    paystackSubscriptionId?: boolean
    state?: boolean
    zip?: boolean
    onboardingCompleted?: boolean
    businessName?: boolean
    countryCode?: boolean
    numberOfProperties?: boolean
    numberOfUnits?: boolean
    phone?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    idNumber?: boolean
    paystackSplitGroupId?: boolean
    paystackSubAccountId?: boolean
    paystackSubscriptionId?: boolean
    state?: boolean
    zip?: boolean
    onboardingCompleted?: boolean
    businessName?: boolean
    countryCode?: boolean
    numberOfProperties?: boolean
    numberOfUnits?: boolean
    phone?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "emailVerified" | "image" | "createdAt" | "updatedAt" | "addressLine1" | "addressLine2" | "city" | "idNumber" | "paystackSplitGroupId" | "paystackSubAccountId" | "paystackSubscriptionId" | "state" | "zip" | "onboardingCompleted" | "businessName" | "countryCode" | "numberOfProperties" | "numberOfUnits" | "phone", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | User$accountsArgs<ExtArgs>
    property?: boolean | User$propertyArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    tenant?: boolean | User$tenantArgs<ExtArgs>
    Invoice?: boolean | User$InvoiceArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      property: Prisma.$PropertyPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      tenant: Prisma.$TenantPayload<ExtArgs>[]
      Invoice: Prisma.$InvoicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      emailVerified: boolean
      image: string | null
      createdAt: Date
      updatedAt: Date
      addressLine1: string | null
      addressLine2: string | null
      city: string | null
      idNumber: string | null
      paystackSplitGroupId: string | null
      paystackSubAccountId: string | null
      paystackSubscriptionId: string | null
      state: string | null
      zip: string | null
      onboardingCompleted: boolean
      businessName: string | null
      countryCode: string | null
      numberOfProperties: number | null
      numberOfUnits: number | null
      phone: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    property<T extends User$propertyArgs<ExtArgs> = {}>(args?: Subset<T, User$propertyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tenant<T extends User$tenantArgs<ExtArgs> = {}>(args?: Subset<T, User$tenantArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Invoice<T extends User$InvoiceArgs<ExtArgs> = {}>(args?: Subset<T, User$InvoiceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly image: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly addressLine1: FieldRef<"User", 'String'>
    readonly addressLine2: FieldRef<"User", 'String'>
    readonly city: FieldRef<"User", 'String'>
    readonly idNumber: FieldRef<"User", 'String'>
    readonly paystackSplitGroupId: FieldRef<"User", 'String'>
    readonly paystackSubAccountId: FieldRef<"User", 'String'>
    readonly paystackSubscriptionId: FieldRef<"User", 'String'>
    readonly state: FieldRef<"User", 'String'>
    readonly zip: FieldRef<"User", 'String'>
    readonly onboardingCompleted: FieldRef<"User", 'Boolean'>
    readonly businessName: FieldRef<"User", 'String'>
    readonly countryCode: FieldRef<"User", 'String'>
    readonly numberOfProperties: FieldRef<"User", 'Int'>
    readonly numberOfUnits: FieldRef<"User", 'Int'>
    readonly phone: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.property
   */
  export type User$propertyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    where?: PropertyWhereInput
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    cursor?: PropertyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.tenant
   */
  export type User$tenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    where?: TenantWhereInput
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    cursor?: TenantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * User.Invoice
   */
  export type User$InvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    expiresAt: Date | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    userId: string | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    expiresAt: Date | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    userId: string | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    expiresAt: number
    token: number
    createdAt: number
    updatedAt: number
    ipAddress: number
    userAgent: number
    userId: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    expiresAt: Date
    token: string
    createdAt: Date
    updatedAt: Date
    ipAddress: string | null
    userAgent: string | null
    userId: string
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "expiresAt" | "token" | "createdAt" | "updatedAt" | "ipAddress" | "userAgent" | "userId", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      expiresAt: Date
      token: string
      createdAt: Date
      updatedAt: Date
      ipAddress: string | null
      userAgent: string | null
      userId: string
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly token: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    providerId: string | null
    userId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    providerId: string | null
    userId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    accountId: number
    providerId: number
    userId: number
    accessToken: number
    refreshToken: number
    idToken: number
    accessTokenExpiresAt: number
    refreshTokenExpiresAt: number
    scope: number
    password: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    accountId: string
    providerId: string
    userId: string
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accountId" | "providerId" | "userId" | "accessToken" | "refreshToken" | "idToken" | "accessTokenExpiresAt" | "refreshTokenExpiresAt" | "scope" | "password" | "createdAt" | "updatedAt", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      providerId: string
      userId: string
      accessToken: string | null
      refreshToken: string | null
      idToken: string | null
      accessTokenExpiresAt: Date | null
      refreshTokenExpiresAt: Date | null
      scope: string | null
      password: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly accountId: FieldRef<"Account", 'String'>
    readonly providerId: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly accessToken: FieldRef<"Account", 'String'>
    readonly refreshToken: FieldRef<"Account", 'String'>
    readonly idToken: FieldRef<"Account", 'String'>
    readonly accessTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly refreshTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly password: FieldRef<"Account", 'String'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Verification
   */

  export type AggregateVerification = {
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  export type VerificationMinAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationMaxAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationCountAggregateOutputType = {
    id: number
    identifier: number
    value: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VerificationMinAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationMaxAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationCountAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verification to aggregate.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Verifications
    **/
    _count?: true | VerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationMaxAggregateInputType
  }

  export type GetVerificationAggregateType<T extends VerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerification[P]>
      : GetScalarType<T[P], AggregateVerification[P]>
  }




  export type VerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationWhereInput
    orderBy?: VerificationOrderByWithAggregationInput | VerificationOrderByWithAggregationInput[]
    by: VerificationScalarFieldEnum[] | VerificationScalarFieldEnum
    having?: VerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationCountAggregateInputType | true
    _min?: VerificationMinAggregateInputType
    _max?: VerificationMaxAggregateInputType
  }

  export type VerificationGroupByOutputType = {
    id: string
    identifier: string
    value: string
    expiresAt: Date
    createdAt: Date | null
    updatedAt: Date | null
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  type GetVerificationGroupByPayload<T extends VerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationGroupByOutputType[P]>
        }
      >
    >


  export type VerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectScalar = {
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VerificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "identifier" | "value" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["verification"]>

  export type $VerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Verification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      identifier: string
      value: string
      expiresAt: Date
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["verification"]>
    composites: {}
  }

  type VerificationGetPayload<S extends boolean | null | undefined | VerificationDefaultArgs> = $Result.GetResult<Prisma.$VerificationPayload, S>

  type VerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationCountAggregateInputType | true
    }

  export interface VerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Verification'], meta: { name: 'Verification' } }
    /**
     * Find zero or one Verification that matches the filter.
     * @param {VerificationFindUniqueArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationFindUniqueArgs>(args: SelectSubset<T, VerificationFindUniqueArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Verification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationFindUniqueOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationFindFirstArgs>(args?: SelectSubset<T, VerificationFindFirstArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Verifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Verifications
     * const verifications = await prisma.verification.findMany()
     * 
     * // Get first 10 Verifications
     * const verifications = await prisma.verification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationWithIdOnly = await prisma.verification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationFindManyArgs>(args?: SelectSubset<T, VerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Verification.
     * @param {VerificationCreateArgs} args - Arguments to create a Verification.
     * @example
     * // Create one Verification
     * const Verification = await prisma.verification.create({
     *   data: {
     *     // ... data to create a Verification
     *   }
     * })
     * 
     */
    create<T extends VerificationCreateArgs>(args: SelectSubset<T, VerificationCreateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Verifications.
     * @param {VerificationCreateManyArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationCreateManyArgs>(args?: SelectSubset<T, VerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Verifications and returns the data saved in the database.
     * @param {VerificationCreateManyAndReturnArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Verification.
     * @param {VerificationDeleteArgs} args - Arguments to delete one Verification.
     * @example
     * // Delete one Verification
     * const Verification = await prisma.verification.delete({
     *   where: {
     *     // ... filter to delete one Verification
     *   }
     * })
     * 
     */
    delete<T extends VerificationDeleteArgs>(args: SelectSubset<T, VerificationDeleteArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Verification.
     * @param {VerificationUpdateArgs} args - Arguments to update one Verification.
     * @example
     * // Update one Verification
     * const verification = await prisma.verification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationUpdateArgs>(args: SelectSubset<T, VerificationUpdateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Verifications.
     * @param {VerificationDeleteManyArgs} args - Arguments to filter Verifications to delete.
     * @example
     * // Delete a few Verifications
     * const { count } = await prisma.verification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationDeleteManyArgs>(args?: SelectSubset<T, VerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationUpdateManyArgs>(args: SelectSubset<T, VerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications and returns the data updated in the database.
     * @param {VerificationUpdateManyAndReturnArgs} args - Arguments to update many Verifications.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Verification.
     * @param {VerificationUpsertArgs} args - Arguments to update or create a Verification.
     * @example
     * // Update or create a Verification
     * const verification = await prisma.verification.upsert({
     *   create: {
     *     // ... data to create a Verification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Verification we want to update
     *   }
     * })
     */
    upsert<T extends VerificationUpsertArgs>(args: SelectSubset<T, VerificationUpsertArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCountArgs} args - Arguments to filter Verifications to count.
     * @example
     * // Count the number of Verifications
     * const count = await prisma.verification.count({
     *   where: {
     *     // ... the filter for the Verifications we want to count
     *   }
     * })
    **/
    count<T extends VerificationCountArgs>(
      args?: Subset<T, VerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationAggregateArgs>(args: Subset<T, VerificationAggregateArgs>): Prisma.PrismaPromise<GetVerificationAggregateType<T>>

    /**
     * Group by Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationGroupByArgs['orderBy'] }
        : { orderBy?: VerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Verification model
   */
  readonly fields: VerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Verification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Verification model
   */
  interface VerificationFieldRefs {
    readonly id: FieldRef<"Verification", 'String'>
    readonly identifier: FieldRef<"Verification", 'String'>
    readonly value: FieldRef<"Verification", 'String'>
    readonly expiresAt: FieldRef<"Verification", 'DateTime'>
    readonly createdAt: FieldRef<"Verification", 'DateTime'>
    readonly updatedAt: FieldRef<"Verification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Verification findUnique
   */
  export type VerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findUniqueOrThrow
   */
  export type VerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findFirst
   */
  export type VerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findFirstOrThrow
   */
  export type VerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findMany
   */
  export type VerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verifications to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification create
   */
  export type VerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to create a Verification.
     */
    data: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
  }

  /**
   * Verification createMany
   */
  export type VerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification createManyAndReturn
   */
  export type VerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification update
   */
  export type VerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to update a Verification.
     */
    data: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
    /**
     * Choose, which Verification to update.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification updateMany
   */
  export type VerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification updateManyAndReturn
   */
  export type VerificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification upsert
   */
  export type VerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The filter to search for the Verification to update in case it exists.
     */
    where: VerificationWhereUniqueInput
    /**
     * In case the Verification found by the `where` argument doesn't exist, create a new Verification with this data.
     */
    create: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
    /**
     * In case the Verification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
  }

  /**
   * Verification delete
   */
  export type VerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter which Verification to delete.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification deleteMany
   */
  export type VerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verifications to delete
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to delete.
     */
    limit?: number
  }

  /**
   * Verification without action
   */
  export type VerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
  }


  /**
   * Model Tenant
   */

  export type AggregateTenant = {
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  export type TenantMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    email: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    landlordId: string | null
    dateOfBirth: Date | null
    avatarUrl: string | null
    fullName: string | null
    paystackCustomerId: string | null
  }

  export type TenantMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    email: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    landlordId: string | null
    dateOfBirth: Date | null
    avatarUrl: string | null
    fullName: string | null
    paystackCustomerId: string | null
  }

  export type TenantCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    email: number
    firstName: number
    lastName: number
    phone: number
    landlordId: number
    dateOfBirth: number
    tenantEmergencyContact: number
    tenantIncome: number
    additionalEmails: number
    additionalPhones: number
    emergencyContacts: number
    vehicles: number
    avatarUrl: number
    fullName: number
    paystackCustomerId: number
    _all: number
  }


  export type TenantMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    email?: true
    firstName?: true
    lastName?: true
    phone?: true
    landlordId?: true
    dateOfBirth?: true
    avatarUrl?: true
    fullName?: true
    paystackCustomerId?: true
  }

  export type TenantMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    email?: true
    firstName?: true
    lastName?: true
    phone?: true
    landlordId?: true
    dateOfBirth?: true
    avatarUrl?: true
    fullName?: true
    paystackCustomerId?: true
  }

  export type TenantCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    email?: true
    firstName?: true
    lastName?: true
    phone?: true
    landlordId?: true
    dateOfBirth?: true
    tenantEmergencyContact?: true
    tenantIncome?: true
    additionalEmails?: true
    additionalPhones?: true
    emergencyContacts?: true
    vehicles?: true
    avatarUrl?: true
    fullName?: true
    paystackCustomerId?: true
    _all?: true
  }

  export type TenantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenant to aggregate.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tenants
    **/
    _count?: true | TenantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantMaxAggregateInputType
  }

  export type GetTenantAggregateType<T extends TenantAggregateArgs> = {
        [P in keyof T & keyof AggregateTenant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenant[P]>
      : GetScalarType<T[P], AggregateTenant[P]>
  }




  export type TenantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantWhereInput
    orderBy?: TenantOrderByWithAggregationInput | TenantOrderByWithAggregationInput[]
    by: TenantScalarFieldEnum[] | TenantScalarFieldEnum
    having?: TenantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantCountAggregateInputType | true
    _min?: TenantMinAggregateInputType
    _max?: TenantMaxAggregateInputType
  }

  export type TenantGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    email: string
    firstName: string
    lastName: string
    phone: string
    landlordId: string
    dateOfBirth: Date | null
    tenantEmergencyContact: JsonValue | null
    tenantIncome: JsonValue | null
    additionalEmails: string[]
    additionalPhones: string[]
    emergencyContacts: JsonValue | null
    vehicles: JsonValue | null
    avatarUrl: string | null
    fullName: string | null
    paystackCustomerId: string | null
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  type GetTenantGroupByPayload<T extends TenantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantGroupByOutputType[P]>
            : GetScalarType<T[P], TenantGroupByOutputType[P]>
        }
      >
    >


  export type TenantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    landlordId?: boolean
    dateOfBirth?: boolean
    tenantEmergencyContact?: boolean
    tenantIncome?: boolean
    additionalEmails?: boolean
    additionalPhones?: boolean
    emergencyContacts?: boolean
    vehicles?: boolean
    avatarUrl?: boolean
    fullName?: boolean
    paystackCustomerId?: boolean
    files?: boolean | Tenant$filesArgs<ExtArgs>
    Invoice?: boolean | Tenant$InvoiceArgs<ExtArgs>
    landlord?: boolean | UserDefaultArgs<ExtArgs>
    tenantLease?: boolean | Tenant$tenantLeaseArgs<ExtArgs>
    recurringBillable?: boolean | Tenant$recurringBillableArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    landlordId?: boolean
    dateOfBirth?: boolean
    tenantEmergencyContact?: boolean
    tenantIncome?: boolean
    additionalEmails?: boolean
    additionalPhones?: boolean
    emergencyContacts?: boolean
    vehicles?: boolean
    avatarUrl?: boolean
    fullName?: boolean
    paystackCustomerId?: boolean
    landlord?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    landlordId?: boolean
    dateOfBirth?: boolean
    tenantEmergencyContact?: boolean
    tenantIncome?: boolean
    additionalEmails?: boolean
    additionalPhones?: boolean
    emergencyContacts?: boolean
    vehicles?: boolean
    avatarUrl?: boolean
    fullName?: boolean
    paystackCustomerId?: boolean
    landlord?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    landlordId?: boolean
    dateOfBirth?: boolean
    tenantEmergencyContact?: boolean
    tenantIncome?: boolean
    additionalEmails?: boolean
    additionalPhones?: boolean
    emergencyContacts?: boolean
    vehicles?: boolean
    avatarUrl?: boolean
    fullName?: boolean
    paystackCustomerId?: boolean
  }

  export type TenantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "email" | "firstName" | "lastName" | "phone" | "landlordId" | "dateOfBirth" | "tenantEmergencyContact" | "tenantIncome" | "additionalEmails" | "additionalPhones" | "emergencyContacts" | "vehicles" | "avatarUrl" | "fullName" | "paystackCustomerId", ExtArgs["result"]["tenant"]>
  export type TenantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    files?: boolean | Tenant$filesArgs<ExtArgs>
    Invoice?: boolean | Tenant$InvoiceArgs<ExtArgs>
    landlord?: boolean | UserDefaultArgs<ExtArgs>
    tenantLease?: boolean | Tenant$tenantLeaseArgs<ExtArgs>
    recurringBillable?: boolean | Tenant$recurringBillableArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TenantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    landlord?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TenantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    landlord?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TenantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tenant"
    objects: {
      files: Prisma.$FilePayload<ExtArgs>[]
      Invoice: Prisma.$InvoicePayload<ExtArgs>[]
      landlord: Prisma.$UserPayload<ExtArgs>
      tenantLease: Prisma.$TenantLeasePayload<ExtArgs>[]
      recurringBillable: Prisma.$RecurringBillablePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      email: string
      firstName: string
      lastName: string
      phone: string
      landlordId: string
      dateOfBirth: Date | null
      tenantEmergencyContact: Prisma.JsonValue | null
      tenantIncome: Prisma.JsonValue | null
      additionalEmails: string[]
      additionalPhones: string[]
      emergencyContacts: Prisma.JsonValue | null
      vehicles: Prisma.JsonValue | null
      avatarUrl: string | null
      fullName: string | null
      paystackCustomerId: string | null
    }, ExtArgs["result"]["tenant"]>
    composites: {}
  }

  type TenantGetPayload<S extends boolean | null | undefined | TenantDefaultArgs> = $Result.GetResult<Prisma.$TenantPayload, S>

  type TenantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TenantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantCountAggregateInputType | true
    }

  export interface TenantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tenant'], meta: { name: 'Tenant' } }
    /**
     * Find zero or one Tenant that matches the filter.
     * @param {TenantFindUniqueArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantFindUniqueArgs>(args: SelectSubset<T, TenantFindUniqueArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tenant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TenantFindUniqueOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tenant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantFindFirstArgs>(args?: SelectSubset<T, TenantFindFirstArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tenant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tenants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tenants
     * const tenants = await prisma.tenant.findMany()
     * 
     * // Get first 10 Tenants
     * const tenants = await prisma.tenant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantWithIdOnly = await prisma.tenant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantFindManyArgs>(args?: SelectSubset<T, TenantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tenant.
     * @param {TenantCreateArgs} args - Arguments to create a Tenant.
     * @example
     * // Create one Tenant
     * const Tenant = await prisma.tenant.create({
     *   data: {
     *     // ... data to create a Tenant
     *   }
     * })
     * 
     */
    create<T extends TenantCreateArgs>(args: SelectSubset<T, TenantCreateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tenants.
     * @param {TenantCreateManyArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantCreateManyArgs>(args?: SelectSubset<T, TenantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tenants and returns the data saved in the database.
     * @param {TenantCreateManyAndReturnArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tenant.
     * @param {TenantDeleteArgs} args - Arguments to delete one Tenant.
     * @example
     * // Delete one Tenant
     * const Tenant = await prisma.tenant.delete({
     *   where: {
     *     // ... filter to delete one Tenant
     *   }
     * })
     * 
     */
    delete<T extends TenantDeleteArgs>(args: SelectSubset<T, TenantDeleteArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tenant.
     * @param {TenantUpdateArgs} args - Arguments to update one Tenant.
     * @example
     * // Update one Tenant
     * const tenant = await prisma.tenant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantUpdateArgs>(args: SelectSubset<T, TenantUpdateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tenants.
     * @param {TenantDeleteManyArgs} args - Arguments to filter Tenants to delete.
     * @example
     * // Delete a few Tenants
     * const { count } = await prisma.tenant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantDeleteManyArgs>(args?: SelectSubset<T, TenantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantUpdateManyArgs>(args: SelectSubset<T, TenantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants and returns the data updated in the database.
     * @param {TenantUpdateManyAndReturnArgs} args - Arguments to update many Tenants.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TenantUpdateManyAndReturnArgs>(args: SelectSubset<T, TenantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tenant.
     * @param {TenantUpsertArgs} args - Arguments to update or create a Tenant.
     * @example
     * // Update or create a Tenant
     * const tenant = await prisma.tenant.upsert({
     *   create: {
     *     // ... data to create a Tenant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tenant we want to update
     *   }
     * })
     */
    upsert<T extends TenantUpsertArgs>(args: SelectSubset<T, TenantUpsertArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantCountArgs} args - Arguments to filter Tenants to count.
     * @example
     * // Count the number of Tenants
     * const count = await prisma.tenant.count({
     *   where: {
     *     // ... the filter for the Tenants we want to count
     *   }
     * })
    **/
    count<T extends TenantCountArgs>(
      args?: Subset<T, TenantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantAggregateArgs>(args: Subset<T, TenantAggregateArgs>): Prisma.PrismaPromise<GetTenantAggregateType<T>>

    /**
     * Group by Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantGroupByArgs['orderBy'] }
        : { orderBy?: TenantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tenant model
   */
  readonly fields: TenantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tenant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    files<T extends Tenant$filesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Invoice<T extends Tenant$InvoiceArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$InvoiceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    landlord<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tenantLease<T extends Tenant$tenantLeaseArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$tenantLeaseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantLeasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    recurringBillable<T extends Tenant$recurringBillableArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$recurringBillableArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringBillablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tenant model
   */
  interface TenantFieldRefs {
    readonly id: FieldRef<"Tenant", 'String'>
    readonly createdAt: FieldRef<"Tenant", 'DateTime'>
    readonly updatedAt: FieldRef<"Tenant", 'DateTime'>
    readonly email: FieldRef<"Tenant", 'String'>
    readonly firstName: FieldRef<"Tenant", 'String'>
    readonly lastName: FieldRef<"Tenant", 'String'>
    readonly phone: FieldRef<"Tenant", 'String'>
    readonly landlordId: FieldRef<"Tenant", 'String'>
    readonly dateOfBirth: FieldRef<"Tenant", 'DateTime'>
    readonly tenantEmergencyContact: FieldRef<"Tenant", 'Json'>
    readonly tenantIncome: FieldRef<"Tenant", 'Json'>
    readonly additionalEmails: FieldRef<"Tenant", 'String[]'>
    readonly additionalPhones: FieldRef<"Tenant", 'String[]'>
    readonly emergencyContacts: FieldRef<"Tenant", 'Json'>
    readonly vehicles: FieldRef<"Tenant", 'Json'>
    readonly avatarUrl: FieldRef<"Tenant", 'String'>
    readonly fullName: FieldRef<"Tenant", 'String'>
    readonly paystackCustomerId: FieldRef<"Tenant", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Tenant findUnique
   */
  export type TenantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findUniqueOrThrow
   */
  export type TenantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findFirst
   */
  export type TenantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findFirstOrThrow
   */
  export type TenantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findMany
   */
  export type TenantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenants to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant create
   */
  export type TenantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to create a Tenant.
     */
    data: XOR<TenantCreateInput, TenantUncheckedCreateInput>
  }

  /**
   * Tenant createMany
   */
  export type TenantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant createManyAndReturn
   */
  export type TenantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tenant update
   */
  export type TenantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to update a Tenant.
     */
    data: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
    /**
     * Choose, which Tenant to update.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant updateMany
   */
  export type TenantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to update.
     */
    limit?: number
  }

  /**
   * Tenant updateManyAndReturn
   */
  export type TenantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tenant upsert
   */
  export type TenantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The filter to search for the Tenant to update in case it exists.
     */
    where: TenantWhereUniqueInput
    /**
     * In case the Tenant found by the `where` argument doesn't exist, create a new Tenant with this data.
     */
    create: XOR<TenantCreateInput, TenantUncheckedCreateInput>
    /**
     * In case the Tenant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
  }

  /**
   * Tenant delete
   */
  export type TenantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter which Tenant to delete.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant deleteMany
   */
  export type TenantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenants to delete
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to delete.
     */
    limit?: number
  }

  /**
   * Tenant.files
   */
  export type Tenant$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    cursor?: FileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * Tenant.Invoice
   */
  export type Tenant$InvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Tenant.tenantLease
   */
  export type Tenant$tenantLeaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantLease
     */
    select?: TenantLeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantLease
     */
    omit?: TenantLeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantLeaseInclude<ExtArgs> | null
    where?: TenantLeaseWhereInput
    orderBy?: TenantLeaseOrderByWithRelationInput | TenantLeaseOrderByWithRelationInput[]
    cursor?: TenantLeaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TenantLeaseScalarFieldEnum | TenantLeaseScalarFieldEnum[]
  }

  /**
   * Tenant.recurringBillable
   */
  export type Tenant$recurringBillableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringBillable
     */
    select?: RecurringBillableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringBillable
     */
    omit?: RecurringBillableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringBillableInclude<ExtArgs> | null
    where?: RecurringBillableWhereInput
    orderBy?: RecurringBillableOrderByWithRelationInput | RecurringBillableOrderByWithRelationInput[]
    cursor?: RecurringBillableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecurringBillableScalarFieldEnum | RecurringBillableScalarFieldEnum[]
  }

  /**
   * Tenant without action
   */
  export type TenantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
  }


  /**
   * Model Property
   */

  export type AggregateProperty = {
    _count: PropertyCountAggregateOutputType | null
    _min: PropertyMinAggregateOutputType | null
    _max: PropertyMaxAggregateOutputType | null
  }

  export type PropertyMinAggregateOutputType = {
    id: string | null
    name: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    state: string | null
    zip: string | null
    createdAt: Date | null
    updatedAt: Date | null
    imageUrl: string | null
    propertyStatus: $Enums.PropertyStatus | null
    propertyType: $Enums.PropertyType | null
    countryCode: string | null
    landlordId: string | null
  }

  export type PropertyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    state: string | null
    zip: string | null
    createdAt: Date | null
    updatedAt: Date | null
    imageUrl: string | null
    propertyStatus: $Enums.PropertyStatus | null
    propertyType: $Enums.PropertyType | null
    countryCode: string | null
    landlordId: string | null
  }

  export type PropertyCountAggregateOutputType = {
    id: number
    name: number
    addressLine1: number
    addressLine2: number
    city: number
    state: number
    zip: number
    createdAt: number
    updatedAt: number
    imageUrl: number
    propertyStatus: number
    propertyType: number
    amenities: number
    countryCode: number
    features: number
    landlordId: number
    _all: number
  }


  export type PropertyMinAggregateInputType = {
    id?: true
    name?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    state?: true
    zip?: true
    createdAt?: true
    updatedAt?: true
    imageUrl?: true
    propertyStatus?: true
    propertyType?: true
    countryCode?: true
    landlordId?: true
  }

  export type PropertyMaxAggregateInputType = {
    id?: true
    name?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    state?: true
    zip?: true
    createdAt?: true
    updatedAt?: true
    imageUrl?: true
    propertyStatus?: true
    propertyType?: true
    countryCode?: true
    landlordId?: true
  }

  export type PropertyCountAggregateInputType = {
    id?: true
    name?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    state?: true
    zip?: true
    createdAt?: true
    updatedAt?: true
    imageUrl?: true
    propertyStatus?: true
    propertyType?: true
    amenities?: true
    countryCode?: true
    features?: true
    landlordId?: true
    _all?: true
  }

  export type PropertyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Property to aggregate.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Properties
    **/
    _count?: true | PropertyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyMaxAggregateInputType
  }

  export type GetPropertyAggregateType<T extends PropertyAggregateArgs> = {
        [P in keyof T & keyof AggregateProperty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProperty[P]>
      : GetScalarType<T[P], AggregateProperty[P]>
  }




  export type PropertyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyWhereInput
    orderBy?: PropertyOrderByWithAggregationInput | PropertyOrderByWithAggregationInput[]
    by: PropertyScalarFieldEnum[] | PropertyScalarFieldEnum
    having?: PropertyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyCountAggregateInputType | true
    _min?: PropertyMinAggregateInputType
    _max?: PropertyMaxAggregateInputType
  }

  export type PropertyGroupByOutputType = {
    id: string
    name: string
    addressLine1: string
    addressLine2: string | null
    city: string
    state: string
    zip: string
    createdAt: Date
    updatedAt: Date
    imageUrl: string | null
    propertyStatus: $Enums.PropertyStatus
    propertyType: $Enums.PropertyType
    amenities: string[]
    countryCode: string
    features: string[]
    landlordId: string
    _count: PropertyCountAggregateOutputType | null
    _min: PropertyMinAggregateOutputType | null
    _max: PropertyMaxAggregateOutputType | null
  }

  type GetPropertyGroupByPayload<T extends PropertyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyGroupByOutputType[P]>
        }
      >
    >


  export type PropertySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    zip?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    imageUrl?: boolean
    propertyStatus?: boolean
    propertyType?: boolean
    amenities?: boolean
    countryCode?: boolean
    features?: boolean
    landlordId?: boolean
    files?: boolean | Property$filesArgs<ExtArgs>
    landlord?: boolean | UserDefaultArgs<ExtArgs>
    unit?: boolean | Property$unitArgs<ExtArgs>
    recurringBillable?: boolean | Property$recurringBillableArgs<ExtArgs>
    _count?: boolean | PropertyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["property"]>

  export type PropertySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    zip?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    imageUrl?: boolean
    propertyStatus?: boolean
    propertyType?: boolean
    amenities?: boolean
    countryCode?: boolean
    features?: boolean
    landlordId?: boolean
    landlord?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["property"]>

  export type PropertySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    zip?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    imageUrl?: boolean
    propertyStatus?: boolean
    propertyType?: boolean
    amenities?: boolean
    countryCode?: boolean
    features?: boolean
    landlordId?: boolean
    landlord?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["property"]>

  export type PropertySelectScalar = {
    id?: boolean
    name?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    zip?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    imageUrl?: boolean
    propertyStatus?: boolean
    propertyType?: boolean
    amenities?: boolean
    countryCode?: boolean
    features?: boolean
    landlordId?: boolean
  }

  export type PropertyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "addressLine1" | "addressLine2" | "city" | "state" | "zip" | "createdAt" | "updatedAt" | "imageUrl" | "propertyStatus" | "propertyType" | "amenities" | "countryCode" | "features" | "landlordId", ExtArgs["result"]["property"]>
  export type PropertyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    files?: boolean | Property$filesArgs<ExtArgs>
    landlord?: boolean | UserDefaultArgs<ExtArgs>
    unit?: boolean | Property$unitArgs<ExtArgs>
    recurringBillable?: boolean | Property$recurringBillableArgs<ExtArgs>
    _count?: boolean | PropertyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PropertyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    landlord?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PropertyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    landlord?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PropertyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Property"
    objects: {
      files: Prisma.$FilePayload<ExtArgs>[]
      landlord: Prisma.$UserPayload<ExtArgs>
      unit: Prisma.$UnitPayload<ExtArgs>[]
      recurringBillable: Prisma.$RecurringBillablePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      addressLine1: string
      addressLine2: string | null
      city: string
      state: string
      zip: string
      createdAt: Date
      updatedAt: Date
      imageUrl: string | null
      propertyStatus: $Enums.PropertyStatus
      propertyType: $Enums.PropertyType
      amenities: string[]
      countryCode: string
      features: string[]
      landlordId: string
    }, ExtArgs["result"]["property"]>
    composites: {}
  }

  type PropertyGetPayload<S extends boolean | null | undefined | PropertyDefaultArgs> = $Result.GetResult<Prisma.$PropertyPayload, S>

  type PropertyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PropertyCountAggregateInputType | true
    }

  export interface PropertyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Property'], meta: { name: 'Property' } }
    /**
     * Find zero or one Property that matches the filter.
     * @param {PropertyFindUniqueArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyFindUniqueArgs>(args: SelectSubset<T, PropertyFindUniqueArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Property that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyFindUniqueOrThrowArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Property that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindFirstArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyFindFirstArgs>(args?: SelectSubset<T, PropertyFindFirstArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Property that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindFirstOrThrowArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Properties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Properties
     * const properties = await prisma.property.findMany()
     * 
     * // Get first 10 Properties
     * const properties = await prisma.property.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyWithIdOnly = await prisma.property.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyFindManyArgs>(args?: SelectSubset<T, PropertyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Property.
     * @param {PropertyCreateArgs} args - Arguments to create a Property.
     * @example
     * // Create one Property
     * const Property = await prisma.property.create({
     *   data: {
     *     // ... data to create a Property
     *   }
     * })
     * 
     */
    create<T extends PropertyCreateArgs>(args: SelectSubset<T, PropertyCreateArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Properties.
     * @param {PropertyCreateManyArgs} args - Arguments to create many Properties.
     * @example
     * // Create many Properties
     * const property = await prisma.property.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyCreateManyArgs>(args?: SelectSubset<T, PropertyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Properties and returns the data saved in the database.
     * @param {PropertyCreateManyAndReturnArgs} args - Arguments to create many Properties.
     * @example
     * // Create many Properties
     * const property = await prisma.property.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Properties and only return the `id`
     * const propertyWithIdOnly = await prisma.property.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Property.
     * @param {PropertyDeleteArgs} args - Arguments to delete one Property.
     * @example
     * // Delete one Property
     * const Property = await prisma.property.delete({
     *   where: {
     *     // ... filter to delete one Property
     *   }
     * })
     * 
     */
    delete<T extends PropertyDeleteArgs>(args: SelectSubset<T, PropertyDeleteArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Property.
     * @param {PropertyUpdateArgs} args - Arguments to update one Property.
     * @example
     * // Update one Property
     * const property = await prisma.property.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyUpdateArgs>(args: SelectSubset<T, PropertyUpdateArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Properties.
     * @param {PropertyDeleteManyArgs} args - Arguments to filter Properties to delete.
     * @example
     * // Delete a few Properties
     * const { count } = await prisma.property.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyDeleteManyArgs>(args?: SelectSubset<T, PropertyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Properties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Properties
     * const property = await prisma.property.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyUpdateManyArgs>(args: SelectSubset<T, PropertyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Properties and returns the data updated in the database.
     * @param {PropertyUpdateManyAndReturnArgs} args - Arguments to update many Properties.
     * @example
     * // Update many Properties
     * const property = await prisma.property.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Properties and only return the `id`
     * const propertyWithIdOnly = await prisma.property.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertyUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Property.
     * @param {PropertyUpsertArgs} args - Arguments to update or create a Property.
     * @example
     * // Update or create a Property
     * const property = await prisma.property.upsert({
     *   create: {
     *     // ... data to create a Property
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Property we want to update
     *   }
     * })
     */
    upsert<T extends PropertyUpsertArgs>(args: SelectSubset<T, PropertyUpsertArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Properties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyCountArgs} args - Arguments to filter Properties to count.
     * @example
     * // Count the number of Properties
     * const count = await prisma.property.count({
     *   where: {
     *     // ... the filter for the Properties we want to count
     *   }
     * })
    **/
    count<T extends PropertyCountArgs>(
      args?: Subset<T, PropertyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Property.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyAggregateArgs>(args: Subset<T, PropertyAggregateArgs>): Prisma.PrismaPromise<GetPropertyAggregateType<T>>

    /**
     * Group by Property.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyGroupByArgs['orderBy'] }
        : { orderBy?: PropertyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Property model
   */
  readonly fields: PropertyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Property.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    files<T extends Property$filesArgs<ExtArgs> = {}>(args?: Subset<T, Property$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    landlord<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    unit<T extends Property$unitArgs<ExtArgs> = {}>(args?: Subset<T, Property$unitArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    recurringBillable<T extends Property$recurringBillableArgs<ExtArgs> = {}>(args?: Subset<T, Property$recurringBillableArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringBillablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Property model
   */
  interface PropertyFieldRefs {
    readonly id: FieldRef<"Property", 'String'>
    readonly name: FieldRef<"Property", 'String'>
    readonly addressLine1: FieldRef<"Property", 'String'>
    readonly addressLine2: FieldRef<"Property", 'String'>
    readonly city: FieldRef<"Property", 'String'>
    readonly state: FieldRef<"Property", 'String'>
    readonly zip: FieldRef<"Property", 'String'>
    readonly createdAt: FieldRef<"Property", 'DateTime'>
    readonly updatedAt: FieldRef<"Property", 'DateTime'>
    readonly imageUrl: FieldRef<"Property", 'String'>
    readonly propertyStatus: FieldRef<"Property", 'PropertyStatus'>
    readonly propertyType: FieldRef<"Property", 'PropertyType'>
    readonly amenities: FieldRef<"Property", 'String[]'>
    readonly countryCode: FieldRef<"Property", 'String'>
    readonly features: FieldRef<"Property", 'String[]'>
    readonly landlordId: FieldRef<"Property", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Property findUnique
   */
  export type PropertyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property findUniqueOrThrow
   */
  export type PropertyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property findFirst
   */
  export type PropertyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Properties.
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Properties.
     */
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * Property findFirstOrThrow
   */
  export type PropertyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Properties.
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Properties.
     */
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * Property findMany
   */
  export type PropertyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Properties to fetch.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Properties.
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * Property create
   */
  export type PropertyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * The data needed to create a Property.
     */
    data: XOR<PropertyCreateInput, PropertyUncheckedCreateInput>
  }

  /**
   * Property createMany
   */
  export type PropertyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Properties.
     */
    data: PropertyCreateManyInput | PropertyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Property createManyAndReturn
   */
  export type PropertyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * The data used to create many Properties.
     */
    data: PropertyCreateManyInput | PropertyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Property update
   */
  export type PropertyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * The data needed to update a Property.
     */
    data: XOR<PropertyUpdateInput, PropertyUncheckedUpdateInput>
    /**
     * Choose, which Property to update.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property updateMany
   */
  export type PropertyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Properties.
     */
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyInput>
    /**
     * Filter which Properties to update
     */
    where?: PropertyWhereInput
    /**
     * Limit how many Properties to update.
     */
    limit?: number
  }

  /**
   * Property updateManyAndReturn
   */
  export type PropertyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * The data used to update Properties.
     */
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyInput>
    /**
     * Filter which Properties to update
     */
    where?: PropertyWhereInput
    /**
     * Limit how many Properties to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Property upsert
   */
  export type PropertyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * The filter to search for the Property to update in case it exists.
     */
    where: PropertyWhereUniqueInput
    /**
     * In case the Property found by the `where` argument doesn't exist, create a new Property with this data.
     */
    create: XOR<PropertyCreateInput, PropertyUncheckedCreateInput>
    /**
     * In case the Property was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyUpdateInput, PropertyUncheckedUpdateInput>
  }

  /**
   * Property delete
   */
  export type PropertyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter which Property to delete.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property deleteMany
   */
  export type PropertyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Properties to delete
     */
    where?: PropertyWhereInput
    /**
     * Limit how many Properties to delete.
     */
    limit?: number
  }

  /**
   * Property.files
   */
  export type Property$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    cursor?: FileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * Property.unit
   */
  export type Property$unitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    where?: UnitWhereInput
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    cursor?: UnitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Property.recurringBillable
   */
  export type Property$recurringBillableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringBillable
     */
    select?: RecurringBillableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringBillable
     */
    omit?: RecurringBillableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringBillableInclude<ExtArgs> | null
    where?: RecurringBillableWhereInput
    orderBy?: RecurringBillableOrderByWithRelationInput | RecurringBillableOrderByWithRelationInput[]
    cursor?: RecurringBillableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecurringBillableScalarFieldEnum | RecurringBillableScalarFieldEnum[]
  }

  /**
   * Property without action
   */
  export type PropertyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
  }


  /**
   * Model Unit
   */

  export type AggregateUnit = {
    _count: UnitCountAggregateOutputType | null
    _avg: UnitAvgAggregateOutputType | null
    _sum: UnitSumAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  export type UnitAvgAggregateOutputType = {
    bathrooms: number | null
    bedrooms: number | null
    deposit: number | null
    marketRent: number | null
    sqmt: number | null
  }

  export type UnitSumAggregateOutputType = {
    bathrooms: number | null
    bedrooms: number | null
    deposit: number | null
    marketRent: number | null
    sqmt: number | null
  }

  export type UnitMinAggregateOutputType = {
    id: string | null
    propertyId: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    bathrooms: number | null
    bedrooms: number | null
    deposit: number | null
    marketRent: number | null
    sqmt: number | null
  }

  export type UnitMaxAggregateOutputType = {
    id: string | null
    propertyId: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    bathrooms: number | null
    bedrooms: number | null
    deposit: number | null
    marketRent: number | null
    sqmt: number | null
  }

  export type UnitCountAggregateOutputType = {
    id: number
    propertyId: number
    name: number
    createdAt: number
    updatedAt: number
    bathrooms: number
    bedrooms: number
    deposit: number
    marketRent: number
    sqmt: number
    _all: number
  }


  export type UnitAvgAggregateInputType = {
    bathrooms?: true
    bedrooms?: true
    deposit?: true
    marketRent?: true
    sqmt?: true
  }

  export type UnitSumAggregateInputType = {
    bathrooms?: true
    bedrooms?: true
    deposit?: true
    marketRent?: true
    sqmt?: true
  }

  export type UnitMinAggregateInputType = {
    id?: true
    propertyId?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    bathrooms?: true
    bedrooms?: true
    deposit?: true
    marketRent?: true
    sqmt?: true
  }

  export type UnitMaxAggregateInputType = {
    id?: true
    propertyId?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    bathrooms?: true
    bedrooms?: true
    deposit?: true
    marketRent?: true
    sqmt?: true
  }

  export type UnitCountAggregateInputType = {
    id?: true
    propertyId?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    bathrooms?: true
    bedrooms?: true
    deposit?: true
    marketRent?: true
    sqmt?: true
    _all?: true
  }

  export type UnitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Unit to aggregate.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Units
    **/
    _count?: true | UnitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitMaxAggregateInputType
  }

  export type GetUnitAggregateType<T extends UnitAggregateArgs> = {
        [P in keyof T & keyof AggregateUnit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnit[P]>
      : GetScalarType<T[P], AggregateUnit[P]>
  }




  export type UnitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitWhereInput
    orderBy?: UnitOrderByWithAggregationInput | UnitOrderByWithAggregationInput[]
    by: UnitScalarFieldEnum[] | UnitScalarFieldEnum
    having?: UnitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitCountAggregateInputType | true
    _avg?: UnitAvgAggregateInputType
    _sum?: UnitSumAggregateInputType
    _min?: UnitMinAggregateInputType
    _max?: UnitMaxAggregateInputType
  }

  export type UnitGroupByOutputType = {
    id: string
    propertyId: string
    name: string
    createdAt: Date
    updatedAt: Date
    bathrooms: number
    bedrooms: number
    deposit: number
    marketRent: number
    sqmt: number
    _count: UnitCountAggregateOutputType | null
    _avg: UnitAvgAggregateOutputType | null
    _sum: UnitSumAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  type GetUnitGroupByPayload<T extends UnitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitGroupByOutputType[P]>
            : GetScalarType<T[P], UnitGroupByOutputType[P]>
        }
      >
    >


  export type UnitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bathrooms?: boolean
    bedrooms?: boolean
    deposit?: boolean
    marketRent?: boolean
    sqmt?: boolean
    lease?: boolean | Unit$leaseArgs<ExtArgs>
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    _count?: boolean | UnitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unit"]>

  export type UnitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bathrooms?: boolean
    bedrooms?: boolean
    deposit?: boolean
    marketRent?: boolean
    sqmt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unit"]>

  export type UnitSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bathrooms?: boolean
    bedrooms?: boolean
    deposit?: boolean
    marketRent?: boolean
    sqmt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unit"]>

  export type UnitSelectScalar = {
    id?: boolean
    propertyId?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bathrooms?: boolean
    bedrooms?: boolean
    deposit?: boolean
    marketRent?: boolean
    sqmt?: boolean
  }

  export type UnitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "propertyId" | "name" | "createdAt" | "updatedAt" | "bathrooms" | "bedrooms" | "deposit" | "marketRent" | "sqmt", ExtArgs["result"]["unit"]>
  export type UnitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lease?: boolean | Unit$leaseArgs<ExtArgs>
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    _count?: boolean | UnitCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UnitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type UnitIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }

  export type $UnitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Unit"
    objects: {
      lease: Prisma.$LeasePayload<ExtArgs>[]
      property: Prisma.$PropertyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      propertyId: string
      name: string
      createdAt: Date
      updatedAt: Date
      bathrooms: number
      bedrooms: number
      deposit: number
      marketRent: number
      sqmt: number
    }, ExtArgs["result"]["unit"]>
    composites: {}
  }

  type UnitGetPayload<S extends boolean | null | undefined | UnitDefaultArgs> = $Result.GetResult<Prisma.$UnitPayload, S>

  type UnitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UnitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UnitCountAggregateInputType | true
    }

  export interface UnitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Unit'], meta: { name: 'Unit' } }
    /**
     * Find zero or one Unit that matches the filter.
     * @param {UnitFindUniqueArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitFindUniqueArgs>(args: SelectSubset<T, UnitFindUniqueArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Unit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UnitFindUniqueOrThrowArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Unit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindFirstArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitFindFirstArgs>(args?: SelectSubset<T, UnitFindFirstArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Unit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindFirstOrThrowArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Units that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Units
     * const units = await prisma.unit.findMany()
     * 
     * // Get first 10 Units
     * const units = await prisma.unit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitWithIdOnly = await prisma.unit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnitFindManyArgs>(args?: SelectSubset<T, UnitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Unit.
     * @param {UnitCreateArgs} args - Arguments to create a Unit.
     * @example
     * // Create one Unit
     * const Unit = await prisma.unit.create({
     *   data: {
     *     // ... data to create a Unit
     *   }
     * })
     * 
     */
    create<T extends UnitCreateArgs>(args: SelectSubset<T, UnitCreateArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Units.
     * @param {UnitCreateManyArgs} args - Arguments to create many Units.
     * @example
     * // Create many Units
     * const unit = await prisma.unit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitCreateManyArgs>(args?: SelectSubset<T, UnitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Units and returns the data saved in the database.
     * @param {UnitCreateManyAndReturnArgs} args - Arguments to create many Units.
     * @example
     * // Create many Units
     * const unit = await prisma.unit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Units and only return the `id`
     * const unitWithIdOnly = await prisma.unit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UnitCreateManyAndReturnArgs>(args?: SelectSubset<T, UnitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Unit.
     * @param {UnitDeleteArgs} args - Arguments to delete one Unit.
     * @example
     * // Delete one Unit
     * const Unit = await prisma.unit.delete({
     *   where: {
     *     // ... filter to delete one Unit
     *   }
     * })
     * 
     */
    delete<T extends UnitDeleteArgs>(args: SelectSubset<T, UnitDeleteArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Unit.
     * @param {UnitUpdateArgs} args - Arguments to update one Unit.
     * @example
     * // Update one Unit
     * const unit = await prisma.unit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitUpdateArgs>(args: SelectSubset<T, UnitUpdateArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Units.
     * @param {UnitDeleteManyArgs} args - Arguments to filter Units to delete.
     * @example
     * // Delete a few Units
     * const { count } = await prisma.unit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitDeleteManyArgs>(args?: SelectSubset<T, UnitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Units
     * const unit = await prisma.unit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitUpdateManyArgs>(args: SelectSubset<T, UnitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Units and returns the data updated in the database.
     * @param {UnitUpdateManyAndReturnArgs} args - Arguments to update many Units.
     * @example
     * // Update many Units
     * const unit = await prisma.unit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Units and only return the `id`
     * const unitWithIdOnly = await prisma.unit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UnitUpdateManyAndReturnArgs>(args: SelectSubset<T, UnitUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Unit.
     * @param {UnitUpsertArgs} args - Arguments to update or create a Unit.
     * @example
     * // Update or create a Unit
     * const unit = await prisma.unit.upsert({
     *   create: {
     *     // ... data to create a Unit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Unit we want to update
     *   }
     * })
     */
    upsert<T extends UnitUpsertArgs>(args: SelectSubset<T, UnitUpsertArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitCountArgs} args - Arguments to filter Units to count.
     * @example
     * // Count the number of Units
     * const count = await prisma.unit.count({
     *   where: {
     *     // ... the filter for the Units we want to count
     *   }
     * })
    **/
    count<T extends UnitCountArgs>(
      args?: Subset<T, UnitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitAggregateArgs>(args: Subset<T, UnitAggregateArgs>): Prisma.PrismaPromise<GetUnitAggregateType<T>>

    /**
     * Group by Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitGroupByArgs['orderBy'] }
        : { orderBy?: UnitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Unit model
   */
  readonly fields: UnitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Unit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lease<T extends Unit$leaseArgs<ExtArgs> = {}>(args?: Subset<T, Unit$leaseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Unit model
   */
  interface UnitFieldRefs {
    readonly id: FieldRef<"Unit", 'String'>
    readonly propertyId: FieldRef<"Unit", 'String'>
    readonly name: FieldRef<"Unit", 'String'>
    readonly createdAt: FieldRef<"Unit", 'DateTime'>
    readonly updatedAt: FieldRef<"Unit", 'DateTime'>
    readonly bathrooms: FieldRef<"Unit", 'Float'>
    readonly bedrooms: FieldRef<"Unit", 'Int'>
    readonly deposit: FieldRef<"Unit", 'Float'>
    readonly marketRent: FieldRef<"Unit", 'Float'>
    readonly sqmt: FieldRef<"Unit", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Unit findUnique
   */
  export type UnitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit findUniqueOrThrow
   */
  export type UnitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit findFirst
   */
  export type UnitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit findFirstOrThrow
   */
  export type UnitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit findMany
   */
  export type UnitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Units to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit create
   */
  export type UnitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The data needed to create a Unit.
     */
    data: XOR<UnitCreateInput, UnitUncheckedCreateInput>
  }

  /**
   * Unit createMany
   */
  export type UnitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Units.
     */
    data: UnitCreateManyInput | UnitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Unit createManyAndReturn
   */
  export type UnitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * The data used to create many Units.
     */
    data: UnitCreateManyInput | UnitCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Unit update
   */
  export type UnitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The data needed to update a Unit.
     */
    data: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
    /**
     * Choose, which Unit to update.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit updateMany
   */
  export type UnitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Units.
     */
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyInput>
    /**
     * Filter which Units to update
     */
    where?: UnitWhereInput
    /**
     * Limit how many Units to update.
     */
    limit?: number
  }

  /**
   * Unit updateManyAndReturn
   */
  export type UnitUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * The data used to update Units.
     */
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyInput>
    /**
     * Filter which Units to update
     */
    where?: UnitWhereInput
    /**
     * Limit how many Units to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Unit upsert
   */
  export type UnitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The filter to search for the Unit to update in case it exists.
     */
    where: UnitWhereUniqueInput
    /**
     * In case the Unit found by the `where` argument doesn't exist, create a new Unit with this data.
     */
    create: XOR<UnitCreateInput, UnitUncheckedCreateInput>
    /**
     * In case the Unit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
  }

  /**
   * Unit delete
   */
  export type UnitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter which Unit to delete.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit deleteMany
   */
  export type UnitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Units to delete
     */
    where?: UnitWhereInput
    /**
     * Limit how many Units to delete.
     */
    limit?: number
  }

  /**
   * Unit.lease
   */
  export type Unit$leaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseInclude<ExtArgs> | null
    where?: LeaseWhereInput
    orderBy?: LeaseOrderByWithRelationInput | LeaseOrderByWithRelationInput[]
    cursor?: LeaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaseScalarFieldEnum | LeaseScalarFieldEnum[]
  }

  /**
   * Unit without action
   */
  export type UnitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
  }


  /**
   * Model Lease
   */

  export type AggregateLease = {
    _count: LeaseCountAggregateOutputType | null
    _avg: LeaseAvgAggregateOutputType | null
    _sum: LeaseSumAggregateOutputType | null
    _min: LeaseMinAggregateOutputType | null
    _max: LeaseMaxAggregateOutputType | null
  }

  export type LeaseAvgAggregateOutputType = {
    rent: number | null
    deposit: number | null
  }

  export type LeaseSumAggregateOutputType = {
    rent: number | null
    deposit: number | null
  }

  export type LeaseMinAggregateOutputType = {
    id: string | null
    startDate: Date | null
    endDate: Date | null
    rent: number | null
    deposit: number | null
    status: $Enums.LeaseStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    rentDueCurrency: string | null
    unitId: string | null
    automaticInvoice: boolean | null
    invoiceCycle: $Enums.InvoiceCycle | null
    leaseType: $Enums.LeaseTermType | null
  }

  export type LeaseMaxAggregateOutputType = {
    id: string | null
    startDate: Date | null
    endDate: Date | null
    rent: number | null
    deposit: number | null
    status: $Enums.LeaseStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    rentDueCurrency: string | null
    unitId: string | null
    automaticInvoice: boolean | null
    invoiceCycle: $Enums.InvoiceCycle | null
    leaseType: $Enums.LeaseTermType | null
  }

  export type LeaseCountAggregateOutputType = {
    id: number
    startDate: number
    endDate: number
    rent: number
    deposit: number
    status: number
    createdAt: number
    updatedAt: number
    rentDueCurrency: number
    unitId: number
    automaticInvoice: number
    invoiceCycle: number
    leaseType: number
    _all: number
  }


  export type LeaseAvgAggregateInputType = {
    rent?: true
    deposit?: true
  }

  export type LeaseSumAggregateInputType = {
    rent?: true
    deposit?: true
  }

  export type LeaseMinAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    rent?: true
    deposit?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    rentDueCurrency?: true
    unitId?: true
    automaticInvoice?: true
    invoiceCycle?: true
    leaseType?: true
  }

  export type LeaseMaxAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    rent?: true
    deposit?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    rentDueCurrency?: true
    unitId?: true
    automaticInvoice?: true
    invoiceCycle?: true
    leaseType?: true
  }

  export type LeaseCountAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    rent?: true
    deposit?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    rentDueCurrency?: true
    unitId?: true
    automaticInvoice?: true
    invoiceCycle?: true
    leaseType?: true
    _all?: true
  }

  export type LeaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lease to aggregate.
     */
    where?: LeaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leases to fetch.
     */
    orderBy?: LeaseOrderByWithRelationInput | LeaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Leases
    **/
    _count?: true | LeaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaseMaxAggregateInputType
  }

  export type GetLeaseAggregateType<T extends LeaseAggregateArgs> = {
        [P in keyof T & keyof AggregateLease]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLease[P]>
      : GetScalarType<T[P], AggregateLease[P]>
  }




  export type LeaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaseWhereInput
    orderBy?: LeaseOrderByWithAggregationInput | LeaseOrderByWithAggregationInput[]
    by: LeaseScalarFieldEnum[] | LeaseScalarFieldEnum
    having?: LeaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaseCountAggregateInputType | true
    _avg?: LeaseAvgAggregateInputType
    _sum?: LeaseSumAggregateInputType
    _min?: LeaseMinAggregateInputType
    _max?: LeaseMaxAggregateInputType
  }

  export type LeaseGroupByOutputType = {
    id: string
    startDate: Date
    endDate: Date | null
    rent: number
    deposit: number
    status: $Enums.LeaseStatus
    createdAt: Date
    updatedAt: Date
    rentDueCurrency: string
    unitId: string | null
    automaticInvoice: boolean
    invoiceCycle: $Enums.InvoiceCycle
    leaseType: $Enums.LeaseTermType
    _count: LeaseCountAggregateOutputType | null
    _avg: LeaseAvgAggregateOutputType | null
    _sum: LeaseSumAggregateOutputType | null
    _min: LeaseMinAggregateOutputType | null
    _max: LeaseMaxAggregateOutputType | null
  }

  type GetLeaseGroupByPayload<T extends LeaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaseGroupByOutputType[P]>
            : GetScalarType<T[P], LeaseGroupByOutputType[P]>
        }
      >
    >


  export type LeaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startDate?: boolean
    endDate?: boolean
    rent?: boolean
    deposit?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rentDueCurrency?: boolean
    unitId?: boolean
    automaticInvoice?: boolean
    invoiceCycle?: boolean
    leaseType?: boolean
    File?: boolean | Lease$FileArgs<ExtArgs>
    invoice?: boolean | Lease$invoiceArgs<ExtArgs>
    unit?: boolean | Lease$unitArgs<ExtArgs>
    maintenanceRequest?: boolean | Lease$maintenanceRequestArgs<ExtArgs>
    tenantLease?: boolean | Lease$tenantLeaseArgs<ExtArgs>
    transactions?: boolean | Lease$transactionsArgs<ExtArgs>
    recurringBillable?: boolean | Lease$recurringBillableArgs<ExtArgs>
    _count?: boolean | LeaseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lease"]>

  export type LeaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startDate?: boolean
    endDate?: boolean
    rent?: boolean
    deposit?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rentDueCurrency?: boolean
    unitId?: boolean
    automaticInvoice?: boolean
    invoiceCycle?: boolean
    leaseType?: boolean
    unit?: boolean | Lease$unitArgs<ExtArgs>
  }, ExtArgs["result"]["lease"]>

  export type LeaseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startDate?: boolean
    endDate?: boolean
    rent?: boolean
    deposit?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rentDueCurrency?: boolean
    unitId?: boolean
    automaticInvoice?: boolean
    invoiceCycle?: boolean
    leaseType?: boolean
    unit?: boolean | Lease$unitArgs<ExtArgs>
  }, ExtArgs["result"]["lease"]>

  export type LeaseSelectScalar = {
    id?: boolean
    startDate?: boolean
    endDate?: boolean
    rent?: boolean
    deposit?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rentDueCurrency?: boolean
    unitId?: boolean
    automaticInvoice?: boolean
    invoiceCycle?: boolean
    leaseType?: boolean
  }

  export type LeaseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "startDate" | "endDate" | "rent" | "deposit" | "status" | "createdAt" | "updatedAt" | "rentDueCurrency" | "unitId" | "automaticInvoice" | "invoiceCycle" | "leaseType", ExtArgs["result"]["lease"]>
  export type LeaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    File?: boolean | Lease$FileArgs<ExtArgs>
    invoice?: boolean | Lease$invoiceArgs<ExtArgs>
    unit?: boolean | Lease$unitArgs<ExtArgs>
    maintenanceRequest?: boolean | Lease$maintenanceRequestArgs<ExtArgs>
    tenantLease?: boolean | Lease$tenantLeaseArgs<ExtArgs>
    transactions?: boolean | Lease$transactionsArgs<ExtArgs>
    recurringBillable?: boolean | Lease$recurringBillableArgs<ExtArgs>
    _count?: boolean | LeaseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LeaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | Lease$unitArgs<ExtArgs>
  }
  export type LeaseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | Lease$unitArgs<ExtArgs>
  }

  export type $LeasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lease"
    objects: {
      File: Prisma.$FilePayload<ExtArgs>[]
      invoice: Prisma.$InvoicePayload<ExtArgs>[]
      unit: Prisma.$UnitPayload<ExtArgs> | null
      maintenanceRequest: Prisma.$MaintenanceRequestPayload<ExtArgs>[]
      tenantLease: Prisma.$TenantLeasePayload<ExtArgs>[]
      transactions: Prisma.$TransactionsPayload<ExtArgs>[]
      recurringBillable: Prisma.$RecurringBillablePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      startDate: Date
      endDate: Date | null
      rent: number
      deposit: number
      status: $Enums.LeaseStatus
      createdAt: Date
      updatedAt: Date
      rentDueCurrency: string
      unitId: string | null
      automaticInvoice: boolean
      invoiceCycle: $Enums.InvoiceCycle
      leaseType: $Enums.LeaseTermType
    }, ExtArgs["result"]["lease"]>
    composites: {}
  }

  type LeaseGetPayload<S extends boolean | null | undefined | LeaseDefaultArgs> = $Result.GetResult<Prisma.$LeasePayload, S>

  type LeaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeaseCountAggregateInputType | true
    }

  export interface LeaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lease'], meta: { name: 'Lease' } }
    /**
     * Find zero or one Lease that matches the filter.
     * @param {LeaseFindUniqueArgs} args - Arguments to find a Lease
     * @example
     * // Get one Lease
     * const lease = await prisma.lease.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeaseFindUniqueArgs>(args: SelectSubset<T, LeaseFindUniqueArgs<ExtArgs>>): Prisma__LeaseClient<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lease that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeaseFindUniqueOrThrowArgs} args - Arguments to find a Lease
     * @example
     * // Get one Lease
     * const lease = await prisma.lease.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeaseFindUniqueOrThrowArgs>(args: SelectSubset<T, LeaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeaseClient<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lease that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaseFindFirstArgs} args - Arguments to find a Lease
     * @example
     * // Get one Lease
     * const lease = await prisma.lease.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeaseFindFirstArgs>(args?: SelectSubset<T, LeaseFindFirstArgs<ExtArgs>>): Prisma__LeaseClient<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lease that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaseFindFirstOrThrowArgs} args - Arguments to find a Lease
     * @example
     * // Get one Lease
     * const lease = await prisma.lease.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeaseFindFirstOrThrowArgs>(args?: SelectSubset<T, LeaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeaseClient<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Leases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leases
     * const leases = await prisma.lease.findMany()
     * 
     * // Get first 10 Leases
     * const leases = await prisma.lease.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaseWithIdOnly = await prisma.lease.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeaseFindManyArgs>(args?: SelectSubset<T, LeaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lease.
     * @param {LeaseCreateArgs} args - Arguments to create a Lease.
     * @example
     * // Create one Lease
     * const Lease = await prisma.lease.create({
     *   data: {
     *     // ... data to create a Lease
     *   }
     * })
     * 
     */
    create<T extends LeaseCreateArgs>(args: SelectSubset<T, LeaseCreateArgs<ExtArgs>>): Prisma__LeaseClient<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Leases.
     * @param {LeaseCreateManyArgs} args - Arguments to create many Leases.
     * @example
     * // Create many Leases
     * const lease = await prisma.lease.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeaseCreateManyArgs>(args?: SelectSubset<T, LeaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Leases and returns the data saved in the database.
     * @param {LeaseCreateManyAndReturnArgs} args - Arguments to create many Leases.
     * @example
     * // Create many Leases
     * const lease = await prisma.lease.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Leases and only return the `id`
     * const leaseWithIdOnly = await prisma.lease.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeaseCreateManyAndReturnArgs>(args?: SelectSubset<T, LeaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Lease.
     * @param {LeaseDeleteArgs} args - Arguments to delete one Lease.
     * @example
     * // Delete one Lease
     * const Lease = await prisma.lease.delete({
     *   where: {
     *     // ... filter to delete one Lease
     *   }
     * })
     * 
     */
    delete<T extends LeaseDeleteArgs>(args: SelectSubset<T, LeaseDeleteArgs<ExtArgs>>): Prisma__LeaseClient<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lease.
     * @param {LeaseUpdateArgs} args - Arguments to update one Lease.
     * @example
     * // Update one Lease
     * const lease = await prisma.lease.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeaseUpdateArgs>(args: SelectSubset<T, LeaseUpdateArgs<ExtArgs>>): Prisma__LeaseClient<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Leases.
     * @param {LeaseDeleteManyArgs} args - Arguments to filter Leases to delete.
     * @example
     * // Delete a few Leases
     * const { count } = await prisma.lease.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeaseDeleteManyArgs>(args?: SelectSubset<T, LeaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leases
     * const lease = await prisma.lease.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeaseUpdateManyArgs>(args: SelectSubset<T, LeaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leases and returns the data updated in the database.
     * @param {LeaseUpdateManyAndReturnArgs} args - Arguments to update many Leases.
     * @example
     * // Update many Leases
     * const lease = await prisma.lease.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Leases and only return the `id`
     * const leaseWithIdOnly = await prisma.lease.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeaseUpdateManyAndReturnArgs>(args: SelectSubset<T, LeaseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Lease.
     * @param {LeaseUpsertArgs} args - Arguments to update or create a Lease.
     * @example
     * // Update or create a Lease
     * const lease = await prisma.lease.upsert({
     *   create: {
     *     // ... data to create a Lease
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lease we want to update
     *   }
     * })
     */
    upsert<T extends LeaseUpsertArgs>(args: SelectSubset<T, LeaseUpsertArgs<ExtArgs>>): Prisma__LeaseClient<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Leases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaseCountArgs} args - Arguments to filter Leases to count.
     * @example
     * // Count the number of Leases
     * const count = await prisma.lease.count({
     *   where: {
     *     // ... the filter for the Leases we want to count
     *   }
     * })
    **/
    count<T extends LeaseCountArgs>(
      args?: Subset<T, LeaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lease.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaseAggregateArgs>(args: Subset<T, LeaseAggregateArgs>): Prisma.PrismaPromise<GetLeaseAggregateType<T>>

    /**
     * Group by Lease.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaseGroupByArgs['orderBy'] }
        : { orderBy?: LeaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lease model
   */
  readonly fields: LeaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lease.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    File<T extends Lease$FileArgs<ExtArgs> = {}>(args?: Subset<T, Lease$FileArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoice<T extends Lease$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, Lease$invoiceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    unit<T extends Lease$unitArgs<ExtArgs> = {}>(args?: Subset<T, Lease$unitArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    maintenanceRequest<T extends Lease$maintenanceRequestArgs<ExtArgs> = {}>(args?: Subset<T, Lease$maintenanceRequestArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tenantLease<T extends Lease$tenantLeaseArgs<ExtArgs> = {}>(args?: Subset<T, Lease$tenantLeaseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantLeasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactions<T extends Lease$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Lease$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    recurringBillable<T extends Lease$recurringBillableArgs<ExtArgs> = {}>(args?: Subset<T, Lease$recurringBillableArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringBillablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lease model
   */
  interface LeaseFieldRefs {
    readonly id: FieldRef<"Lease", 'String'>
    readonly startDate: FieldRef<"Lease", 'DateTime'>
    readonly endDate: FieldRef<"Lease", 'DateTime'>
    readonly rent: FieldRef<"Lease", 'Float'>
    readonly deposit: FieldRef<"Lease", 'Float'>
    readonly status: FieldRef<"Lease", 'LeaseStatus'>
    readonly createdAt: FieldRef<"Lease", 'DateTime'>
    readonly updatedAt: FieldRef<"Lease", 'DateTime'>
    readonly rentDueCurrency: FieldRef<"Lease", 'String'>
    readonly unitId: FieldRef<"Lease", 'String'>
    readonly automaticInvoice: FieldRef<"Lease", 'Boolean'>
    readonly invoiceCycle: FieldRef<"Lease", 'InvoiceCycle'>
    readonly leaseType: FieldRef<"Lease", 'LeaseTermType'>
  }
    

  // Custom InputTypes
  /**
   * Lease findUnique
   */
  export type LeaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseInclude<ExtArgs> | null
    /**
     * Filter, which Lease to fetch.
     */
    where: LeaseWhereUniqueInput
  }

  /**
   * Lease findUniqueOrThrow
   */
  export type LeaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseInclude<ExtArgs> | null
    /**
     * Filter, which Lease to fetch.
     */
    where: LeaseWhereUniqueInput
  }

  /**
   * Lease findFirst
   */
  export type LeaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseInclude<ExtArgs> | null
    /**
     * Filter, which Lease to fetch.
     */
    where?: LeaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leases to fetch.
     */
    orderBy?: LeaseOrderByWithRelationInput | LeaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leases.
     */
    cursor?: LeaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leases.
     */
    distinct?: LeaseScalarFieldEnum | LeaseScalarFieldEnum[]
  }

  /**
   * Lease findFirstOrThrow
   */
  export type LeaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseInclude<ExtArgs> | null
    /**
     * Filter, which Lease to fetch.
     */
    where?: LeaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leases to fetch.
     */
    orderBy?: LeaseOrderByWithRelationInput | LeaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leases.
     */
    cursor?: LeaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leases.
     */
    distinct?: LeaseScalarFieldEnum | LeaseScalarFieldEnum[]
  }

  /**
   * Lease findMany
   */
  export type LeaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseInclude<ExtArgs> | null
    /**
     * Filter, which Leases to fetch.
     */
    where?: LeaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leases to fetch.
     */
    orderBy?: LeaseOrderByWithRelationInput | LeaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Leases.
     */
    cursor?: LeaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leases.
     */
    skip?: number
    distinct?: LeaseScalarFieldEnum | LeaseScalarFieldEnum[]
  }

  /**
   * Lease create
   */
  export type LeaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseInclude<ExtArgs> | null
    /**
     * The data needed to create a Lease.
     */
    data: XOR<LeaseCreateInput, LeaseUncheckedCreateInput>
  }

  /**
   * Lease createMany
   */
  export type LeaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Leases.
     */
    data: LeaseCreateManyInput | LeaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lease createManyAndReturn
   */
  export type LeaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * The data used to create many Leases.
     */
    data: LeaseCreateManyInput | LeaseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lease update
   */
  export type LeaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseInclude<ExtArgs> | null
    /**
     * The data needed to update a Lease.
     */
    data: XOR<LeaseUpdateInput, LeaseUncheckedUpdateInput>
    /**
     * Choose, which Lease to update.
     */
    where: LeaseWhereUniqueInput
  }

  /**
   * Lease updateMany
   */
  export type LeaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Leases.
     */
    data: XOR<LeaseUpdateManyMutationInput, LeaseUncheckedUpdateManyInput>
    /**
     * Filter which Leases to update
     */
    where?: LeaseWhereInput
    /**
     * Limit how many Leases to update.
     */
    limit?: number
  }

  /**
   * Lease updateManyAndReturn
   */
  export type LeaseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * The data used to update Leases.
     */
    data: XOR<LeaseUpdateManyMutationInput, LeaseUncheckedUpdateManyInput>
    /**
     * Filter which Leases to update
     */
    where?: LeaseWhereInput
    /**
     * Limit how many Leases to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lease upsert
   */
  export type LeaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseInclude<ExtArgs> | null
    /**
     * The filter to search for the Lease to update in case it exists.
     */
    where: LeaseWhereUniqueInput
    /**
     * In case the Lease found by the `where` argument doesn't exist, create a new Lease with this data.
     */
    create: XOR<LeaseCreateInput, LeaseUncheckedCreateInput>
    /**
     * In case the Lease was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaseUpdateInput, LeaseUncheckedUpdateInput>
  }

  /**
   * Lease delete
   */
  export type LeaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseInclude<ExtArgs> | null
    /**
     * Filter which Lease to delete.
     */
    where: LeaseWhereUniqueInput
  }

  /**
   * Lease deleteMany
   */
  export type LeaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leases to delete
     */
    where?: LeaseWhereInput
    /**
     * Limit how many Leases to delete.
     */
    limit?: number
  }

  /**
   * Lease.File
   */
  export type Lease$FileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    cursor?: FileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * Lease.invoice
   */
  export type Lease$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Lease.unit
   */
  export type Lease$unitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    where?: UnitWhereInput
  }

  /**
   * Lease.maintenanceRequest
   */
  export type Lease$maintenanceRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    where?: MaintenanceRequestWhereInput
    orderBy?: MaintenanceRequestOrderByWithRelationInput | MaintenanceRequestOrderByWithRelationInput[]
    cursor?: MaintenanceRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaintenanceRequestScalarFieldEnum | MaintenanceRequestScalarFieldEnum[]
  }

  /**
   * Lease.tenantLease
   */
  export type Lease$tenantLeaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantLease
     */
    select?: TenantLeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantLease
     */
    omit?: TenantLeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantLeaseInclude<ExtArgs> | null
    where?: TenantLeaseWhereInput
    orderBy?: TenantLeaseOrderByWithRelationInput | TenantLeaseOrderByWithRelationInput[]
    cursor?: TenantLeaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TenantLeaseScalarFieldEnum | TenantLeaseScalarFieldEnum[]
  }

  /**
   * Lease.transactions
   */
  export type Lease$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    where?: TransactionsWhereInput
    orderBy?: TransactionsOrderByWithRelationInput | TransactionsOrderByWithRelationInput[]
    cursor?: TransactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * Lease.recurringBillable
   */
  export type Lease$recurringBillableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringBillable
     */
    select?: RecurringBillableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringBillable
     */
    omit?: RecurringBillableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringBillableInclude<ExtArgs> | null
    where?: RecurringBillableWhereInput
    orderBy?: RecurringBillableOrderByWithRelationInput | RecurringBillableOrderByWithRelationInput[]
    cursor?: RecurringBillableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecurringBillableScalarFieldEnum | RecurringBillableScalarFieldEnum[]
  }

  /**
   * Lease without action
   */
  export type LeaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    dueAmount: number | null
  }

  export type InvoiceSumAggregateOutputType = {
    dueAmount: number | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    leaseId: string | null
    description: string | null
    dueAmount: number | null
    category: $Enums.InvoiceCategory | null
    status: $Enums.InvoiceStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    paystackId: string | null
    dueDate: Date | null
    landlordId: string | null
    tenantId: string | null
    recurringBillableId: string | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    leaseId: string | null
    description: string | null
    dueAmount: number | null
    category: $Enums.InvoiceCategory | null
    status: $Enums.InvoiceStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    paystackId: string | null
    dueDate: Date | null
    landlordId: string | null
    tenantId: string | null
    recurringBillableId: string | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    leaseId: number
    description: number
    dueAmount: number
    category: number
    status: number
    createdAt: number
    updatedAt: number
    paystackId: number
    dueDate: number
    lineItems: number
    landlordId: number
    tenantId: number
    recurringBillableId: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    dueAmount?: true
  }

  export type InvoiceSumAggregateInputType = {
    dueAmount?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    leaseId?: true
    description?: true
    dueAmount?: true
    category?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    paystackId?: true
    dueDate?: true
    landlordId?: true
    tenantId?: true
    recurringBillableId?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    leaseId?: true
    description?: true
    dueAmount?: true
    category?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    paystackId?: true
    dueDate?: true
    landlordId?: true
    tenantId?: true
    recurringBillableId?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    leaseId?: true
    description?: true
    dueAmount?: true
    category?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    paystackId?: true
    dueDate?: true
    lineItems?: true
    landlordId?: true
    tenantId?: true
    recurringBillableId?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    leaseId: string | null
    description: string
    dueAmount: number
    category: $Enums.InvoiceCategory
    status: $Enums.InvoiceStatus
    createdAt: Date
    updatedAt: Date
    paystackId: string
    dueDate: Date | null
    lineItems: JsonValue | null
    landlordId: string
    tenantId: string
    recurringBillableId: string | null
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leaseId?: boolean
    description?: boolean
    dueAmount?: boolean
    category?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paystackId?: boolean
    dueDate?: boolean
    lineItems?: boolean
    landlordId?: boolean
    tenantId?: boolean
    recurringBillableId?: boolean
    File?: boolean | Invoice$FileArgs<ExtArgs>
    lease?: boolean | Invoice$leaseArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    transactions?: boolean | Invoice$transactionsArgs<ExtArgs>
    recurringBillable?: boolean | Invoice$recurringBillableArgs<ExtArgs>
    landlord?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leaseId?: boolean
    description?: boolean
    dueAmount?: boolean
    category?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paystackId?: boolean
    dueDate?: boolean
    lineItems?: boolean
    landlordId?: boolean
    tenantId?: boolean
    recurringBillableId?: boolean
    lease?: boolean | Invoice$leaseArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    recurringBillable?: boolean | Invoice$recurringBillableArgs<ExtArgs>
    landlord?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leaseId?: boolean
    description?: boolean
    dueAmount?: boolean
    category?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paystackId?: boolean
    dueDate?: boolean
    lineItems?: boolean
    landlordId?: boolean
    tenantId?: boolean
    recurringBillableId?: boolean
    lease?: boolean | Invoice$leaseArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    recurringBillable?: boolean | Invoice$recurringBillableArgs<ExtArgs>
    landlord?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    leaseId?: boolean
    description?: boolean
    dueAmount?: boolean
    category?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paystackId?: boolean
    dueDate?: boolean
    lineItems?: boolean
    landlordId?: boolean
    tenantId?: boolean
    recurringBillableId?: boolean
  }

  export type InvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "leaseId" | "description" | "dueAmount" | "category" | "status" | "createdAt" | "updatedAt" | "paystackId" | "dueDate" | "lineItems" | "landlordId" | "tenantId" | "recurringBillableId", ExtArgs["result"]["invoice"]>
  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    File?: boolean | Invoice$FileArgs<ExtArgs>
    lease?: boolean | Invoice$leaseArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    transactions?: boolean | Invoice$transactionsArgs<ExtArgs>
    recurringBillable?: boolean | Invoice$recurringBillableArgs<ExtArgs>
    landlord?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lease?: boolean | Invoice$leaseArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    recurringBillable?: boolean | Invoice$recurringBillableArgs<ExtArgs>
    landlord?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lease?: boolean | Invoice$leaseArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    recurringBillable?: boolean | Invoice$recurringBillableArgs<ExtArgs>
    landlord?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      File: Prisma.$FilePayload<ExtArgs>[]
      lease: Prisma.$LeasePayload<ExtArgs> | null
      tenant: Prisma.$TenantPayload<ExtArgs>
      transactions: Prisma.$TransactionsPayload<ExtArgs>[]
      recurringBillable: Prisma.$RecurringBillablePayload<ExtArgs> | null
      landlord: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      leaseId: string | null
      description: string
      dueAmount: number
      category: $Enums.InvoiceCategory
      status: $Enums.InvoiceStatus
      createdAt: Date
      updatedAt: Date
      paystackId: string
      dueDate: Date | null
      lineItems: Prisma.JsonValue | null
      landlordId: string
      tenantId: string
      recurringBillableId: string | null
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices and returns the data updated in the database.
     * @param {InvoiceUpdateManyAndReturnArgs} args - Arguments to update many Invoices.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    File<T extends Invoice$FileArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$FileArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lease<T extends Invoice$leaseArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$leaseArgs<ExtArgs>>): Prisma__LeaseClient<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transactions<T extends Invoice$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    recurringBillable<T extends Invoice$recurringBillableArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$recurringBillableArgs<ExtArgs>>): Prisma__RecurringBillableClient<$Result.GetResult<Prisma.$RecurringBillablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    landlord<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly leaseId: FieldRef<"Invoice", 'String'>
    readonly description: FieldRef<"Invoice", 'String'>
    readonly dueAmount: FieldRef<"Invoice", 'Float'>
    readonly category: FieldRef<"Invoice", 'InvoiceCategory'>
    readonly status: FieldRef<"Invoice", 'InvoiceStatus'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
    readonly updatedAt: FieldRef<"Invoice", 'DateTime'>
    readonly paystackId: FieldRef<"Invoice", 'String'>
    readonly dueDate: FieldRef<"Invoice", 'DateTime'>
    readonly lineItems: FieldRef<"Invoice", 'Json'>
    readonly landlordId: FieldRef<"Invoice", 'String'>
    readonly tenantId: FieldRef<"Invoice", 'String'>
    readonly recurringBillableId: FieldRef<"Invoice", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
  }

  /**
   * Invoice updateManyAndReturn
   */
  export type InvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to delete.
     */
    limit?: number
  }

  /**
   * Invoice.File
   */
  export type Invoice$FileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    cursor?: FileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * Invoice.lease
   */
  export type Invoice$leaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseInclude<ExtArgs> | null
    where?: LeaseWhereInput
  }

  /**
   * Invoice.transactions
   */
  export type Invoice$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    where?: TransactionsWhereInput
    orderBy?: TransactionsOrderByWithRelationInput | TransactionsOrderByWithRelationInput[]
    cursor?: TransactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * Invoice.recurringBillable
   */
  export type Invoice$recurringBillableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringBillable
     */
    select?: RecurringBillableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringBillable
     */
    omit?: RecurringBillableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringBillableInclude<ExtArgs> | null
    where?: RecurringBillableWhereInput
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model RecurringBillable
   */

  export type AggregateRecurringBillable = {
    _count: RecurringBillableCountAggregateOutputType | null
    _avg: RecurringBillableAvgAggregateOutputType | null
    _sum: RecurringBillableSumAggregateOutputType | null
    _min: RecurringBillableMinAggregateOutputType | null
    _max: RecurringBillableMaxAggregateOutputType | null
  }

  export type RecurringBillableAvgAggregateOutputType = {
    amount: number | null
  }

  export type RecurringBillableSumAggregateOutputType = {
    amount: number | null
  }

  export type RecurringBillableMinAggregateOutputType = {
    id: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    description: string | null
    amount: number | null
    category: $Enums.InvoiceCategory | null
    cycle: $Enums.InvoiceCycle | null
    nextInvoiceAt: Date | null
    isActive: boolean | null
    leaseId: string | null
    tenantId: string | null
    propertyId: string | null
  }

  export type RecurringBillableMaxAggregateOutputType = {
    id: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    description: string | null
    amount: number | null
    category: $Enums.InvoiceCategory | null
    cycle: $Enums.InvoiceCycle | null
    nextInvoiceAt: Date | null
    isActive: boolean | null
    leaseId: string | null
    tenantId: string | null
    propertyId: string | null
  }

  export type RecurringBillableCountAggregateOutputType = {
    id: number
    startDate: number
    endDate: number
    createdAt: number
    updatedAt: number
    description: number
    amount: number
    category: number
    cycle: number
    nextInvoiceAt: number
    isActive: number
    leaseId: number
    tenantId: number
    propertyId: number
    _all: number
  }


  export type RecurringBillableAvgAggregateInputType = {
    amount?: true
  }

  export type RecurringBillableSumAggregateInputType = {
    amount?: true
  }

  export type RecurringBillableMinAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    description?: true
    amount?: true
    category?: true
    cycle?: true
    nextInvoiceAt?: true
    isActive?: true
    leaseId?: true
    tenantId?: true
    propertyId?: true
  }

  export type RecurringBillableMaxAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    description?: true
    amount?: true
    category?: true
    cycle?: true
    nextInvoiceAt?: true
    isActive?: true
    leaseId?: true
    tenantId?: true
    propertyId?: true
  }

  export type RecurringBillableCountAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    description?: true
    amount?: true
    category?: true
    cycle?: true
    nextInvoiceAt?: true
    isActive?: true
    leaseId?: true
    tenantId?: true
    propertyId?: true
    _all?: true
  }

  export type RecurringBillableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecurringBillable to aggregate.
     */
    where?: RecurringBillableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringBillables to fetch.
     */
    orderBy?: RecurringBillableOrderByWithRelationInput | RecurringBillableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecurringBillableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringBillables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringBillables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecurringBillables
    **/
    _count?: true | RecurringBillableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecurringBillableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecurringBillableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecurringBillableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecurringBillableMaxAggregateInputType
  }

  export type GetRecurringBillableAggregateType<T extends RecurringBillableAggregateArgs> = {
        [P in keyof T & keyof AggregateRecurringBillable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecurringBillable[P]>
      : GetScalarType<T[P], AggregateRecurringBillable[P]>
  }




  export type RecurringBillableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecurringBillableWhereInput
    orderBy?: RecurringBillableOrderByWithAggregationInput | RecurringBillableOrderByWithAggregationInput[]
    by: RecurringBillableScalarFieldEnum[] | RecurringBillableScalarFieldEnum
    having?: RecurringBillableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecurringBillableCountAggregateInputType | true
    _avg?: RecurringBillableAvgAggregateInputType
    _sum?: RecurringBillableSumAggregateInputType
    _min?: RecurringBillableMinAggregateInputType
    _max?: RecurringBillableMaxAggregateInputType
  }

  export type RecurringBillableGroupByOutputType = {
    id: string
    startDate: Date
    endDate: Date | null
    createdAt: Date
    updatedAt: Date
    description: string
    amount: number
    category: $Enums.InvoiceCategory
    cycle: $Enums.InvoiceCycle
    nextInvoiceAt: Date
    isActive: boolean
    leaseId: string | null
    tenantId: string
    propertyId: string | null
    _count: RecurringBillableCountAggregateOutputType | null
    _avg: RecurringBillableAvgAggregateOutputType | null
    _sum: RecurringBillableSumAggregateOutputType | null
    _min: RecurringBillableMinAggregateOutputType | null
    _max: RecurringBillableMaxAggregateOutputType | null
  }

  type GetRecurringBillableGroupByPayload<T extends RecurringBillableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecurringBillableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecurringBillableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecurringBillableGroupByOutputType[P]>
            : GetScalarType<T[P], RecurringBillableGroupByOutputType[P]>
        }
      >
    >


  export type RecurringBillableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    description?: boolean
    amount?: boolean
    category?: boolean
    cycle?: boolean
    nextInvoiceAt?: boolean
    isActive?: boolean
    leaseId?: boolean
    tenantId?: boolean
    propertyId?: boolean
    lease?: boolean | RecurringBillable$leaseArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    invoice?: boolean | RecurringBillable$invoiceArgs<ExtArgs>
    property?: boolean | RecurringBillable$propertyArgs<ExtArgs>
    _count?: boolean | RecurringBillableCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recurringBillable"]>

  export type RecurringBillableSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    description?: boolean
    amount?: boolean
    category?: boolean
    cycle?: boolean
    nextInvoiceAt?: boolean
    isActive?: boolean
    leaseId?: boolean
    tenantId?: boolean
    propertyId?: boolean
    lease?: boolean | RecurringBillable$leaseArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    property?: boolean | RecurringBillable$propertyArgs<ExtArgs>
  }, ExtArgs["result"]["recurringBillable"]>

  export type RecurringBillableSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    description?: boolean
    amount?: boolean
    category?: boolean
    cycle?: boolean
    nextInvoiceAt?: boolean
    isActive?: boolean
    leaseId?: boolean
    tenantId?: boolean
    propertyId?: boolean
    lease?: boolean | RecurringBillable$leaseArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    property?: boolean | RecurringBillable$propertyArgs<ExtArgs>
  }, ExtArgs["result"]["recurringBillable"]>

  export type RecurringBillableSelectScalar = {
    id?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    description?: boolean
    amount?: boolean
    category?: boolean
    cycle?: boolean
    nextInvoiceAt?: boolean
    isActive?: boolean
    leaseId?: boolean
    tenantId?: boolean
    propertyId?: boolean
  }

  export type RecurringBillableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "startDate" | "endDate" | "createdAt" | "updatedAt" | "description" | "amount" | "category" | "cycle" | "nextInvoiceAt" | "isActive" | "leaseId" | "tenantId" | "propertyId", ExtArgs["result"]["recurringBillable"]>
  export type RecurringBillableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lease?: boolean | RecurringBillable$leaseArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    invoice?: boolean | RecurringBillable$invoiceArgs<ExtArgs>
    property?: boolean | RecurringBillable$propertyArgs<ExtArgs>
    _count?: boolean | RecurringBillableCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RecurringBillableIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lease?: boolean | RecurringBillable$leaseArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    property?: boolean | RecurringBillable$propertyArgs<ExtArgs>
  }
  export type RecurringBillableIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lease?: boolean | RecurringBillable$leaseArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    property?: boolean | RecurringBillable$propertyArgs<ExtArgs>
  }

  export type $RecurringBillablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecurringBillable"
    objects: {
      lease: Prisma.$LeasePayload<ExtArgs> | null
      tenant: Prisma.$TenantPayload<ExtArgs>
      invoice: Prisma.$InvoicePayload<ExtArgs>[]
      property: Prisma.$PropertyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      startDate: Date
      endDate: Date | null
      createdAt: Date
      updatedAt: Date
      description: string
      amount: number
      category: $Enums.InvoiceCategory
      cycle: $Enums.InvoiceCycle
      nextInvoiceAt: Date
      isActive: boolean
      leaseId: string | null
      tenantId: string
      propertyId: string | null
    }, ExtArgs["result"]["recurringBillable"]>
    composites: {}
  }

  type RecurringBillableGetPayload<S extends boolean | null | undefined | RecurringBillableDefaultArgs> = $Result.GetResult<Prisma.$RecurringBillablePayload, S>

  type RecurringBillableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RecurringBillableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RecurringBillableCountAggregateInputType | true
    }

  export interface RecurringBillableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecurringBillable'], meta: { name: 'RecurringBillable' } }
    /**
     * Find zero or one RecurringBillable that matches the filter.
     * @param {RecurringBillableFindUniqueArgs} args - Arguments to find a RecurringBillable
     * @example
     * // Get one RecurringBillable
     * const recurringBillable = await prisma.recurringBillable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecurringBillableFindUniqueArgs>(args: SelectSubset<T, RecurringBillableFindUniqueArgs<ExtArgs>>): Prisma__RecurringBillableClient<$Result.GetResult<Prisma.$RecurringBillablePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RecurringBillable that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RecurringBillableFindUniqueOrThrowArgs} args - Arguments to find a RecurringBillable
     * @example
     * // Get one RecurringBillable
     * const recurringBillable = await prisma.recurringBillable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecurringBillableFindUniqueOrThrowArgs>(args: SelectSubset<T, RecurringBillableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecurringBillableClient<$Result.GetResult<Prisma.$RecurringBillablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecurringBillable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringBillableFindFirstArgs} args - Arguments to find a RecurringBillable
     * @example
     * // Get one RecurringBillable
     * const recurringBillable = await prisma.recurringBillable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecurringBillableFindFirstArgs>(args?: SelectSubset<T, RecurringBillableFindFirstArgs<ExtArgs>>): Prisma__RecurringBillableClient<$Result.GetResult<Prisma.$RecurringBillablePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecurringBillable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringBillableFindFirstOrThrowArgs} args - Arguments to find a RecurringBillable
     * @example
     * // Get one RecurringBillable
     * const recurringBillable = await prisma.recurringBillable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecurringBillableFindFirstOrThrowArgs>(args?: SelectSubset<T, RecurringBillableFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecurringBillableClient<$Result.GetResult<Prisma.$RecurringBillablePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RecurringBillables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringBillableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecurringBillables
     * const recurringBillables = await prisma.recurringBillable.findMany()
     * 
     * // Get first 10 RecurringBillables
     * const recurringBillables = await prisma.recurringBillable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recurringBillableWithIdOnly = await prisma.recurringBillable.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecurringBillableFindManyArgs>(args?: SelectSubset<T, RecurringBillableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringBillablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RecurringBillable.
     * @param {RecurringBillableCreateArgs} args - Arguments to create a RecurringBillable.
     * @example
     * // Create one RecurringBillable
     * const RecurringBillable = await prisma.recurringBillable.create({
     *   data: {
     *     // ... data to create a RecurringBillable
     *   }
     * })
     * 
     */
    create<T extends RecurringBillableCreateArgs>(args: SelectSubset<T, RecurringBillableCreateArgs<ExtArgs>>): Prisma__RecurringBillableClient<$Result.GetResult<Prisma.$RecurringBillablePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RecurringBillables.
     * @param {RecurringBillableCreateManyArgs} args - Arguments to create many RecurringBillables.
     * @example
     * // Create many RecurringBillables
     * const recurringBillable = await prisma.recurringBillable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecurringBillableCreateManyArgs>(args?: SelectSubset<T, RecurringBillableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RecurringBillables and returns the data saved in the database.
     * @param {RecurringBillableCreateManyAndReturnArgs} args - Arguments to create many RecurringBillables.
     * @example
     * // Create many RecurringBillables
     * const recurringBillable = await prisma.recurringBillable.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RecurringBillables and only return the `id`
     * const recurringBillableWithIdOnly = await prisma.recurringBillable.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecurringBillableCreateManyAndReturnArgs>(args?: SelectSubset<T, RecurringBillableCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringBillablePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RecurringBillable.
     * @param {RecurringBillableDeleteArgs} args - Arguments to delete one RecurringBillable.
     * @example
     * // Delete one RecurringBillable
     * const RecurringBillable = await prisma.recurringBillable.delete({
     *   where: {
     *     // ... filter to delete one RecurringBillable
     *   }
     * })
     * 
     */
    delete<T extends RecurringBillableDeleteArgs>(args: SelectSubset<T, RecurringBillableDeleteArgs<ExtArgs>>): Prisma__RecurringBillableClient<$Result.GetResult<Prisma.$RecurringBillablePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RecurringBillable.
     * @param {RecurringBillableUpdateArgs} args - Arguments to update one RecurringBillable.
     * @example
     * // Update one RecurringBillable
     * const recurringBillable = await prisma.recurringBillable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecurringBillableUpdateArgs>(args: SelectSubset<T, RecurringBillableUpdateArgs<ExtArgs>>): Prisma__RecurringBillableClient<$Result.GetResult<Prisma.$RecurringBillablePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RecurringBillables.
     * @param {RecurringBillableDeleteManyArgs} args - Arguments to filter RecurringBillables to delete.
     * @example
     * // Delete a few RecurringBillables
     * const { count } = await prisma.recurringBillable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecurringBillableDeleteManyArgs>(args?: SelectSubset<T, RecurringBillableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecurringBillables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringBillableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecurringBillables
     * const recurringBillable = await prisma.recurringBillable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecurringBillableUpdateManyArgs>(args: SelectSubset<T, RecurringBillableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecurringBillables and returns the data updated in the database.
     * @param {RecurringBillableUpdateManyAndReturnArgs} args - Arguments to update many RecurringBillables.
     * @example
     * // Update many RecurringBillables
     * const recurringBillable = await prisma.recurringBillable.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RecurringBillables and only return the `id`
     * const recurringBillableWithIdOnly = await prisma.recurringBillable.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RecurringBillableUpdateManyAndReturnArgs>(args: SelectSubset<T, RecurringBillableUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringBillablePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RecurringBillable.
     * @param {RecurringBillableUpsertArgs} args - Arguments to update or create a RecurringBillable.
     * @example
     * // Update or create a RecurringBillable
     * const recurringBillable = await prisma.recurringBillable.upsert({
     *   create: {
     *     // ... data to create a RecurringBillable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecurringBillable we want to update
     *   }
     * })
     */
    upsert<T extends RecurringBillableUpsertArgs>(args: SelectSubset<T, RecurringBillableUpsertArgs<ExtArgs>>): Prisma__RecurringBillableClient<$Result.GetResult<Prisma.$RecurringBillablePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RecurringBillables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringBillableCountArgs} args - Arguments to filter RecurringBillables to count.
     * @example
     * // Count the number of RecurringBillables
     * const count = await prisma.recurringBillable.count({
     *   where: {
     *     // ... the filter for the RecurringBillables we want to count
     *   }
     * })
    **/
    count<T extends RecurringBillableCountArgs>(
      args?: Subset<T, RecurringBillableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecurringBillableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecurringBillable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringBillableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecurringBillableAggregateArgs>(args: Subset<T, RecurringBillableAggregateArgs>): Prisma.PrismaPromise<GetRecurringBillableAggregateType<T>>

    /**
     * Group by RecurringBillable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringBillableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecurringBillableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecurringBillableGroupByArgs['orderBy'] }
        : { orderBy?: RecurringBillableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecurringBillableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecurringBillableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecurringBillable model
   */
  readonly fields: RecurringBillableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecurringBillable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecurringBillableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lease<T extends RecurringBillable$leaseArgs<ExtArgs> = {}>(args?: Subset<T, RecurringBillable$leaseArgs<ExtArgs>>): Prisma__LeaseClient<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    invoice<T extends RecurringBillable$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, RecurringBillable$invoiceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    property<T extends RecurringBillable$propertyArgs<ExtArgs> = {}>(args?: Subset<T, RecurringBillable$propertyArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RecurringBillable model
   */
  interface RecurringBillableFieldRefs {
    readonly id: FieldRef<"RecurringBillable", 'String'>
    readonly startDate: FieldRef<"RecurringBillable", 'DateTime'>
    readonly endDate: FieldRef<"RecurringBillable", 'DateTime'>
    readonly createdAt: FieldRef<"RecurringBillable", 'DateTime'>
    readonly updatedAt: FieldRef<"RecurringBillable", 'DateTime'>
    readonly description: FieldRef<"RecurringBillable", 'String'>
    readonly amount: FieldRef<"RecurringBillable", 'Float'>
    readonly category: FieldRef<"RecurringBillable", 'InvoiceCategory'>
    readonly cycle: FieldRef<"RecurringBillable", 'InvoiceCycle'>
    readonly nextInvoiceAt: FieldRef<"RecurringBillable", 'DateTime'>
    readonly isActive: FieldRef<"RecurringBillable", 'Boolean'>
    readonly leaseId: FieldRef<"RecurringBillable", 'String'>
    readonly tenantId: FieldRef<"RecurringBillable", 'String'>
    readonly propertyId: FieldRef<"RecurringBillable", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RecurringBillable findUnique
   */
  export type RecurringBillableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringBillable
     */
    select?: RecurringBillableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringBillable
     */
    omit?: RecurringBillableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringBillableInclude<ExtArgs> | null
    /**
     * Filter, which RecurringBillable to fetch.
     */
    where: RecurringBillableWhereUniqueInput
  }

  /**
   * RecurringBillable findUniqueOrThrow
   */
  export type RecurringBillableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringBillable
     */
    select?: RecurringBillableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringBillable
     */
    omit?: RecurringBillableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringBillableInclude<ExtArgs> | null
    /**
     * Filter, which RecurringBillable to fetch.
     */
    where: RecurringBillableWhereUniqueInput
  }

  /**
   * RecurringBillable findFirst
   */
  export type RecurringBillableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringBillable
     */
    select?: RecurringBillableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringBillable
     */
    omit?: RecurringBillableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringBillableInclude<ExtArgs> | null
    /**
     * Filter, which RecurringBillable to fetch.
     */
    where?: RecurringBillableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringBillables to fetch.
     */
    orderBy?: RecurringBillableOrderByWithRelationInput | RecurringBillableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecurringBillables.
     */
    cursor?: RecurringBillableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringBillables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringBillables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecurringBillables.
     */
    distinct?: RecurringBillableScalarFieldEnum | RecurringBillableScalarFieldEnum[]
  }

  /**
   * RecurringBillable findFirstOrThrow
   */
  export type RecurringBillableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringBillable
     */
    select?: RecurringBillableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringBillable
     */
    omit?: RecurringBillableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringBillableInclude<ExtArgs> | null
    /**
     * Filter, which RecurringBillable to fetch.
     */
    where?: RecurringBillableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringBillables to fetch.
     */
    orderBy?: RecurringBillableOrderByWithRelationInput | RecurringBillableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecurringBillables.
     */
    cursor?: RecurringBillableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringBillables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringBillables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecurringBillables.
     */
    distinct?: RecurringBillableScalarFieldEnum | RecurringBillableScalarFieldEnum[]
  }

  /**
   * RecurringBillable findMany
   */
  export type RecurringBillableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringBillable
     */
    select?: RecurringBillableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringBillable
     */
    omit?: RecurringBillableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringBillableInclude<ExtArgs> | null
    /**
     * Filter, which RecurringBillables to fetch.
     */
    where?: RecurringBillableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringBillables to fetch.
     */
    orderBy?: RecurringBillableOrderByWithRelationInput | RecurringBillableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecurringBillables.
     */
    cursor?: RecurringBillableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringBillables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringBillables.
     */
    skip?: number
    distinct?: RecurringBillableScalarFieldEnum | RecurringBillableScalarFieldEnum[]
  }

  /**
   * RecurringBillable create
   */
  export type RecurringBillableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringBillable
     */
    select?: RecurringBillableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringBillable
     */
    omit?: RecurringBillableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringBillableInclude<ExtArgs> | null
    /**
     * The data needed to create a RecurringBillable.
     */
    data: XOR<RecurringBillableCreateInput, RecurringBillableUncheckedCreateInput>
  }

  /**
   * RecurringBillable createMany
   */
  export type RecurringBillableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RecurringBillables.
     */
    data: RecurringBillableCreateManyInput | RecurringBillableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RecurringBillable createManyAndReturn
   */
  export type RecurringBillableCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringBillable
     */
    select?: RecurringBillableSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringBillable
     */
    omit?: RecurringBillableOmit<ExtArgs> | null
    /**
     * The data used to create many RecurringBillables.
     */
    data: RecurringBillableCreateManyInput | RecurringBillableCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringBillableIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecurringBillable update
   */
  export type RecurringBillableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringBillable
     */
    select?: RecurringBillableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringBillable
     */
    omit?: RecurringBillableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringBillableInclude<ExtArgs> | null
    /**
     * The data needed to update a RecurringBillable.
     */
    data: XOR<RecurringBillableUpdateInput, RecurringBillableUncheckedUpdateInput>
    /**
     * Choose, which RecurringBillable to update.
     */
    where: RecurringBillableWhereUniqueInput
  }

  /**
   * RecurringBillable updateMany
   */
  export type RecurringBillableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecurringBillables.
     */
    data: XOR<RecurringBillableUpdateManyMutationInput, RecurringBillableUncheckedUpdateManyInput>
    /**
     * Filter which RecurringBillables to update
     */
    where?: RecurringBillableWhereInput
    /**
     * Limit how many RecurringBillables to update.
     */
    limit?: number
  }

  /**
   * RecurringBillable updateManyAndReturn
   */
  export type RecurringBillableUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringBillable
     */
    select?: RecurringBillableSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringBillable
     */
    omit?: RecurringBillableOmit<ExtArgs> | null
    /**
     * The data used to update RecurringBillables.
     */
    data: XOR<RecurringBillableUpdateManyMutationInput, RecurringBillableUncheckedUpdateManyInput>
    /**
     * Filter which RecurringBillables to update
     */
    where?: RecurringBillableWhereInput
    /**
     * Limit how many RecurringBillables to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringBillableIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecurringBillable upsert
   */
  export type RecurringBillableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringBillable
     */
    select?: RecurringBillableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringBillable
     */
    omit?: RecurringBillableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringBillableInclude<ExtArgs> | null
    /**
     * The filter to search for the RecurringBillable to update in case it exists.
     */
    where: RecurringBillableWhereUniqueInput
    /**
     * In case the RecurringBillable found by the `where` argument doesn't exist, create a new RecurringBillable with this data.
     */
    create: XOR<RecurringBillableCreateInput, RecurringBillableUncheckedCreateInput>
    /**
     * In case the RecurringBillable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecurringBillableUpdateInput, RecurringBillableUncheckedUpdateInput>
  }

  /**
   * RecurringBillable delete
   */
  export type RecurringBillableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringBillable
     */
    select?: RecurringBillableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringBillable
     */
    omit?: RecurringBillableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringBillableInclude<ExtArgs> | null
    /**
     * Filter which RecurringBillable to delete.
     */
    where: RecurringBillableWhereUniqueInput
  }

  /**
   * RecurringBillable deleteMany
   */
  export type RecurringBillableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecurringBillables to delete
     */
    where?: RecurringBillableWhereInput
    /**
     * Limit how many RecurringBillables to delete.
     */
    limit?: number
  }

  /**
   * RecurringBillable.lease
   */
  export type RecurringBillable$leaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseInclude<ExtArgs> | null
    where?: LeaseWhereInput
  }

  /**
   * RecurringBillable.invoice
   */
  export type RecurringBillable$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * RecurringBillable.property
   */
  export type RecurringBillable$propertyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    where?: PropertyWhereInput
  }

  /**
   * RecurringBillable without action
   */
  export type RecurringBillableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringBillable
     */
    select?: RecurringBillableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringBillable
     */
    omit?: RecurringBillableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringBillableInclude<ExtArgs> | null
  }


  /**
   * Model Transactions
   */

  export type AggregateTransactions = {
    _count: TransactionsCountAggregateOutputType | null
    _avg: TransactionsAvgAggregateOutputType | null
    _sum: TransactionsSumAggregateOutputType | null
    _min: TransactionsMinAggregateOutputType | null
    _max: TransactionsMaxAggregateOutputType | null
  }

  export type TransactionsAvgAggregateOutputType = {
    amountPaid: number | null
  }

  export type TransactionsSumAggregateOutputType = {
    amountPaid: number | null
  }

  export type TransactionsMinAggregateOutputType = {
    id: string | null
    leaseId: string | null
    description: string | null
    amountPaid: number | null
    referenceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    invoiceId: string | null
  }

  export type TransactionsMaxAggregateOutputType = {
    id: string | null
    leaseId: string | null
    description: string | null
    amountPaid: number | null
    referenceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    invoiceId: string | null
  }

  export type TransactionsCountAggregateOutputType = {
    id: number
    leaseId: number
    description: number
    amountPaid: number
    referenceId: number
    createdAt: number
    updatedAt: number
    invoiceId: number
    _all: number
  }


  export type TransactionsAvgAggregateInputType = {
    amountPaid?: true
  }

  export type TransactionsSumAggregateInputType = {
    amountPaid?: true
  }

  export type TransactionsMinAggregateInputType = {
    id?: true
    leaseId?: true
    description?: true
    amountPaid?: true
    referenceId?: true
    createdAt?: true
    updatedAt?: true
    invoiceId?: true
  }

  export type TransactionsMaxAggregateInputType = {
    id?: true
    leaseId?: true
    description?: true
    amountPaid?: true
    referenceId?: true
    createdAt?: true
    updatedAt?: true
    invoiceId?: true
  }

  export type TransactionsCountAggregateInputType = {
    id?: true
    leaseId?: true
    description?: true
    amountPaid?: true
    referenceId?: true
    createdAt?: true
    updatedAt?: true
    invoiceId?: true
    _all?: true
  }

  export type TransactionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to aggregate.
     */
    where?: TransactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionsOrderByWithRelationInput | TransactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionsMaxAggregateInputType
  }

  export type GetTransactionsAggregateType<T extends TransactionsAggregateArgs> = {
        [P in keyof T & keyof AggregateTransactions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransactions[P]>
      : GetScalarType<T[P], AggregateTransactions[P]>
  }




  export type TransactionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionsWhereInput
    orderBy?: TransactionsOrderByWithAggregationInput | TransactionsOrderByWithAggregationInput[]
    by: TransactionsScalarFieldEnum[] | TransactionsScalarFieldEnum
    having?: TransactionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionsCountAggregateInputType | true
    _avg?: TransactionsAvgAggregateInputType
    _sum?: TransactionsSumAggregateInputType
    _min?: TransactionsMinAggregateInputType
    _max?: TransactionsMaxAggregateInputType
  }

  export type TransactionsGroupByOutputType = {
    id: string
    leaseId: string | null
    description: string
    amountPaid: number
    referenceId: string | null
    createdAt: Date
    updatedAt: Date
    invoiceId: string | null
    _count: TransactionsCountAggregateOutputType | null
    _avg: TransactionsAvgAggregateOutputType | null
    _sum: TransactionsSumAggregateOutputType | null
    _min: TransactionsMinAggregateOutputType | null
    _max: TransactionsMaxAggregateOutputType | null
  }

  type GetTransactionsGroupByPayload<T extends TransactionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionsGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionsGroupByOutputType[P]>
        }
      >
    >


  export type TransactionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leaseId?: boolean
    description?: boolean
    amountPaid?: boolean
    referenceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoiceId?: boolean
    invoice?: boolean | Transactions$invoiceArgs<ExtArgs>
    lease?: boolean | Transactions$leaseArgs<ExtArgs>
  }, ExtArgs["result"]["transactions"]>

  export type TransactionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leaseId?: boolean
    description?: boolean
    amountPaid?: boolean
    referenceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoiceId?: boolean
    invoice?: boolean | Transactions$invoiceArgs<ExtArgs>
    lease?: boolean | Transactions$leaseArgs<ExtArgs>
  }, ExtArgs["result"]["transactions"]>

  export type TransactionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leaseId?: boolean
    description?: boolean
    amountPaid?: boolean
    referenceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoiceId?: boolean
    invoice?: boolean | Transactions$invoiceArgs<ExtArgs>
    lease?: boolean | Transactions$leaseArgs<ExtArgs>
  }, ExtArgs["result"]["transactions"]>

  export type TransactionsSelectScalar = {
    id?: boolean
    leaseId?: boolean
    description?: boolean
    amountPaid?: boolean
    referenceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoiceId?: boolean
  }

  export type TransactionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "leaseId" | "description" | "amountPaid" | "referenceId" | "createdAt" | "updatedAt" | "invoiceId", ExtArgs["result"]["transactions"]>
  export type TransactionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | Transactions$invoiceArgs<ExtArgs>
    lease?: boolean | Transactions$leaseArgs<ExtArgs>
  }
  export type TransactionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | Transactions$invoiceArgs<ExtArgs>
    lease?: boolean | Transactions$leaseArgs<ExtArgs>
  }
  export type TransactionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | Transactions$invoiceArgs<ExtArgs>
    lease?: boolean | Transactions$leaseArgs<ExtArgs>
  }

  export type $TransactionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transactions"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs> | null
      lease: Prisma.$LeasePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      leaseId: string | null
      description: string
      amountPaid: number
      referenceId: string | null
      createdAt: Date
      updatedAt: Date
      invoiceId: string | null
    }, ExtArgs["result"]["transactions"]>
    composites: {}
  }

  type TransactionsGetPayload<S extends boolean | null | undefined | TransactionsDefaultArgs> = $Result.GetResult<Prisma.$TransactionsPayload, S>

  type TransactionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionsCountAggregateInputType | true
    }

  export interface TransactionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transactions'], meta: { name: 'Transactions' } }
    /**
     * Find zero or one Transactions that matches the filter.
     * @param {TransactionsFindUniqueArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionsFindUniqueArgs>(args: SelectSubset<T, TransactionsFindUniqueArgs<ExtArgs>>): Prisma__TransactionsClient<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transactions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionsFindUniqueOrThrowArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionsFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionsClient<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsFindFirstArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionsFindFirstArgs>(args?: SelectSubset<T, TransactionsFindFirstArgs<ExtArgs>>): Prisma__TransactionsClient<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transactions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsFindFirstOrThrowArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionsFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionsClient<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transactions.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transactions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionsWithIdOnly = await prisma.transactions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionsFindManyArgs>(args?: SelectSubset<T, TransactionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transactions.
     * @param {TransactionsCreateArgs} args - Arguments to create a Transactions.
     * @example
     * // Create one Transactions
     * const Transactions = await prisma.transactions.create({
     *   data: {
     *     // ... data to create a Transactions
     *   }
     * })
     * 
     */
    create<T extends TransactionsCreateArgs>(args: SelectSubset<T, TransactionsCreateArgs<ExtArgs>>): Prisma__TransactionsClient<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {TransactionsCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transactions = await prisma.transactions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionsCreateManyArgs>(args?: SelectSubset<T, TransactionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionsCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transactions = await prisma.transactions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionsWithIdOnly = await prisma.transactions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionsCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transactions.
     * @param {TransactionsDeleteArgs} args - Arguments to delete one Transactions.
     * @example
     * // Delete one Transactions
     * const Transactions = await prisma.transactions.delete({
     *   where: {
     *     // ... filter to delete one Transactions
     *   }
     * })
     * 
     */
    delete<T extends TransactionsDeleteArgs>(args: SelectSubset<T, TransactionsDeleteArgs<ExtArgs>>): Prisma__TransactionsClient<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transactions.
     * @param {TransactionsUpdateArgs} args - Arguments to update one Transactions.
     * @example
     * // Update one Transactions
     * const transactions = await prisma.transactions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionsUpdateArgs>(args: SelectSubset<T, TransactionsUpdateArgs<ExtArgs>>): Prisma__TransactionsClient<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionsDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transactions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionsDeleteManyArgs>(args?: SelectSubset<T, TransactionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transactions = await prisma.transactions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionsUpdateManyArgs>(args: SelectSubset<T, TransactionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions and returns the data updated in the database.
     * @param {TransactionsUpdateManyAndReturnArgs} args - Arguments to update many Transactions.
     * @example
     * // Update many Transactions
     * const transactions = await prisma.transactions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transactions and only return the `id`
     * const transactionsWithIdOnly = await prisma.transactions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionsUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transactions.
     * @param {TransactionsUpsertArgs} args - Arguments to update or create a Transactions.
     * @example
     * // Update or create a Transactions
     * const transactions = await prisma.transactions.upsert({
     *   create: {
     *     // ... data to create a Transactions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transactions we want to update
     *   }
     * })
     */
    upsert<T extends TransactionsUpsertArgs>(args: SelectSubset<T, TransactionsUpsertArgs<ExtArgs>>): Prisma__TransactionsClient<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transactions.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionsCountArgs>(
      args?: Subset<T, TransactionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionsAggregateArgs>(args: Subset<T, TransactionsAggregateArgs>): Prisma.PrismaPromise<GetTransactionsAggregateType<T>>

    /**
     * Group by Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionsGroupByArgs['orderBy'] }
        : { orderBy?: TransactionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transactions model
   */
  readonly fields: TransactionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transactions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends Transactions$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, Transactions$invoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    lease<T extends Transactions$leaseArgs<ExtArgs> = {}>(args?: Subset<T, Transactions$leaseArgs<ExtArgs>>): Prisma__LeaseClient<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transactions model
   */
  interface TransactionsFieldRefs {
    readonly id: FieldRef<"Transactions", 'String'>
    readonly leaseId: FieldRef<"Transactions", 'String'>
    readonly description: FieldRef<"Transactions", 'String'>
    readonly amountPaid: FieldRef<"Transactions", 'Float'>
    readonly referenceId: FieldRef<"Transactions", 'String'>
    readonly createdAt: FieldRef<"Transactions", 'DateTime'>
    readonly updatedAt: FieldRef<"Transactions", 'DateTime'>
    readonly invoiceId: FieldRef<"Transactions", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Transactions findUnique
   */
  export type TransactionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where: TransactionsWhereUniqueInput
  }

  /**
   * Transactions findUniqueOrThrow
   */
  export type TransactionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where: TransactionsWhereUniqueInput
  }

  /**
   * Transactions findFirst
   */
  export type TransactionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionsOrderByWithRelationInput | TransactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * Transactions findFirstOrThrow
   */
  export type TransactionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionsOrderByWithRelationInput | TransactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * Transactions findMany
   */
  export type TransactionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionsOrderByWithRelationInput | TransactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * Transactions create
   */
  export type TransactionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    /**
     * The data needed to create a Transactions.
     */
    data: XOR<TransactionsCreateInput, TransactionsUncheckedCreateInput>
  }

  /**
   * Transactions createMany
   */
  export type TransactionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionsCreateManyInput | TransactionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transactions createManyAndReturn
   */
  export type TransactionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionsCreateManyInput | TransactionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transactions update
   */
  export type TransactionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    /**
     * The data needed to update a Transactions.
     */
    data: XOR<TransactionsUpdateInput, TransactionsUncheckedUpdateInput>
    /**
     * Choose, which Transactions to update.
     */
    where: TransactionsWhereUniqueInput
  }

  /**
   * Transactions updateMany
   */
  export type TransactionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionsUpdateManyMutationInput, TransactionsUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionsWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
  }

  /**
   * Transactions updateManyAndReturn
   */
  export type TransactionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionsUpdateManyMutationInput, TransactionsUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionsWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transactions upsert
   */
  export type TransactionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    /**
     * The filter to search for the Transactions to update in case it exists.
     */
    where: TransactionsWhereUniqueInput
    /**
     * In case the Transactions found by the `where` argument doesn't exist, create a new Transactions with this data.
     */
    create: XOR<TransactionsCreateInput, TransactionsUncheckedCreateInput>
    /**
     * In case the Transactions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionsUpdateInput, TransactionsUncheckedUpdateInput>
  }

  /**
   * Transactions delete
   */
  export type TransactionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    /**
     * Filter which Transactions to delete.
     */
    where: TransactionsWhereUniqueInput
  }

  /**
   * Transactions deleteMany
   */
  export type TransactionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionsWhereInput
    /**
     * Limit how many Transactions to delete.
     */
    limit?: number
  }

  /**
   * Transactions.invoice
   */
  export type Transactions$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
  }

  /**
   * Transactions.lease
   */
  export type Transactions$leaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseInclude<ExtArgs> | null
    where?: LeaseWhereInput
  }

  /**
   * Transactions without action
   */
  export type TransactionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
  }


  /**
   * Model TenantLease
   */

  export type AggregateTenantLease = {
    _count: TenantLeaseCountAggregateOutputType | null
    _min: TenantLeaseMinAggregateOutputType | null
    _max: TenantLeaseMaxAggregateOutputType | null
  }

  export type TenantLeaseMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    leaseId: string | null
  }

  export type TenantLeaseMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    leaseId: string | null
  }

  export type TenantLeaseCountAggregateOutputType = {
    id: number
    tenantId: number
    leaseId: number
    _all: number
  }


  export type TenantLeaseMinAggregateInputType = {
    id?: true
    tenantId?: true
    leaseId?: true
  }

  export type TenantLeaseMaxAggregateInputType = {
    id?: true
    tenantId?: true
    leaseId?: true
  }

  export type TenantLeaseCountAggregateInputType = {
    id?: true
    tenantId?: true
    leaseId?: true
    _all?: true
  }

  export type TenantLeaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantLease to aggregate.
     */
    where?: TenantLeaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantLeases to fetch.
     */
    orderBy?: TenantLeaseOrderByWithRelationInput | TenantLeaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantLeaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantLeases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantLeases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TenantLeases
    **/
    _count?: true | TenantLeaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantLeaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantLeaseMaxAggregateInputType
  }

  export type GetTenantLeaseAggregateType<T extends TenantLeaseAggregateArgs> = {
        [P in keyof T & keyof AggregateTenantLease]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenantLease[P]>
      : GetScalarType<T[P], AggregateTenantLease[P]>
  }




  export type TenantLeaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantLeaseWhereInput
    orderBy?: TenantLeaseOrderByWithAggregationInput | TenantLeaseOrderByWithAggregationInput[]
    by: TenantLeaseScalarFieldEnum[] | TenantLeaseScalarFieldEnum
    having?: TenantLeaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantLeaseCountAggregateInputType | true
    _min?: TenantLeaseMinAggregateInputType
    _max?: TenantLeaseMaxAggregateInputType
  }

  export type TenantLeaseGroupByOutputType = {
    id: string
    tenantId: string
    leaseId: string
    _count: TenantLeaseCountAggregateOutputType | null
    _min: TenantLeaseMinAggregateOutputType | null
    _max: TenantLeaseMaxAggregateOutputType | null
  }

  type GetTenantLeaseGroupByPayload<T extends TenantLeaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantLeaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantLeaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantLeaseGroupByOutputType[P]>
            : GetScalarType<T[P], TenantLeaseGroupByOutputType[P]>
        }
      >
    >


  export type TenantLeaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    leaseId?: boolean
    lease?: boolean | LeaseDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantLease"]>

  export type TenantLeaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    leaseId?: boolean
    lease?: boolean | LeaseDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantLease"]>

  export type TenantLeaseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    leaseId?: boolean
    lease?: boolean | LeaseDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantLease"]>

  export type TenantLeaseSelectScalar = {
    id?: boolean
    tenantId?: boolean
    leaseId?: boolean
  }

  export type TenantLeaseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "leaseId", ExtArgs["result"]["tenantLease"]>
  export type TenantLeaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lease?: boolean | LeaseDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type TenantLeaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lease?: boolean | LeaseDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type TenantLeaseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lease?: boolean | LeaseDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $TenantLeasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TenantLease"
    objects: {
      lease: Prisma.$LeasePayload<ExtArgs>
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      leaseId: string
    }, ExtArgs["result"]["tenantLease"]>
    composites: {}
  }

  type TenantLeaseGetPayload<S extends boolean | null | undefined | TenantLeaseDefaultArgs> = $Result.GetResult<Prisma.$TenantLeasePayload, S>

  type TenantLeaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TenantLeaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantLeaseCountAggregateInputType | true
    }

  export interface TenantLeaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TenantLease'], meta: { name: 'TenantLease' } }
    /**
     * Find zero or one TenantLease that matches the filter.
     * @param {TenantLeaseFindUniqueArgs} args - Arguments to find a TenantLease
     * @example
     * // Get one TenantLease
     * const tenantLease = await prisma.tenantLease.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantLeaseFindUniqueArgs>(args: SelectSubset<T, TenantLeaseFindUniqueArgs<ExtArgs>>): Prisma__TenantLeaseClient<$Result.GetResult<Prisma.$TenantLeasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TenantLease that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TenantLeaseFindUniqueOrThrowArgs} args - Arguments to find a TenantLease
     * @example
     * // Get one TenantLease
     * const tenantLease = await prisma.tenantLease.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantLeaseFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantLeaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantLeaseClient<$Result.GetResult<Prisma.$TenantLeasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantLease that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantLeaseFindFirstArgs} args - Arguments to find a TenantLease
     * @example
     * // Get one TenantLease
     * const tenantLease = await prisma.tenantLease.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantLeaseFindFirstArgs>(args?: SelectSubset<T, TenantLeaseFindFirstArgs<ExtArgs>>): Prisma__TenantLeaseClient<$Result.GetResult<Prisma.$TenantLeasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantLease that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantLeaseFindFirstOrThrowArgs} args - Arguments to find a TenantLease
     * @example
     * // Get one TenantLease
     * const tenantLease = await prisma.tenantLease.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantLeaseFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantLeaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantLeaseClient<$Result.GetResult<Prisma.$TenantLeasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TenantLeases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantLeaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TenantLeases
     * const tenantLeases = await prisma.tenantLease.findMany()
     * 
     * // Get first 10 TenantLeases
     * const tenantLeases = await prisma.tenantLease.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantLeaseWithIdOnly = await prisma.tenantLease.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantLeaseFindManyArgs>(args?: SelectSubset<T, TenantLeaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantLeasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TenantLease.
     * @param {TenantLeaseCreateArgs} args - Arguments to create a TenantLease.
     * @example
     * // Create one TenantLease
     * const TenantLease = await prisma.tenantLease.create({
     *   data: {
     *     // ... data to create a TenantLease
     *   }
     * })
     * 
     */
    create<T extends TenantLeaseCreateArgs>(args: SelectSubset<T, TenantLeaseCreateArgs<ExtArgs>>): Prisma__TenantLeaseClient<$Result.GetResult<Prisma.$TenantLeasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TenantLeases.
     * @param {TenantLeaseCreateManyArgs} args - Arguments to create many TenantLeases.
     * @example
     * // Create many TenantLeases
     * const tenantLease = await prisma.tenantLease.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantLeaseCreateManyArgs>(args?: SelectSubset<T, TenantLeaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TenantLeases and returns the data saved in the database.
     * @param {TenantLeaseCreateManyAndReturnArgs} args - Arguments to create many TenantLeases.
     * @example
     * // Create many TenantLeases
     * const tenantLease = await prisma.tenantLease.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TenantLeases and only return the `id`
     * const tenantLeaseWithIdOnly = await prisma.tenantLease.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantLeaseCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantLeaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantLeasePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TenantLease.
     * @param {TenantLeaseDeleteArgs} args - Arguments to delete one TenantLease.
     * @example
     * // Delete one TenantLease
     * const TenantLease = await prisma.tenantLease.delete({
     *   where: {
     *     // ... filter to delete one TenantLease
     *   }
     * })
     * 
     */
    delete<T extends TenantLeaseDeleteArgs>(args: SelectSubset<T, TenantLeaseDeleteArgs<ExtArgs>>): Prisma__TenantLeaseClient<$Result.GetResult<Prisma.$TenantLeasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TenantLease.
     * @param {TenantLeaseUpdateArgs} args - Arguments to update one TenantLease.
     * @example
     * // Update one TenantLease
     * const tenantLease = await prisma.tenantLease.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantLeaseUpdateArgs>(args: SelectSubset<T, TenantLeaseUpdateArgs<ExtArgs>>): Prisma__TenantLeaseClient<$Result.GetResult<Prisma.$TenantLeasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TenantLeases.
     * @param {TenantLeaseDeleteManyArgs} args - Arguments to filter TenantLeases to delete.
     * @example
     * // Delete a few TenantLeases
     * const { count } = await prisma.tenantLease.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantLeaseDeleteManyArgs>(args?: SelectSubset<T, TenantLeaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantLeases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantLeaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TenantLeases
     * const tenantLease = await prisma.tenantLease.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantLeaseUpdateManyArgs>(args: SelectSubset<T, TenantLeaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantLeases and returns the data updated in the database.
     * @param {TenantLeaseUpdateManyAndReturnArgs} args - Arguments to update many TenantLeases.
     * @example
     * // Update many TenantLeases
     * const tenantLease = await prisma.tenantLease.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TenantLeases and only return the `id`
     * const tenantLeaseWithIdOnly = await prisma.tenantLease.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TenantLeaseUpdateManyAndReturnArgs>(args: SelectSubset<T, TenantLeaseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantLeasePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TenantLease.
     * @param {TenantLeaseUpsertArgs} args - Arguments to update or create a TenantLease.
     * @example
     * // Update or create a TenantLease
     * const tenantLease = await prisma.tenantLease.upsert({
     *   create: {
     *     // ... data to create a TenantLease
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TenantLease we want to update
     *   }
     * })
     */
    upsert<T extends TenantLeaseUpsertArgs>(args: SelectSubset<T, TenantLeaseUpsertArgs<ExtArgs>>): Prisma__TenantLeaseClient<$Result.GetResult<Prisma.$TenantLeasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TenantLeases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantLeaseCountArgs} args - Arguments to filter TenantLeases to count.
     * @example
     * // Count the number of TenantLeases
     * const count = await prisma.tenantLease.count({
     *   where: {
     *     // ... the filter for the TenantLeases we want to count
     *   }
     * })
    **/
    count<T extends TenantLeaseCountArgs>(
      args?: Subset<T, TenantLeaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantLeaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TenantLease.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantLeaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantLeaseAggregateArgs>(args: Subset<T, TenantLeaseAggregateArgs>): Prisma.PrismaPromise<GetTenantLeaseAggregateType<T>>

    /**
     * Group by TenantLease.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantLeaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantLeaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantLeaseGroupByArgs['orderBy'] }
        : { orderBy?: TenantLeaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantLeaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantLeaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TenantLease model
   */
  readonly fields: TenantLeaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TenantLease.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantLeaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lease<T extends LeaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LeaseDefaultArgs<ExtArgs>>): Prisma__LeaseClient<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TenantLease model
   */
  interface TenantLeaseFieldRefs {
    readonly id: FieldRef<"TenantLease", 'String'>
    readonly tenantId: FieldRef<"TenantLease", 'String'>
    readonly leaseId: FieldRef<"TenantLease", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TenantLease findUnique
   */
  export type TenantLeaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantLease
     */
    select?: TenantLeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantLease
     */
    omit?: TenantLeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantLeaseInclude<ExtArgs> | null
    /**
     * Filter, which TenantLease to fetch.
     */
    where: TenantLeaseWhereUniqueInput
  }

  /**
   * TenantLease findUniqueOrThrow
   */
  export type TenantLeaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantLease
     */
    select?: TenantLeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantLease
     */
    omit?: TenantLeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantLeaseInclude<ExtArgs> | null
    /**
     * Filter, which TenantLease to fetch.
     */
    where: TenantLeaseWhereUniqueInput
  }

  /**
   * TenantLease findFirst
   */
  export type TenantLeaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantLease
     */
    select?: TenantLeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantLease
     */
    omit?: TenantLeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantLeaseInclude<ExtArgs> | null
    /**
     * Filter, which TenantLease to fetch.
     */
    where?: TenantLeaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantLeases to fetch.
     */
    orderBy?: TenantLeaseOrderByWithRelationInput | TenantLeaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantLeases.
     */
    cursor?: TenantLeaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantLeases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantLeases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantLeases.
     */
    distinct?: TenantLeaseScalarFieldEnum | TenantLeaseScalarFieldEnum[]
  }

  /**
   * TenantLease findFirstOrThrow
   */
  export type TenantLeaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantLease
     */
    select?: TenantLeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantLease
     */
    omit?: TenantLeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantLeaseInclude<ExtArgs> | null
    /**
     * Filter, which TenantLease to fetch.
     */
    where?: TenantLeaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantLeases to fetch.
     */
    orderBy?: TenantLeaseOrderByWithRelationInput | TenantLeaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantLeases.
     */
    cursor?: TenantLeaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantLeases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantLeases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantLeases.
     */
    distinct?: TenantLeaseScalarFieldEnum | TenantLeaseScalarFieldEnum[]
  }

  /**
   * TenantLease findMany
   */
  export type TenantLeaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantLease
     */
    select?: TenantLeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantLease
     */
    omit?: TenantLeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantLeaseInclude<ExtArgs> | null
    /**
     * Filter, which TenantLeases to fetch.
     */
    where?: TenantLeaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantLeases to fetch.
     */
    orderBy?: TenantLeaseOrderByWithRelationInput | TenantLeaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TenantLeases.
     */
    cursor?: TenantLeaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantLeases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantLeases.
     */
    skip?: number
    distinct?: TenantLeaseScalarFieldEnum | TenantLeaseScalarFieldEnum[]
  }

  /**
   * TenantLease create
   */
  export type TenantLeaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantLease
     */
    select?: TenantLeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantLease
     */
    omit?: TenantLeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantLeaseInclude<ExtArgs> | null
    /**
     * The data needed to create a TenantLease.
     */
    data: XOR<TenantLeaseCreateInput, TenantLeaseUncheckedCreateInput>
  }

  /**
   * TenantLease createMany
   */
  export type TenantLeaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TenantLeases.
     */
    data: TenantLeaseCreateManyInput | TenantLeaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TenantLease createManyAndReturn
   */
  export type TenantLeaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantLease
     */
    select?: TenantLeaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TenantLease
     */
    omit?: TenantLeaseOmit<ExtArgs> | null
    /**
     * The data used to create many TenantLeases.
     */
    data: TenantLeaseCreateManyInput | TenantLeaseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantLeaseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenantLease update
   */
  export type TenantLeaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantLease
     */
    select?: TenantLeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantLease
     */
    omit?: TenantLeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantLeaseInclude<ExtArgs> | null
    /**
     * The data needed to update a TenantLease.
     */
    data: XOR<TenantLeaseUpdateInput, TenantLeaseUncheckedUpdateInput>
    /**
     * Choose, which TenantLease to update.
     */
    where: TenantLeaseWhereUniqueInput
  }

  /**
   * TenantLease updateMany
   */
  export type TenantLeaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TenantLeases.
     */
    data: XOR<TenantLeaseUpdateManyMutationInput, TenantLeaseUncheckedUpdateManyInput>
    /**
     * Filter which TenantLeases to update
     */
    where?: TenantLeaseWhereInput
    /**
     * Limit how many TenantLeases to update.
     */
    limit?: number
  }

  /**
   * TenantLease updateManyAndReturn
   */
  export type TenantLeaseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantLease
     */
    select?: TenantLeaseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TenantLease
     */
    omit?: TenantLeaseOmit<ExtArgs> | null
    /**
     * The data used to update TenantLeases.
     */
    data: XOR<TenantLeaseUpdateManyMutationInput, TenantLeaseUncheckedUpdateManyInput>
    /**
     * Filter which TenantLeases to update
     */
    where?: TenantLeaseWhereInput
    /**
     * Limit how many TenantLeases to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantLeaseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenantLease upsert
   */
  export type TenantLeaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantLease
     */
    select?: TenantLeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantLease
     */
    omit?: TenantLeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantLeaseInclude<ExtArgs> | null
    /**
     * The filter to search for the TenantLease to update in case it exists.
     */
    where: TenantLeaseWhereUniqueInput
    /**
     * In case the TenantLease found by the `where` argument doesn't exist, create a new TenantLease with this data.
     */
    create: XOR<TenantLeaseCreateInput, TenantLeaseUncheckedCreateInput>
    /**
     * In case the TenantLease was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantLeaseUpdateInput, TenantLeaseUncheckedUpdateInput>
  }

  /**
   * TenantLease delete
   */
  export type TenantLeaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantLease
     */
    select?: TenantLeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantLease
     */
    omit?: TenantLeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantLeaseInclude<ExtArgs> | null
    /**
     * Filter which TenantLease to delete.
     */
    where: TenantLeaseWhereUniqueInput
  }

  /**
   * TenantLease deleteMany
   */
  export type TenantLeaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantLeases to delete
     */
    where?: TenantLeaseWhereInput
    /**
     * Limit how many TenantLeases to delete.
     */
    limit?: number
  }

  /**
   * TenantLease without action
   */
  export type TenantLeaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantLease
     */
    select?: TenantLeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantLease
     */
    omit?: TenantLeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantLeaseInclude<ExtArgs> | null
  }


  /**
   * Model MaintenanceRequest
   */

  export type AggregateMaintenanceRequest = {
    _count: MaintenanceRequestCountAggregateOutputType | null
    _min: MaintenanceRequestMinAggregateOutputType | null
    _max: MaintenanceRequestMaxAggregateOutputType | null
  }

  export type MaintenanceRequestMinAggregateOutputType = {
    id: string | null
    leaseId: string | null
    description: string | null
    status: $Enums.MaintenanceRequestStatus | null
    priority: $Enums.MaintenanceRequestPriority | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MaintenanceRequestMaxAggregateOutputType = {
    id: string | null
    leaseId: string | null
    description: string | null
    status: $Enums.MaintenanceRequestStatus | null
    priority: $Enums.MaintenanceRequestPriority | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MaintenanceRequestCountAggregateOutputType = {
    id: number
    leaseId: number
    description: number
    status: number
    priority: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MaintenanceRequestMinAggregateInputType = {
    id?: true
    leaseId?: true
    description?: true
    status?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MaintenanceRequestMaxAggregateInputType = {
    id?: true
    leaseId?: true
    description?: true
    status?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MaintenanceRequestCountAggregateInputType = {
    id?: true
    leaseId?: true
    description?: true
    status?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MaintenanceRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaintenanceRequest to aggregate.
     */
    where?: MaintenanceRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceRequests to fetch.
     */
    orderBy?: MaintenanceRequestOrderByWithRelationInput | MaintenanceRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaintenanceRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MaintenanceRequests
    **/
    _count?: true | MaintenanceRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaintenanceRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaintenanceRequestMaxAggregateInputType
  }

  export type GetMaintenanceRequestAggregateType<T extends MaintenanceRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateMaintenanceRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaintenanceRequest[P]>
      : GetScalarType<T[P], AggregateMaintenanceRequest[P]>
  }




  export type MaintenanceRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceRequestWhereInput
    orderBy?: MaintenanceRequestOrderByWithAggregationInput | MaintenanceRequestOrderByWithAggregationInput[]
    by: MaintenanceRequestScalarFieldEnum[] | MaintenanceRequestScalarFieldEnum
    having?: MaintenanceRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaintenanceRequestCountAggregateInputType | true
    _min?: MaintenanceRequestMinAggregateInputType
    _max?: MaintenanceRequestMaxAggregateInputType
  }

  export type MaintenanceRequestGroupByOutputType = {
    id: string
    leaseId: string
    description: string | null
    status: $Enums.MaintenanceRequestStatus | null
    priority: $Enums.MaintenanceRequestPriority
    createdAt: Date
    updatedAt: Date
    _count: MaintenanceRequestCountAggregateOutputType | null
    _min: MaintenanceRequestMinAggregateOutputType | null
    _max: MaintenanceRequestMaxAggregateOutputType | null
  }

  type GetMaintenanceRequestGroupByPayload<T extends MaintenanceRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaintenanceRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaintenanceRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaintenanceRequestGroupByOutputType[P]>
            : GetScalarType<T[P], MaintenanceRequestGroupByOutputType[P]>
        }
      >
    >


  export type MaintenanceRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leaseId?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    File?: boolean | MaintenanceRequest$FileArgs<ExtArgs>
    lease?: boolean | LeaseDefaultArgs<ExtArgs>
    _count?: boolean | MaintenanceRequestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenanceRequest"]>

  export type MaintenanceRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leaseId?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lease?: boolean | LeaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenanceRequest"]>

  export type MaintenanceRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leaseId?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lease?: boolean | LeaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenanceRequest"]>

  export type MaintenanceRequestSelectScalar = {
    id?: boolean
    leaseId?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MaintenanceRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "leaseId" | "description" | "status" | "priority" | "createdAt" | "updatedAt", ExtArgs["result"]["maintenanceRequest"]>
  export type MaintenanceRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    File?: boolean | MaintenanceRequest$FileArgs<ExtArgs>
    lease?: boolean | LeaseDefaultArgs<ExtArgs>
    _count?: boolean | MaintenanceRequestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MaintenanceRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lease?: boolean | LeaseDefaultArgs<ExtArgs>
  }
  export type MaintenanceRequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lease?: boolean | LeaseDefaultArgs<ExtArgs>
  }

  export type $MaintenanceRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MaintenanceRequest"
    objects: {
      File: Prisma.$FilePayload<ExtArgs>[]
      lease: Prisma.$LeasePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      leaseId: string
      description: string | null
      status: $Enums.MaintenanceRequestStatus | null
      priority: $Enums.MaintenanceRequestPriority
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["maintenanceRequest"]>
    composites: {}
  }

  type MaintenanceRequestGetPayload<S extends boolean | null | undefined | MaintenanceRequestDefaultArgs> = $Result.GetResult<Prisma.$MaintenanceRequestPayload, S>

  type MaintenanceRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MaintenanceRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MaintenanceRequestCountAggregateInputType | true
    }

  export interface MaintenanceRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MaintenanceRequest'], meta: { name: 'MaintenanceRequest' } }
    /**
     * Find zero or one MaintenanceRequest that matches the filter.
     * @param {MaintenanceRequestFindUniqueArgs} args - Arguments to find a MaintenanceRequest
     * @example
     * // Get one MaintenanceRequest
     * const maintenanceRequest = await prisma.maintenanceRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaintenanceRequestFindUniqueArgs>(args: SelectSubset<T, MaintenanceRequestFindUniqueArgs<ExtArgs>>): Prisma__MaintenanceRequestClient<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MaintenanceRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MaintenanceRequestFindUniqueOrThrowArgs} args - Arguments to find a MaintenanceRequest
     * @example
     * // Get one MaintenanceRequest
     * const maintenanceRequest = await prisma.maintenanceRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaintenanceRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, MaintenanceRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaintenanceRequestClient<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MaintenanceRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceRequestFindFirstArgs} args - Arguments to find a MaintenanceRequest
     * @example
     * // Get one MaintenanceRequest
     * const maintenanceRequest = await prisma.maintenanceRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaintenanceRequestFindFirstArgs>(args?: SelectSubset<T, MaintenanceRequestFindFirstArgs<ExtArgs>>): Prisma__MaintenanceRequestClient<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MaintenanceRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceRequestFindFirstOrThrowArgs} args - Arguments to find a MaintenanceRequest
     * @example
     * // Get one MaintenanceRequest
     * const maintenanceRequest = await prisma.maintenanceRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaintenanceRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, MaintenanceRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaintenanceRequestClient<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MaintenanceRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MaintenanceRequests
     * const maintenanceRequests = await prisma.maintenanceRequest.findMany()
     * 
     * // Get first 10 MaintenanceRequests
     * const maintenanceRequests = await prisma.maintenanceRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const maintenanceRequestWithIdOnly = await prisma.maintenanceRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaintenanceRequestFindManyArgs>(args?: SelectSubset<T, MaintenanceRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MaintenanceRequest.
     * @param {MaintenanceRequestCreateArgs} args - Arguments to create a MaintenanceRequest.
     * @example
     * // Create one MaintenanceRequest
     * const MaintenanceRequest = await prisma.maintenanceRequest.create({
     *   data: {
     *     // ... data to create a MaintenanceRequest
     *   }
     * })
     * 
     */
    create<T extends MaintenanceRequestCreateArgs>(args: SelectSubset<T, MaintenanceRequestCreateArgs<ExtArgs>>): Prisma__MaintenanceRequestClient<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MaintenanceRequests.
     * @param {MaintenanceRequestCreateManyArgs} args - Arguments to create many MaintenanceRequests.
     * @example
     * // Create many MaintenanceRequests
     * const maintenanceRequest = await prisma.maintenanceRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaintenanceRequestCreateManyArgs>(args?: SelectSubset<T, MaintenanceRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MaintenanceRequests and returns the data saved in the database.
     * @param {MaintenanceRequestCreateManyAndReturnArgs} args - Arguments to create many MaintenanceRequests.
     * @example
     * // Create many MaintenanceRequests
     * const maintenanceRequest = await prisma.maintenanceRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MaintenanceRequests and only return the `id`
     * const maintenanceRequestWithIdOnly = await prisma.maintenanceRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaintenanceRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, MaintenanceRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MaintenanceRequest.
     * @param {MaintenanceRequestDeleteArgs} args - Arguments to delete one MaintenanceRequest.
     * @example
     * // Delete one MaintenanceRequest
     * const MaintenanceRequest = await prisma.maintenanceRequest.delete({
     *   where: {
     *     // ... filter to delete one MaintenanceRequest
     *   }
     * })
     * 
     */
    delete<T extends MaintenanceRequestDeleteArgs>(args: SelectSubset<T, MaintenanceRequestDeleteArgs<ExtArgs>>): Prisma__MaintenanceRequestClient<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MaintenanceRequest.
     * @param {MaintenanceRequestUpdateArgs} args - Arguments to update one MaintenanceRequest.
     * @example
     * // Update one MaintenanceRequest
     * const maintenanceRequest = await prisma.maintenanceRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaintenanceRequestUpdateArgs>(args: SelectSubset<T, MaintenanceRequestUpdateArgs<ExtArgs>>): Prisma__MaintenanceRequestClient<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MaintenanceRequests.
     * @param {MaintenanceRequestDeleteManyArgs} args - Arguments to filter MaintenanceRequests to delete.
     * @example
     * // Delete a few MaintenanceRequests
     * const { count } = await prisma.maintenanceRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaintenanceRequestDeleteManyArgs>(args?: SelectSubset<T, MaintenanceRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaintenanceRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MaintenanceRequests
     * const maintenanceRequest = await prisma.maintenanceRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaintenanceRequestUpdateManyArgs>(args: SelectSubset<T, MaintenanceRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaintenanceRequests and returns the data updated in the database.
     * @param {MaintenanceRequestUpdateManyAndReturnArgs} args - Arguments to update many MaintenanceRequests.
     * @example
     * // Update many MaintenanceRequests
     * const maintenanceRequest = await prisma.maintenanceRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MaintenanceRequests and only return the `id`
     * const maintenanceRequestWithIdOnly = await prisma.maintenanceRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MaintenanceRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, MaintenanceRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MaintenanceRequest.
     * @param {MaintenanceRequestUpsertArgs} args - Arguments to update or create a MaintenanceRequest.
     * @example
     * // Update or create a MaintenanceRequest
     * const maintenanceRequest = await prisma.maintenanceRequest.upsert({
     *   create: {
     *     // ... data to create a MaintenanceRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MaintenanceRequest we want to update
     *   }
     * })
     */
    upsert<T extends MaintenanceRequestUpsertArgs>(args: SelectSubset<T, MaintenanceRequestUpsertArgs<ExtArgs>>): Prisma__MaintenanceRequestClient<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MaintenanceRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceRequestCountArgs} args - Arguments to filter MaintenanceRequests to count.
     * @example
     * // Count the number of MaintenanceRequests
     * const count = await prisma.maintenanceRequest.count({
     *   where: {
     *     // ... the filter for the MaintenanceRequests we want to count
     *   }
     * })
    **/
    count<T extends MaintenanceRequestCountArgs>(
      args?: Subset<T, MaintenanceRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaintenanceRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MaintenanceRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaintenanceRequestAggregateArgs>(args: Subset<T, MaintenanceRequestAggregateArgs>): Prisma.PrismaPromise<GetMaintenanceRequestAggregateType<T>>

    /**
     * Group by MaintenanceRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaintenanceRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaintenanceRequestGroupByArgs['orderBy'] }
        : { orderBy?: MaintenanceRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaintenanceRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaintenanceRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MaintenanceRequest model
   */
  readonly fields: MaintenanceRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MaintenanceRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaintenanceRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    File<T extends MaintenanceRequest$FileArgs<ExtArgs> = {}>(args?: Subset<T, MaintenanceRequest$FileArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lease<T extends LeaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LeaseDefaultArgs<ExtArgs>>): Prisma__LeaseClient<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MaintenanceRequest model
   */
  interface MaintenanceRequestFieldRefs {
    readonly id: FieldRef<"MaintenanceRequest", 'String'>
    readonly leaseId: FieldRef<"MaintenanceRequest", 'String'>
    readonly description: FieldRef<"MaintenanceRequest", 'String'>
    readonly status: FieldRef<"MaintenanceRequest", 'MaintenanceRequestStatus'>
    readonly priority: FieldRef<"MaintenanceRequest", 'MaintenanceRequestPriority'>
    readonly createdAt: FieldRef<"MaintenanceRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"MaintenanceRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MaintenanceRequest findUnique
   */
  export type MaintenanceRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceRequest to fetch.
     */
    where: MaintenanceRequestWhereUniqueInput
  }

  /**
   * MaintenanceRequest findUniqueOrThrow
   */
  export type MaintenanceRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceRequest to fetch.
     */
    where: MaintenanceRequestWhereUniqueInput
  }

  /**
   * MaintenanceRequest findFirst
   */
  export type MaintenanceRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceRequest to fetch.
     */
    where?: MaintenanceRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceRequests to fetch.
     */
    orderBy?: MaintenanceRequestOrderByWithRelationInput | MaintenanceRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaintenanceRequests.
     */
    cursor?: MaintenanceRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaintenanceRequests.
     */
    distinct?: MaintenanceRequestScalarFieldEnum | MaintenanceRequestScalarFieldEnum[]
  }

  /**
   * MaintenanceRequest findFirstOrThrow
   */
  export type MaintenanceRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceRequest to fetch.
     */
    where?: MaintenanceRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceRequests to fetch.
     */
    orderBy?: MaintenanceRequestOrderByWithRelationInput | MaintenanceRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaintenanceRequests.
     */
    cursor?: MaintenanceRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaintenanceRequests.
     */
    distinct?: MaintenanceRequestScalarFieldEnum | MaintenanceRequestScalarFieldEnum[]
  }

  /**
   * MaintenanceRequest findMany
   */
  export type MaintenanceRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceRequests to fetch.
     */
    where?: MaintenanceRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceRequests to fetch.
     */
    orderBy?: MaintenanceRequestOrderByWithRelationInput | MaintenanceRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MaintenanceRequests.
     */
    cursor?: MaintenanceRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceRequests.
     */
    skip?: number
    distinct?: MaintenanceRequestScalarFieldEnum | MaintenanceRequestScalarFieldEnum[]
  }

  /**
   * MaintenanceRequest create
   */
  export type MaintenanceRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a MaintenanceRequest.
     */
    data: XOR<MaintenanceRequestCreateInput, MaintenanceRequestUncheckedCreateInput>
  }

  /**
   * MaintenanceRequest createMany
   */
  export type MaintenanceRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MaintenanceRequests.
     */
    data: MaintenanceRequestCreateManyInput | MaintenanceRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MaintenanceRequest createManyAndReturn
   */
  export type MaintenanceRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * The data used to create many MaintenanceRequests.
     */
    data: MaintenanceRequestCreateManyInput | MaintenanceRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MaintenanceRequest update
   */
  export type MaintenanceRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a MaintenanceRequest.
     */
    data: XOR<MaintenanceRequestUpdateInput, MaintenanceRequestUncheckedUpdateInput>
    /**
     * Choose, which MaintenanceRequest to update.
     */
    where: MaintenanceRequestWhereUniqueInput
  }

  /**
   * MaintenanceRequest updateMany
   */
  export type MaintenanceRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MaintenanceRequests.
     */
    data: XOR<MaintenanceRequestUpdateManyMutationInput, MaintenanceRequestUncheckedUpdateManyInput>
    /**
     * Filter which MaintenanceRequests to update
     */
    where?: MaintenanceRequestWhereInput
    /**
     * Limit how many MaintenanceRequests to update.
     */
    limit?: number
  }

  /**
   * MaintenanceRequest updateManyAndReturn
   */
  export type MaintenanceRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * The data used to update MaintenanceRequests.
     */
    data: XOR<MaintenanceRequestUpdateManyMutationInput, MaintenanceRequestUncheckedUpdateManyInput>
    /**
     * Filter which MaintenanceRequests to update
     */
    where?: MaintenanceRequestWhereInput
    /**
     * Limit how many MaintenanceRequests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MaintenanceRequest upsert
   */
  export type MaintenanceRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the MaintenanceRequest to update in case it exists.
     */
    where: MaintenanceRequestWhereUniqueInput
    /**
     * In case the MaintenanceRequest found by the `where` argument doesn't exist, create a new MaintenanceRequest with this data.
     */
    create: XOR<MaintenanceRequestCreateInput, MaintenanceRequestUncheckedCreateInput>
    /**
     * In case the MaintenanceRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaintenanceRequestUpdateInput, MaintenanceRequestUncheckedUpdateInput>
  }

  /**
   * MaintenanceRequest delete
   */
  export type MaintenanceRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    /**
     * Filter which MaintenanceRequest to delete.
     */
    where: MaintenanceRequestWhereUniqueInput
  }

  /**
   * MaintenanceRequest deleteMany
   */
  export type MaintenanceRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaintenanceRequests to delete
     */
    where?: MaintenanceRequestWhereInput
    /**
     * Limit how many MaintenanceRequests to delete.
     */
    limit?: number
  }

  /**
   * MaintenanceRequest.File
   */
  export type MaintenanceRequest$FileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    cursor?: FileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * MaintenanceRequest without action
   */
  export type MaintenanceRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
  }


  /**
   * Model File
   */

  export type AggregateFile = {
    _count: FileCountAggregateOutputType | null
    _avg: FileAvgAggregateOutputType | null
    _sum: FileSumAggregateOutputType | null
    _min: FileMinAggregateOutputType | null
    _max: FileMaxAggregateOutputType | null
  }

  export type FileAvgAggregateOutputType = {
    size: number | null
  }

  export type FileSumAggregateOutputType = {
    size: number | null
  }

  export type FileMinAggregateOutputType = {
    id: string | null
    name: string | null
    url: string | null
    ownerId: string | null
    tenantId: string | null
    propertyId: string | null
    leaseId: string | null
    invoiceId: string | null
    maintenanceRequestId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    size: number | null
    type: string | null
  }

  export type FileMaxAggregateOutputType = {
    id: string | null
    name: string | null
    url: string | null
    ownerId: string | null
    tenantId: string | null
    propertyId: string | null
    leaseId: string | null
    invoiceId: string | null
    maintenanceRequestId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    size: number | null
    type: string | null
  }

  export type FileCountAggregateOutputType = {
    id: number
    name: number
    url: number
    ownerId: number
    tenantId: number
    propertyId: number
    leaseId: number
    invoiceId: number
    maintenanceRequestId: number
    createdAt: number
    updatedAt: number
    size: number
    type: number
    _all: number
  }


  export type FileAvgAggregateInputType = {
    size?: true
  }

  export type FileSumAggregateInputType = {
    size?: true
  }

  export type FileMinAggregateInputType = {
    id?: true
    name?: true
    url?: true
    ownerId?: true
    tenantId?: true
    propertyId?: true
    leaseId?: true
    invoiceId?: true
    maintenanceRequestId?: true
    createdAt?: true
    updatedAt?: true
    size?: true
    type?: true
  }

  export type FileMaxAggregateInputType = {
    id?: true
    name?: true
    url?: true
    ownerId?: true
    tenantId?: true
    propertyId?: true
    leaseId?: true
    invoiceId?: true
    maintenanceRequestId?: true
    createdAt?: true
    updatedAt?: true
    size?: true
    type?: true
  }

  export type FileCountAggregateInputType = {
    id?: true
    name?: true
    url?: true
    ownerId?: true
    tenantId?: true
    propertyId?: true
    leaseId?: true
    invoiceId?: true
    maintenanceRequestId?: true
    createdAt?: true
    updatedAt?: true
    size?: true
    type?: true
    _all?: true
  }

  export type FileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which File to aggregate.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Files
    **/
    _count?: true | FileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FileMaxAggregateInputType
  }

  export type GetFileAggregateType<T extends FileAggregateArgs> = {
        [P in keyof T & keyof AggregateFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFile[P]>
      : GetScalarType<T[P], AggregateFile[P]>
  }




  export type FileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
    orderBy?: FileOrderByWithAggregationInput | FileOrderByWithAggregationInput[]
    by: FileScalarFieldEnum[] | FileScalarFieldEnum
    having?: FileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FileCountAggregateInputType | true
    _avg?: FileAvgAggregateInputType
    _sum?: FileSumAggregateInputType
    _min?: FileMinAggregateInputType
    _max?: FileMaxAggregateInputType
  }

  export type FileGroupByOutputType = {
    id: string
    name: string
    url: string
    ownerId: string
    tenantId: string | null
    propertyId: string | null
    leaseId: string | null
    invoiceId: string | null
    maintenanceRequestId: string | null
    createdAt: Date
    updatedAt: Date
    size: number | null
    type: string | null
    _count: FileCountAggregateOutputType | null
    _avg: FileAvgAggregateOutputType | null
    _sum: FileSumAggregateOutputType | null
    _min: FileMinAggregateOutputType | null
    _max: FileMaxAggregateOutputType | null
  }

  type GetFileGroupByPayload<T extends FileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FileGroupByOutputType[P]>
            : GetScalarType<T[P], FileGroupByOutputType[P]>
        }
      >
    >


  export type FileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    ownerId?: boolean
    tenantId?: boolean
    propertyId?: boolean
    leaseId?: boolean
    invoiceId?: boolean
    maintenanceRequestId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    size?: boolean
    type?: boolean
    invoice?: boolean | File$invoiceArgs<ExtArgs>
    lease?: boolean | File$leaseArgs<ExtArgs>
    maintenanceRequest?: boolean | File$maintenanceRequestArgs<ExtArgs>
    property?: boolean | File$propertyArgs<ExtArgs>
    tenant?: boolean | File$tenantArgs<ExtArgs>
  }, ExtArgs["result"]["file"]>

  export type FileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    ownerId?: boolean
    tenantId?: boolean
    propertyId?: boolean
    leaseId?: boolean
    invoiceId?: boolean
    maintenanceRequestId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    size?: boolean
    type?: boolean
    invoice?: boolean | File$invoiceArgs<ExtArgs>
    lease?: boolean | File$leaseArgs<ExtArgs>
    maintenanceRequest?: boolean | File$maintenanceRequestArgs<ExtArgs>
    property?: boolean | File$propertyArgs<ExtArgs>
    tenant?: boolean | File$tenantArgs<ExtArgs>
  }, ExtArgs["result"]["file"]>

  export type FileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    ownerId?: boolean
    tenantId?: boolean
    propertyId?: boolean
    leaseId?: boolean
    invoiceId?: boolean
    maintenanceRequestId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    size?: boolean
    type?: boolean
    invoice?: boolean | File$invoiceArgs<ExtArgs>
    lease?: boolean | File$leaseArgs<ExtArgs>
    maintenanceRequest?: boolean | File$maintenanceRequestArgs<ExtArgs>
    property?: boolean | File$propertyArgs<ExtArgs>
    tenant?: boolean | File$tenantArgs<ExtArgs>
  }, ExtArgs["result"]["file"]>

  export type FileSelectScalar = {
    id?: boolean
    name?: boolean
    url?: boolean
    ownerId?: boolean
    tenantId?: boolean
    propertyId?: boolean
    leaseId?: boolean
    invoiceId?: boolean
    maintenanceRequestId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    size?: boolean
    type?: boolean
  }

  export type FileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "url" | "ownerId" | "tenantId" | "propertyId" | "leaseId" | "invoiceId" | "maintenanceRequestId" | "createdAt" | "updatedAt" | "size" | "type", ExtArgs["result"]["file"]>
  export type FileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | File$invoiceArgs<ExtArgs>
    lease?: boolean | File$leaseArgs<ExtArgs>
    maintenanceRequest?: boolean | File$maintenanceRequestArgs<ExtArgs>
    property?: boolean | File$propertyArgs<ExtArgs>
    tenant?: boolean | File$tenantArgs<ExtArgs>
  }
  export type FileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | File$invoiceArgs<ExtArgs>
    lease?: boolean | File$leaseArgs<ExtArgs>
    maintenanceRequest?: boolean | File$maintenanceRequestArgs<ExtArgs>
    property?: boolean | File$propertyArgs<ExtArgs>
    tenant?: boolean | File$tenantArgs<ExtArgs>
  }
  export type FileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | File$invoiceArgs<ExtArgs>
    lease?: boolean | File$leaseArgs<ExtArgs>
    maintenanceRequest?: boolean | File$maintenanceRequestArgs<ExtArgs>
    property?: boolean | File$propertyArgs<ExtArgs>
    tenant?: boolean | File$tenantArgs<ExtArgs>
  }

  export type $FilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "File"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs> | null
      lease: Prisma.$LeasePayload<ExtArgs> | null
      maintenanceRequest: Prisma.$MaintenanceRequestPayload<ExtArgs> | null
      property: Prisma.$PropertyPayload<ExtArgs> | null
      tenant: Prisma.$TenantPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      url: string
      ownerId: string
      tenantId: string | null
      propertyId: string | null
      leaseId: string | null
      invoiceId: string | null
      maintenanceRequestId: string | null
      createdAt: Date
      updatedAt: Date
      size: number | null
      type: string | null
    }, ExtArgs["result"]["file"]>
    composites: {}
  }

  type FileGetPayload<S extends boolean | null | undefined | FileDefaultArgs> = $Result.GetResult<Prisma.$FilePayload, S>

  type FileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FileCountAggregateInputType | true
    }

  export interface FileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['File'], meta: { name: 'File' } }
    /**
     * Find zero or one File that matches the filter.
     * @param {FileFindUniqueArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FileFindUniqueArgs>(args: SelectSubset<T, FileFindUniqueArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one File that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FileFindUniqueOrThrowArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FileFindUniqueOrThrowArgs>(args: SelectSubset<T, FileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first File that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindFirstArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FileFindFirstArgs>(args?: SelectSubset<T, FileFindFirstArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first File that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindFirstOrThrowArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FileFindFirstOrThrowArgs>(args?: SelectSubset<T, FileFindFirstOrThrowArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Files
     * const files = await prisma.file.findMany()
     * 
     * // Get first 10 Files
     * const files = await prisma.file.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fileWithIdOnly = await prisma.file.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FileFindManyArgs>(args?: SelectSubset<T, FileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a File.
     * @param {FileCreateArgs} args - Arguments to create a File.
     * @example
     * // Create one File
     * const File = await prisma.file.create({
     *   data: {
     *     // ... data to create a File
     *   }
     * })
     * 
     */
    create<T extends FileCreateArgs>(args: SelectSubset<T, FileCreateArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Files.
     * @param {FileCreateManyArgs} args - Arguments to create many Files.
     * @example
     * // Create many Files
     * const file = await prisma.file.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FileCreateManyArgs>(args?: SelectSubset<T, FileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Files and returns the data saved in the database.
     * @param {FileCreateManyAndReturnArgs} args - Arguments to create many Files.
     * @example
     * // Create many Files
     * const file = await prisma.file.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Files and only return the `id`
     * const fileWithIdOnly = await prisma.file.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FileCreateManyAndReturnArgs>(args?: SelectSubset<T, FileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a File.
     * @param {FileDeleteArgs} args - Arguments to delete one File.
     * @example
     * // Delete one File
     * const File = await prisma.file.delete({
     *   where: {
     *     // ... filter to delete one File
     *   }
     * })
     * 
     */
    delete<T extends FileDeleteArgs>(args: SelectSubset<T, FileDeleteArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one File.
     * @param {FileUpdateArgs} args - Arguments to update one File.
     * @example
     * // Update one File
     * const file = await prisma.file.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FileUpdateArgs>(args: SelectSubset<T, FileUpdateArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Files.
     * @param {FileDeleteManyArgs} args - Arguments to filter Files to delete.
     * @example
     * // Delete a few Files
     * const { count } = await prisma.file.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FileDeleteManyArgs>(args?: SelectSubset<T, FileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Files
     * const file = await prisma.file.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FileUpdateManyArgs>(args: SelectSubset<T, FileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Files and returns the data updated in the database.
     * @param {FileUpdateManyAndReturnArgs} args - Arguments to update many Files.
     * @example
     * // Update many Files
     * const file = await prisma.file.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Files and only return the `id`
     * const fileWithIdOnly = await prisma.file.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FileUpdateManyAndReturnArgs>(args: SelectSubset<T, FileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one File.
     * @param {FileUpsertArgs} args - Arguments to update or create a File.
     * @example
     * // Update or create a File
     * const file = await prisma.file.upsert({
     *   create: {
     *     // ... data to create a File
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the File we want to update
     *   }
     * })
     */
    upsert<T extends FileUpsertArgs>(args: SelectSubset<T, FileUpsertArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileCountArgs} args - Arguments to filter Files to count.
     * @example
     * // Count the number of Files
     * const count = await prisma.file.count({
     *   where: {
     *     // ... the filter for the Files we want to count
     *   }
     * })
    **/
    count<T extends FileCountArgs>(
      args?: Subset<T, FileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FileAggregateArgs>(args: Subset<T, FileAggregateArgs>): Prisma.PrismaPromise<GetFileAggregateType<T>>

    /**
     * Group by File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FileGroupByArgs['orderBy'] }
        : { orderBy?: FileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the File model
   */
  readonly fields: FileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for File.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends File$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, File$invoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    lease<T extends File$leaseArgs<ExtArgs> = {}>(args?: Subset<T, File$leaseArgs<ExtArgs>>): Prisma__LeaseClient<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    maintenanceRequest<T extends File$maintenanceRequestArgs<ExtArgs> = {}>(args?: Subset<T, File$maintenanceRequestArgs<ExtArgs>>): Prisma__MaintenanceRequestClient<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    property<T extends File$propertyArgs<ExtArgs> = {}>(args?: Subset<T, File$propertyArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tenant<T extends File$tenantArgs<ExtArgs> = {}>(args?: Subset<T, File$tenantArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the File model
   */
  interface FileFieldRefs {
    readonly id: FieldRef<"File", 'String'>
    readonly name: FieldRef<"File", 'String'>
    readonly url: FieldRef<"File", 'String'>
    readonly ownerId: FieldRef<"File", 'String'>
    readonly tenantId: FieldRef<"File", 'String'>
    readonly propertyId: FieldRef<"File", 'String'>
    readonly leaseId: FieldRef<"File", 'String'>
    readonly invoiceId: FieldRef<"File", 'String'>
    readonly maintenanceRequestId: FieldRef<"File", 'String'>
    readonly createdAt: FieldRef<"File", 'DateTime'>
    readonly updatedAt: FieldRef<"File", 'DateTime'>
    readonly size: FieldRef<"File", 'Int'>
    readonly type: FieldRef<"File", 'String'>
  }
    

  // Custom InputTypes
  /**
   * File findUnique
   */
  export type FileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File findUniqueOrThrow
   */
  export type FileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File findFirst
   */
  export type FileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Files.
     */
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File findFirstOrThrow
   */
  export type FileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Files.
     */
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File findMany
   */
  export type FileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which Files to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File create
   */
  export type FileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The data needed to create a File.
     */
    data: XOR<FileCreateInput, FileUncheckedCreateInput>
  }

  /**
   * File createMany
   */
  export type FileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Files.
     */
    data: FileCreateManyInput | FileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * File createManyAndReturn
   */
  export type FileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * The data used to create many Files.
     */
    data: FileCreateManyInput | FileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * File update
   */
  export type FileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The data needed to update a File.
     */
    data: XOR<FileUpdateInput, FileUncheckedUpdateInput>
    /**
     * Choose, which File to update.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File updateMany
   */
  export type FileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Files.
     */
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyInput>
    /**
     * Filter which Files to update
     */
    where?: FileWhereInput
    /**
     * Limit how many Files to update.
     */
    limit?: number
  }

  /**
   * File updateManyAndReturn
   */
  export type FileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * The data used to update Files.
     */
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyInput>
    /**
     * Filter which Files to update
     */
    where?: FileWhereInput
    /**
     * Limit how many Files to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * File upsert
   */
  export type FileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The filter to search for the File to update in case it exists.
     */
    where: FileWhereUniqueInput
    /**
     * In case the File found by the `where` argument doesn't exist, create a new File with this data.
     */
    create: XOR<FileCreateInput, FileUncheckedCreateInput>
    /**
     * In case the File was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FileUpdateInput, FileUncheckedUpdateInput>
  }

  /**
   * File delete
   */
  export type FileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter which File to delete.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File deleteMany
   */
  export type FileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Files to delete
     */
    where?: FileWhereInput
    /**
     * Limit how many Files to delete.
     */
    limit?: number
  }

  /**
   * File.invoice
   */
  export type File$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
  }

  /**
   * File.lease
   */
  export type File$leaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseInclude<ExtArgs> | null
    where?: LeaseWhereInput
  }

  /**
   * File.maintenanceRequest
   */
  export type File$maintenanceRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    where?: MaintenanceRequestWhereInput
  }

  /**
   * File.property
   */
  export type File$propertyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    where?: PropertyWhereInput
  }

  /**
   * File.tenant
   */
  export type File$tenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    where?: TenantWhereInput
  }

  /**
   * File without action
   */
  export type FileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    addressLine1: 'addressLine1',
    addressLine2: 'addressLine2',
    city: 'city',
    idNumber: 'idNumber',
    paystackSplitGroupId: 'paystackSplitGroupId',
    paystackSubAccountId: 'paystackSubAccountId',
    paystackSubscriptionId: 'paystackSubscriptionId',
    state: 'state',
    zip: 'zip',
    onboardingCompleted: 'onboardingCompleted',
    businessName: 'businessName',
    countryCode: 'countryCode',
    numberOfProperties: 'numberOfProperties',
    numberOfUnits: 'numberOfUnits',
    phone: 'phone'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    expiresAt: 'expiresAt',
    token: 'token',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    userId: 'userId'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    providerId: 'providerId',
    userId: 'userId',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    idToken: 'idToken',
    accessTokenExpiresAt: 'accessTokenExpiresAt',
    refreshTokenExpiresAt: 'refreshTokenExpiresAt',
    scope: 'scope',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const VerificationScalarFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    value: 'value',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VerificationScalarFieldEnum = (typeof VerificationScalarFieldEnum)[keyof typeof VerificationScalarFieldEnum]


  export const TenantScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    email: 'email',
    firstName: 'firstName',
    lastName: 'lastName',
    phone: 'phone',
    landlordId: 'landlordId',
    dateOfBirth: 'dateOfBirth',
    tenantEmergencyContact: 'tenantEmergencyContact',
    tenantIncome: 'tenantIncome',
    additionalEmails: 'additionalEmails',
    additionalPhones: 'additionalPhones',
    emergencyContacts: 'emergencyContacts',
    vehicles: 'vehicles',
    avatarUrl: 'avatarUrl',
    fullName: 'fullName',
    paystackCustomerId: 'paystackCustomerId'
  };

  export type TenantScalarFieldEnum = (typeof TenantScalarFieldEnum)[keyof typeof TenantScalarFieldEnum]


  export const PropertyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    addressLine1: 'addressLine1',
    addressLine2: 'addressLine2',
    city: 'city',
    state: 'state',
    zip: 'zip',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    imageUrl: 'imageUrl',
    propertyStatus: 'propertyStatus',
    propertyType: 'propertyType',
    amenities: 'amenities',
    countryCode: 'countryCode',
    features: 'features',
    landlordId: 'landlordId'
  };

  export type PropertyScalarFieldEnum = (typeof PropertyScalarFieldEnum)[keyof typeof PropertyScalarFieldEnum]


  export const UnitScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    bathrooms: 'bathrooms',
    bedrooms: 'bedrooms',
    deposit: 'deposit',
    marketRent: 'marketRent',
    sqmt: 'sqmt'
  };

  export type UnitScalarFieldEnum = (typeof UnitScalarFieldEnum)[keyof typeof UnitScalarFieldEnum]


  export const LeaseScalarFieldEnum: {
    id: 'id',
    startDate: 'startDate',
    endDate: 'endDate',
    rent: 'rent',
    deposit: 'deposit',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    rentDueCurrency: 'rentDueCurrency',
    unitId: 'unitId',
    automaticInvoice: 'automaticInvoice',
    invoiceCycle: 'invoiceCycle',
    leaseType: 'leaseType'
  };

  export type LeaseScalarFieldEnum = (typeof LeaseScalarFieldEnum)[keyof typeof LeaseScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    leaseId: 'leaseId',
    description: 'description',
    dueAmount: 'dueAmount',
    category: 'category',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    paystackId: 'paystackId',
    dueDate: 'dueDate',
    lineItems: 'lineItems',
    landlordId: 'landlordId',
    tenantId: 'tenantId',
    recurringBillableId: 'recurringBillableId'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const RecurringBillableScalarFieldEnum: {
    id: 'id',
    startDate: 'startDate',
    endDate: 'endDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    description: 'description',
    amount: 'amount',
    category: 'category',
    cycle: 'cycle',
    nextInvoiceAt: 'nextInvoiceAt',
    isActive: 'isActive',
    leaseId: 'leaseId',
    tenantId: 'tenantId',
    propertyId: 'propertyId'
  };

  export type RecurringBillableScalarFieldEnum = (typeof RecurringBillableScalarFieldEnum)[keyof typeof RecurringBillableScalarFieldEnum]


  export const TransactionsScalarFieldEnum: {
    id: 'id',
    leaseId: 'leaseId',
    description: 'description',
    amountPaid: 'amountPaid',
    referenceId: 'referenceId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    invoiceId: 'invoiceId'
  };

  export type TransactionsScalarFieldEnum = (typeof TransactionsScalarFieldEnum)[keyof typeof TransactionsScalarFieldEnum]


  export const TenantLeaseScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    leaseId: 'leaseId'
  };

  export type TenantLeaseScalarFieldEnum = (typeof TenantLeaseScalarFieldEnum)[keyof typeof TenantLeaseScalarFieldEnum]


  export const MaintenanceRequestScalarFieldEnum: {
    id: 'id',
    leaseId: 'leaseId',
    description: 'description',
    status: 'status',
    priority: 'priority',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MaintenanceRequestScalarFieldEnum = (typeof MaintenanceRequestScalarFieldEnum)[keyof typeof MaintenanceRequestScalarFieldEnum]


  export const FileScalarFieldEnum: {
    id: 'id',
    name: 'name',
    url: 'url',
    ownerId: 'ownerId',
    tenantId: 'tenantId',
    propertyId: 'propertyId',
    leaseId: 'leaseId',
    invoiceId: 'invoiceId',
    maintenanceRequestId: 'maintenanceRequestId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    size: 'size',
    type: 'type'
  };

  export type FileScalarFieldEnum = (typeof FileScalarFieldEnum)[keyof typeof FileScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'PropertyStatus'
   */
  export type EnumPropertyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PropertyStatus'>
    


  /**
   * Reference to a field of type 'PropertyStatus[]'
   */
  export type ListEnumPropertyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PropertyStatus[]'>
    


  /**
   * Reference to a field of type 'PropertyType'
   */
  export type EnumPropertyTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PropertyType'>
    


  /**
   * Reference to a field of type 'PropertyType[]'
   */
  export type ListEnumPropertyTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PropertyType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'LeaseStatus'
   */
  export type EnumLeaseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaseStatus'>
    


  /**
   * Reference to a field of type 'LeaseStatus[]'
   */
  export type ListEnumLeaseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaseStatus[]'>
    


  /**
   * Reference to a field of type 'InvoiceCycle'
   */
  export type EnumInvoiceCycleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceCycle'>
    


  /**
   * Reference to a field of type 'InvoiceCycle[]'
   */
  export type ListEnumInvoiceCycleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceCycle[]'>
    


  /**
   * Reference to a field of type 'LeaseTermType'
   */
  export type EnumLeaseTermTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaseTermType'>
    


  /**
   * Reference to a field of type 'LeaseTermType[]'
   */
  export type ListEnumLeaseTermTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaseTermType[]'>
    


  /**
   * Reference to a field of type 'InvoiceCategory'
   */
  export type EnumInvoiceCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceCategory'>
    


  /**
   * Reference to a field of type 'InvoiceCategory[]'
   */
  export type ListEnumInvoiceCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceCategory[]'>
    


  /**
   * Reference to a field of type 'InvoiceStatus'
   */
  export type EnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus'>
    


  /**
   * Reference to a field of type 'InvoiceStatus[]'
   */
  export type ListEnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus[]'>
    


  /**
   * Reference to a field of type 'MaintenanceRequestStatus'
   */
  export type EnumMaintenanceRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaintenanceRequestStatus'>
    


  /**
   * Reference to a field of type 'MaintenanceRequestStatus[]'
   */
  export type ListEnumMaintenanceRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaintenanceRequestStatus[]'>
    


  /**
   * Reference to a field of type 'MaintenanceRequestPriority'
   */
  export type EnumMaintenanceRequestPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaintenanceRequestPriority'>
    


  /**
   * Reference to a field of type 'MaintenanceRequestPriority[]'
   */
  export type ListEnumMaintenanceRequestPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaintenanceRequestPriority[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    image?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    addressLine1?: StringNullableFilter<"User"> | string | null
    addressLine2?: StringNullableFilter<"User"> | string | null
    city?: StringNullableFilter<"User"> | string | null
    idNumber?: StringNullableFilter<"User"> | string | null
    paystackSplitGroupId?: StringNullableFilter<"User"> | string | null
    paystackSubAccountId?: StringNullableFilter<"User"> | string | null
    paystackSubscriptionId?: StringNullableFilter<"User"> | string | null
    state?: StringNullableFilter<"User"> | string | null
    zip?: StringNullableFilter<"User"> | string | null
    onboardingCompleted?: BoolFilter<"User"> | boolean
    businessName?: StringNullableFilter<"User"> | string | null
    countryCode?: StringNullableFilter<"User"> | string | null
    numberOfProperties?: IntNullableFilter<"User"> | number | null
    numberOfUnits?: IntNullableFilter<"User"> | number | null
    phone?: StringNullableFilter<"User"> | string | null
    accounts?: AccountListRelationFilter
    property?: PropertyListRelationFilter
    sessions?: SessionListRelationFilter
    tenant?: TenantListRelationFilter
    Invoice?: InvoiceListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    addressLine1?: SortOrderInput | SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    idNumber?: SortOrderInput | SortOrder
    paystackSplitGroupId?: SortOrderInput | SortOrder
    paystackSubAccountId?: SortOrderInput | SortOrder
    paystackSubscriptionId?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    zip?: SortOrderInput | SortOrder
    onboardingCompleted?: SortOrder
    businessName?: SortOrderInput | SortOrder
    countryCode?: SortOrderInput | SortOrder
    numberOfProperties?: SortOrderInput | SortOrder
    numberOfUnits?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    property?: PropertyOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    tenant?: TenantOrderByRelationAggregateInput
    Invoice?: InvoiceOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    image?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    addressLine1?: StringNullableFilter<"User"> | string | null
    addressLine2?: StringNullableFilter<"User"> | string | null
    city?: StringNullableFilter<"User"> | string | null
    idNumber?: StringNullableFilter<"User"> | string | null
    paystackSplitGroupId?: StringNullableFilter<"User"> | string | null
    paystackSubAccountId?: StringNullableFilter<"User"> | string | null
    paystackSubscriptionId?: StringNullableFilter<"User"> | string | null
    state?: StringNullableFilter<"User"> | string | null
    zip?: StringNullableFilter<"User"> | string | null
    onboardingCompleted?: BoolFilter<"User"> | boolean
    businessName?: StringNullableFilter<"User"> | string | null
    countryCode?: StringNullableFilter<"User"> | string | null
    numberOfProperties?: IntNullableFilter<"User"> | number | null
    numberOfUnits?: IntNullableFilter<"User"> | number | null
    phone?: StringNullableFilter<"User"> | string | null
    accounts?: AccountListRelationFilter
    property?: PropertyListRelationFilter
    sessions?: SessionListRelationFilter
    tenant?: TenantListRelationFilter
    Invoice?: InvoiceListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    addressLine1?: SortOrderInput | SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    idNumber?: SortOrderInput | SortOrder
    paystackSplitGroupId?: SortOrderInput | SortOrder
    paystackSubAccountId?: SortOrderInput | SortOrder
    paystackSubscriptionId?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    zip?: SortOrderInput | SortOrder
    onboardingCompleted?: SortOrder
    businessName?: SortOrderInput | SortOrder
    countryCode?: SortOrderInput | SortOrder
    numberOfProperties?: SortOrderInput | SortOrder
    numberOfUnits?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    addressLine1?: StringNullableWithAggregatesFilter<"User"> | string | null
    addressLine2?: StringNullableWithAggregatesFilter<"User"> | string | null
    city?: StringNullableWithAggregatesFilter<"User"> | string | null
    idNumber?: StringNullableWithAggregatesFilter<"User"> | string | null
    paystackSplitGroupId?: StringNullableWithAggregatesFilter<"User"> | string | null
    paystackSubAccountId?: StringNullableWithAggregatesFilter<"User"> | string | null
    paystackSubscriptionId?: StringNullableWithAggregatesFilter<"User"> | string | null
    state?: StringNullableWithAggregatesFilter<"User"> | string | null
    zip?: StringNullableWithAggregatesFilter<"User"> | string | null
    onboardingCompleted?: BoolWithAggregatesFilter<"User"> | boolean
    businessName?: StringNullableWithAggregatesFilter<"User"> | string | null
    countryCode?: StringNullableWithAggregatesFilter<"User"> | string | null
    numberOfProperties?: IntNullableWithAggregatesFilter<"User"> | number | null
    numberOfUnits?: IntNullableWithAggregatesFilter<"User"> | number | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    token?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    userId?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    token?: StringWithAggregatesFilter<"Session"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userId?: StringWithAggregatesFilter<"Session"> | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    accountId?: StringWithAggregatesFilter<"Account"> | string
    providerId?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    accessToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    idToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    password?: StringNullableWithAggregatesFilter<"Account"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type VerificationWhereInput = {
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    id?: StringFilter<"Verification"> | string
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeNullableFilter<"Verification"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Verification"> | Date | string | null
  }

  export type VerificationOrderByWithRelationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
  }

  export type VerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeNullableFilter<"Verification"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Verification"> | Date | string | null
  }, "id">

  export type VerificationOrderByWithAggregationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: VerificationCountOrderByAggregateInput
    _max?: VerificationMaxOrderByAggregateInput
    _min?: VerificationMinOrderByAggregateInput
  }

  export type VerificationScalarWhereWithAggregatesInput = {
    AND?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    OR?: VerificationScalarWhereWithAggregatesInput[]
    NOT?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Verification"> | string
    identifier?: StringWithAggregatesFilter<"Verification"> | string
    value?: StringWithAggregatesFilter<"Verification"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"Verification"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Verification"> | Date | string | null
  }

  export type TenantWhereInput = {
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    id?: StringFilter<"Tenant"> | string
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    email?: StringFilter<"Tenant"> | string
    firstName?: StringFilter<"Tenant"> | string
    lastName?: StringFilter<"Tenant"> | string
    phone?: StringFilter<"Tenant"> | string
    landlordId?: StringFilter<"Tenant"> | string
    dateOfBirth?: DateTimeNullableFilter<"Tenant"> | Date | string | null
    tenantEmergencyContact?: JsonNullableFilter<"Tenant">
    tenantIncome?: JsonNullableFilter<"Tenant">
    additionalEmails?: StringNullableListFilter<"Tenant">
    additionalPhones?: StringNullableListFilter<"Tenant">
    emergencyContacts?: JsonNullableFilter<"Tenant">
    vehicles?: JsonNullableFilter<"Tenant">
    avatarUrl?: StringNullableFilter<"Tenant"> | string | null
    fullName?: StringNullableFilter<"Tenant"> | string | null
    paystackCustomerId?: StringNullableFilter<"Tenant"> | string | null
    files?: FileListRelationFilter
    Invoice?: InvoiceListRelationFilter
    landlord?: XOR<UserScalarRelationFilter, UserWhereInput>
    tenantLease?: TenantLeaseListRelationFilter
    recurringBillable?: RecurringBillableListRelationFilter
  }

  export type TenantOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    landlordId?: SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    tenantEmergencyContact?: SortOrderInput | SortOrder
    tenantIncome?: SortOrderInput | SortOrder
    additionalEmails?: SortOrder
    additionalPhones?: SortOrder
    emergencyContacts?: SortOrderInput | SortOrder
    vehicles?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    fullName?: SortOrderInput | SortOrder
    paystackCustomerId?: SortOrderInput | SortOrder
    files?: FileOrderByRelationAggregateInput
    Invoice?: InvoiceOrderByRelationAggregateInput
    landlord?: UserOrderByWithRelationInput
    tenantLease?: TenantLeaseOrderByRelationAggregateInput
    recurringBillable?: RecurringBillableOrderByRelationAggregateInput
  }

  export type TenantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    email?: StringFilter<"Tenant"> | string
    firstName?: StringFilter<"Tenant"> | string
    lastName?: StringFilter<"Tenant"> | string
    phone?: StringFilter<"Tenant"> | string
    landlordId?: StringFilter<"Tenant"> | string
    dateOfBirth?: DateTimeNullableFilter<"Tenant"> | Date | string | null
    tenantEmergencyContact?: JsonNullableFilter<"Tenant">
    tenantIncome?: JsonNullableFilter<"Tenant">
    additionalEmails?: StringNullableListFilter<"Tenant">
    additionalPhones?: StringNullableListFilter<"Tenant">
    emergencyContacts?: JsonNullableFilter<"Tenant">
    vehicles?: JsonNullableFilter<"Tenant">
    avatarUrl?: StringNullableFilter<"Tenant"> | string | null
    fullName?: StringNullableFilter<"Tenant"> | string | null
    paystackCustomerId?: StringNullableFilter<"Tenant"> | string | null
    files?: FileListRelationFilter
    Invoice?: InvoiceListRelationFilter
    landlord?: XOR<UserScalarRelationFilter, UserWhereInput>
    tenantLease?: TenantLeaseListRelationFilter
    recurringBillable?: RecurringBillableListRelationFilter
  }, "id">

  export type TenantOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    landlordId?: SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    tenantEmergencyContact?: SortOrderInput | SortOrder
    tenantIncome?: SortOrderInput | SortOrder
    additionalEmails?: SortOrder
    additionalPhones?: SortOrder
    emergencyContacts?: SortOrderInput | SortOrder
    vehicles?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    fullName?: SortOrderInput | SortOrder
    paystackCustomerId?: SortOrderInput | SortOrder
    _count?: TenantCountOrderByAggregateInput
    _max?: TenantMaxOrderByAggregateInput
    _min?: TenantMinOrderByAggregateInput
  }

  export type TenantScalarWhereWithAggregatesInput = {
    AND?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    OR?: TenantScalarWhereWithAggregatesInput[]
    NOT?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tenant"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
    email?: StringWithAggregatesFilter<"Tenant"> | string
    firstName?: StringWithAggregatesFilter<"Tenant"> | string
    lastName?: StringWithAggregatesFilter<"Tenant"> | string
    phone?: StringWithAggregatesFilter<"Tenant"> | string
    landlordId?: StringWithAggregatesFilter<"Tenant"> | string
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"Tenant"> | Date | string | null
    tenantEmergencyContact?: JsonNullableWithAggregatesFilter<"Tenant">
    tenantIncome?: JsonNullableWithAggregatesFilter<"Tenant">
    additionalEmails?: StringNullableListFilter<"Tenant">
    additionalPhones?: StringNullableListFilter<"Tenant">
    emergencyContacts?: JsonNullableWithAggregatesFilter<"Tenant">
    vehicles?: JsonNullableWithAggregatesFilter<"Tenant">
    avatarUrl?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    fullName?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    paystackCustomerId?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
  }

  export type PropertyWhereInput = {
    AND?: PropertyWhereInput | PropertyWhereInput[]
    OR?: PropertyWhereInput[]
    NOT?: PropertyWhereInput | PropertyWhereInput[]
    id?: StringFilter<"Property"> | string
    name?: StringFilter<"Property"> | string
    addressLine1?: StringFilter<"Property"> | string
    addressLine2?: StringNullableFilter<"Property"> | string | null
    city?: StringFilter<"Property"> | string
    state?: StringFilter<"Property"> | string
    zip?: StringFilter<"Property"> | string
    createdAt?: DateTimeFilter<"Property"> | Date | string
    updatedAt?: DateTimeFilter<"Property"> | Date | string
    imageUrl?: StringNullableFilter<"Property"> | string | null
    propertyStatus?: EnumPropertyStatusFilter<"Property"> | $Enums.PropertyStatus
    propertyType?: EnumPropertyTypeFilter<"Property"> | $Enums.PropertyType
    amenities?: StringNullableListFilter<"Property">
    countryCode?: StringFilter<"Property"> | string
    features?: StringNullableListFilter<"Property">
    landlordId?: StringFilter<"Property"> | string
    files?: FileListRelationFilter
    landlord?: XOR<UserScalarRelationFilter, UserWhereInput>
    unit?: UnitListRelationFilter
    recurringBillable?: RecurringBillableListRelationFilter
  }

  export type PropertyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    propertyStatus?: SortOrder
    propertyType?: SortOrder
    amenities?: SortOrder
    countryCode?: SortOrder
    features?: SortOrder
    landlordId?: SortOrder
    files?: FileOrderByRelationAggregateInput
    landlord?: UserOrderByWithRelationInput
    unit?: UnitOrderByRelationAggregateInput
    recurringBillable?: RecurringBillableOrderByRelationAggregateInput
  }

  export type PropertyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PropertyWhereInput | PropertyWhereInput[]
    OR?: PropertyWhereInput[]
    NOT?: PropertyWhereInput | PropertyWhereInput[]
    name?: StringFilter<"Property"> | string
    addressLine1?: StringFilter<"Property"> | string
    addressLine2?: StringNullableFilter<"Property"> | string | null
    city?: StringFilter<"Property"> | string
    state?: StringFilter<"Property"> | string
    zip?: StringFilter<"Property"> | string
    createdAt?: DateTimeFilter<"Property"> | Date | string
    updatedAt?: DateTimeFilter<"Property"> | Date | string
    imageUrl?: StringNullableFilter<"Property"> | string | null
    propertyStatus?: EnumPropertyStatusFilter<"Property"> | $Enums.PropertyStatus
    propertyType?: EnumPropertyTypeFilter<"Property"> | $Enums.PropertyType
    amenities?: StringNullableListFilter<"Property">
    countryCode?: StringFilter<"Property"> | string
    features?: StringNullableListFilter<"Property">
    landlordId?: StringFilter<"Property"> | string
    files?: FileListRelationFilter
    landlord?: XOR<UserScalarRelationFilter, UserWhereInput>
    unit?: UnitListRelationFilter
    recurringBillable?: RecurringBillableListRelationFilter
  }, "id">

  export type PropertyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    propertyStatus?: SortOrder
    propertyType?: SortOrder
    amenities?: SortOrder
    countryCode?: SortOrder
    features?: SortOrder
    landlordId?: SortOrder
    _count?: PropertyCountOrderByAggregateInput
    _max?: PropertyMaxOrderByAggregateInput
    _min?: PropertyMinOrderByAggregateInput
  }

  export type PropertyScalarWhereWithAggregatesInput = {
    AND?: PropertyScalarWhereWithAggregatesInput | PropertyScalarWhereWithAggregatesInput[]
    OR?: PropertyScalarWhereWithAggregatesInput[]
    NOT?: PropertyScalarWhereWithAggregatesInput | PropertyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Property"> | string
    name?: StringWithAggregatesFilter<"Property"> | string
    addressLine1?: StringWithAggregatesFilter<"Property"> | string
    addressLine2?: StringNullableWithAggregatesFilter<"Property"> | string | null
    city?: StringWithAggregatesFilter<"Property"> | string
    state?: StringWithAggregatesFilter<"Property"> | string
    zip?: StringWithAggregatesFilter<"Property"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Property"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Property"> | Date | string
    imageUrl?: StringNullableWithAggregatesFilter<"Property"> | string | null
    propertyStatus?: EnumPropertyStatusWithAggregatesFilter<"Property"> | $Enums.PropertyStatus
    propertyType?: EnumPropertyTypeWithAggregatesFilter<"Property"> | $Enums.PropertyType
    amenities?: StringNullableListFilter<"Property">
    countryCode?: StringWithAggregatesFilter<"Property"> | string
    features?: StringNullableListFilter<"Property">
    landlordId?: StringWithAggregatesFilter<"Property"> | string
  }

  export type UnitWhereInput = {
    AND?: UnitWhereInput | UnitWhereInput[]
    OR?: UnitWhereInput[]
    NOT?: UnitWhereInput | UnitWhereInput[]
    id?: StringFilter<"Unit"> | string
    propertyId?: StringFilter<"Unit"> | string
    name?: StringFilter<"Unit"> | string
    createdAt?: DateTimeFilter<"Unit"> | Date | string
    updatedAt?: DateTimeFilter<"Unit"> | Date | string
    bathrooms?: FloatFilter<"Unit"> | number
    bedrooms?: IntFilter<"Unit"> | number
    deposit?: FloatFilter<"Unit"> | number
    marketRent?: FloatFilter<"Unit"> | number
    sqmt?: FloatFilter<"Unit"> | number
    lease?: LeaseListRelationFilter
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }

  export type UnitOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bathrooms?: SortOrder
    bedrooms?: SortOrder
    deposit?: SortOrder
    marketRent?: SortOrder
    sqmt?: SortOrder
    lease?: LeaseOrderByRelationAggregateInput
    property?: PropertyOrderByWithRelationInput
  }

  export type UnitWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UnitWhereInput | UnitWhereInput[]
    OR?: UnitWhereInput[]
    NOT?: UnitWhereInput | UnitWhereInput[]
    propertyId?: StringFilter<"Unit"> | string
    name?: StringFilter<"Unit"> | string
    createdAt?: DateTimeFilter<"Unit"> | Date | string
    updatedAt?: DateTimeFilter<"Unit"> | Date | string
    bathrooms?: FloatFilter<"Unit"> | number
    bedrooms?: IntFilter<"Unit"> | number
    deposit?: FloatFilter<"Unit"> | number
    marketRent?: FloatFilter<"Unit"> | number
    sqmt?: FloatFilter<"Unit"> | number
    lease?: LeaseListRelationFilter
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }, "id">

  export type UnitOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bathrooms?: SortOrder
    bedrooms?: SortOrder
    deposit?: SortOrder
    marketRent?: SortOrder
    sqmt?: SortOrder
    _count?: UnitCountOrderByAggregateInput
    _avg?: UnitAvgOrderByAggregateInput
    _max?: UnitMaxOrderByAggregateInput
    _min?: UnitMinOrderByAggregateInput
    _sum?: UnitSumOrderByAggregateInput
  }

  export type UnitScalarWhereWithAggregatesInput = {
    AND?: UnitScalarWhereWithAggregatesInput | UnitScalarWhereWithAggregatesInput[]
    OR?: UnitScalarWhereWithAggregatesInput[]
    NOT?: UnitScalarWhereWithAggregatesInput | UnitScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Unit"> | string
    propertyId?: StringWithAggregatesFilter<"Unit"> | string
    name?: StringWithAggregatesFilter<"Unit"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Unit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Unit"> | Date | string
    bathrooms?: FloatWithAggregatesFilter<"Unit"> | number
    bedrooms?: IntWithAggregatesFilter<"Unit"> | number
    deposit?: FloatWithAggregatesFilter<"Unit"> | number
    marketRent?: FloatWithAggregatesFilter<"Unit"> | number
    sqmt?: FloatWithAggregatesFilter<"Unit"> | number
  }

  export type LeaseWhereInput = {
    AND?: LeaseWhereInput | LeaseWhereInput[]
    OR?: LeaseWhereInput[]
    NOT?: LeaseWhereInput | LeaseWhereInput[]
    id?: StringFilter<"Lease"> | string
    startDate?: DateTimeFilter<"Lease"> | Date | string
    endDate?: DateTimeNullableFilter<"Lease"> | Date | string | null
    rent?: FloatFilter<"Lease"> | number
    deposit?: FloatFilter<"Lease"> | number
    status?: EnumLeaseStatusFilter<"Lease"> | $Enums.LeaseStatus
    createdAt?: DateTimeFilter<"Lease"> | Date | string
    updatedAt?: DateTimeFilter<"Lease"> | Date | string
    rentDueCurrency?: StringFilter<"Lease"> | string
    unitId?: StringNullableFilter<"Lease"> | string | null
    automaticInvoice?: BoolFilter<"Lease"> | boolean
    invoiceCycle?: EnumInvoiceCycleFilter<"Lease"> | $Enums.InvoiceCycle
    leaseType?: EnumLeaseTermTypeFilter<"Lease"> | $Enums.LeaseTermType
    File?: FileListRelationFilter
    invoice?: InvoiceListRelationFilter
    unit?: XOR<UnitNullableScalarRelationFilter, UnitWhereInput> | null
    maintenanceRequest?: MaintenanceRequestListRelationFilter
    tenantLease?: TenantLeaseListRelationFilter
    transactions?: TransactionsListRelationFilter
    recurringBillable?: RecurringBillableListRelationFilter
  }

  export type LeaseOrderByWithRelationInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    rent?: SortOrder
    deposit?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rentDueCurrency?: SortOrder
    unitId?: SortOrderInput | SortOrder
    automaticInvoice?: SortOrder
    invoiceCycle?: SortOrder
    leaseType?: SortOrder
    File?: FileOrderByRelationAggregateInput
    invoice?: InvoiceOrderByRelationAggregateInput
    unit?: UnitOrderByWithRelationInput
    maintenanceRequest?: MaintenanceRequestOrderByRelationAggregateInput
    tenantLease?: TenantLeaseOrderByRelationAggregateInput
    transactions?: TransactionsOrderByRelationAggregateInput
    recurringBillable?: RecurringBillableOrderByRelationAggregateInput
  }

  export type LeaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LeaseWhereInput | LeaseWhereInput[]
    OR?: LeaseWhereInput[]
    NOT?: LeaseWhereInput | LeaseWhereInput[]
    startDate?: DateTimeFilter<"Lease"> | Date | string
    endDate?: DateTimeNullableFilter<"Lease"> | Date | string | null
    rent?: FloatFilter<"Lease"> | number
    deposit?: FloatFilter<"Lease"> | number
    status?: EnumLeaseStatusFilter<"Lease"> | $Enums.LeaseStatus
    createdAt?: DateTimeFilter<"Lease"> | Date | string
    updatedAt?: DateTimeFilter<"Lease"> | Date | string
    rentDueCurrency?: StringFilter<"Lease"> | string
    unitId?: StringNullableFilter<"Lease"> | string | null
    automaticInvoice?: BoolFilter<"Lease"> | boolean
    invoiceCycle?: EnumInvoiceCycleFilter<"Lease"> | $Enums.InvoiceCycle
    leaseType?: EnumLeaseTermTypeFilter<"Lease"> | $Enums.LeaseTermType
    File?: FileListRelationFilter
    invoice?: InvoiceListRelationFilter
    unit?: XOR<UnitNullableScalarRelationFilter, UnitWhereInput> | null
    maintenanceRequest?: MaintenanceRequestListRelationFilter
    tenantLease?: TenantLeaseListRelationFilter
    transactions?: TransactionsListRelationFilter
    recurringBillable?: RecurringBillableListRelationFilter
  }, "id">

  export type LeaseOrderByWithAggregationInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    rent?: SortOrder
    deposit?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rentDueCurrency?: SortOrder
    unitId?: SortOrderInput | SortOrder
    automaticInvoice?: SortOrder
    invoiceCycle?: SortOrder
    leaseType?: SortOrder
    _count?: LeaseCountOrderByAggregateInput
    _avg?: LeaseAvgOrderByAggregateInput
    _max?: LeaseMaxOrderByAggregateInput
    _min?: LeaseMinOrderByAggregateInput
    _sum?: LeaseSumOrderByAggregateInput
  }

  export type LeaseScalarWhereWithAggregatesInput = {
    AND?: LeaseScalarWhereWithAggregatesInput | LeaseScalarWhereWithAggregatesInput[]
    OR?: LeaseScalarWhereWithAggregatesInput[]
    NOT?: LeaseScalarWhereWithAggregatesInput | LeaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lease"> | string
    startDate?: DateTimeWithAggregatesFilter<"Lease"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"Lease"> | Date | string | null
    rent?: FloatWithAggregatesFilter<"Lease"> | number
    deposit?: FloatWithAggregatesFilter<"Lease"> | number
    status?: EnumLeaseStatusWithAggregatesFilter<"Lease"> | $Enums.LeaseStatus
    createdAt?: DateTimeWithAggregatesFilter<"Lease"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Lease"> | Date | string
    rentDueCurrency?: StringWithAggregatesFilter<"Lease"> | string
    unitId?: StringNullableWithAggregatesFilter<"Lease"> | string | null
    automaticInvoice?: BoolWithAggregatesFilter<"Lease"> | boolean
    invoiceCycle?: EnumInvoiceCycleWithAggregatesFilter<"Lease"> | $Enums.InvoiceCycle
    leaseType?: EnumLeaseTermTypeWithAggregatesFilter<"Lease"> | $Enums.LeaseTermType
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: StringFilter<"Invoice"> | string
    leaseId?: StringNullableFilter<"Invoice"> | string | null
    description?: StringFilter<"Invoice"> | string
    dueAmount?: FloatFilter<"Invoice"> | number
    category?: EnumInvoiceCategoryFilter<"Invoice"> | $Enums.InvoiceCategory
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    paystackId?: StringFilter<"Invoice"> | string
    dueDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    lineItems?: JsonNullableFilter<"Invoice">
    landlordId?: StringFilter<"Invoice"> | string
    tenantId?: StringFilter<"Invoice"> | string
    recurringBillableId?: StringNullableFilter<"Invoice"> | string | null
    File?: FileListRelationFilter
    lease?: XOR<LeaseNullableScalarRelationFilter, LeaseWhereInput> | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    transactions?: TransactionsListRelationFilter
    recurringBillable?: XOR<RecurringBillableNullableScalarRelationFilter, RecurringBillableWhereInput> | null
    landlord?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    leaseId?: SortOrderInput | SortOrder
    description?: SortOrder
    dueAmount?: SortOrder
    category?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paystackId?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    lineItems?: SortOrderInput | SortOrder
    landlordId?: SortOrder
    tenantId?: SortOrder
    recurringBillableId?: SortOrderInput | SortOrder
    File?: FileOrderByRelationAggregateInput
    lease?: LeaseOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
    transactions?: TransactionsOrderByRelationAggregateInput
    recurringBillable?: RecurringBillableOrderByWithRelationInput
    landlord?: UserOrderByWithRelationInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    leaseId?: StringNullableFilter<"Invoice"> | string | null
    description?: StringFilter<"Invoice"> | string
    dueAmount?: FloatFilter<"Invoice"> | number
    category?: EnumInvoiceCategoryFilter<"Invoice"> | $Enums.InvoiceCategory
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    paystackId?: StringFilter<"Invoice"> | string
    dueDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    lineItems?: JsonNullableFilter<"Invoice">
    landlordId?: StringFilter<"Invoice"> | string
    tenantId?: StringFilter<"Invoice"> | string
    recurringBillableId?: StringNullableFilter<"Invoice"> | string | null
    File?: FileListRelationFilter
    lease?: XOR<LeaseNullableScalarRelationFilter, LeaseWhereInput> | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    transactions?: TransactionsListRelationFilter
    recurringBillable?: XOR<RecurringBillableNullableScalarRelationFilter, RecurringBillableWhereInput> | null
    landlord?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    leaseId?: SortOrderInput | SortOrder
    description?: SortOrder
    dueAmount?: SortOrder
    category?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paystackId?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    lineItems?: SortOrderInput | SortOrder
    landlordId?: SortOrder
    tenantId?: SortOrder
    recurringBillableId?: SortOrderInput | SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invoice"> | string
    leaseId?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    description?: StringWithAggregatesFilter<"Invoice"> | string
    dueAmount?: FloatWithAggregatesFilter<"Invoice"> | number
    category?: EnumInvoiceCategoryWithAggregatesFilter<"Invoice"> | $Enums.InvoiceCategory
    status?: EnumInvoiceStatusWithAggregatesFilter<"Invoice"> | $Enums.InvoiceStatus
    createdAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    paystackId?: StringWithAggregatesFilter<"Invoice"> | string
    dueDate?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    lineItems?: JsonNullableWithAggregatesFilter<"Invoice">
    landlordId?: StringWithAggregatesFilter<"Invoice"> | string
    tenantId?: StringWithAggregatesFilter<"Invoice"> | string
    recurringBillableId?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
  }

  export type RecurringBillableWhereInput = {
    AND?: RecurringBillableWhereInput | RecurringBillableWhereInput[]
    OR?: RecurringBillableWhereInput[]
    NOT?: RecurringBillableWhereInput | RecurringBillableWhereInput[]
    id?: StringFilter<"RecurringBillable"> | string
    startDate?: DateTimeFilter<"RecurringBillable"> | Date | string
    endDate?: DateTimeNullableFilter<"RecurringBillable"> | Date | string | null
    createdAt?: DateTimeFilter<"RecurringBillable"> | Date | string
    updatedAt?: DateTimeFilter<"RecurringBillable"> | Date | string
    description?: StringFilter<"RecurringBillable"> | string
    amount?: FloatFilter<"RecurringBillable"> | number
    category?: EnumInvoiceCategoryFilter<"RecurringBillable"> | $Enums.InvoiceCategory
    cycle?: EnumInvoiceCycleFilter<"RecurringBillable"> | $Enums.InvoiceCycle
    nextInvoiceAt?: DateTimeFilter<"RecurringBillable"> | Date | string
    isActive?: BoolFilter<"RecurringBillable"> | boolean
    leaseId?: StringNullableFilter<"RecurringBillable"> | string | null
    tenantId?: StringFilter<"RecurringBillable"> | string
    propertyId?: StringNullableFilter<"RecurringBillable"> | string | null
    lease?: XOR<LeaseNullableScalarRelationFilter, LeaseWhereInput> | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    invoice?: InvoiceListRelationFilter
    property?: XOR<PropertyNullableScalarRelationFilter, PropertyWhereInput> | null
  }

  export type RecurringBillableOrderByWithRelationInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    category?: SortOrder
    cycle?: SortOrder
    nextInvoiceAt?: SortOrder
    isActive?: SortOrder
    leaseId?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    propertyId?: SortOrderInput | SortOrder
    lease?: LeaseOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
    invoice?: InvoiceOrderByRelationAggregateInput
    property?: PropertyOrderByWithRelationInput
  }

  export type RecurringBillableWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RecurringBillableWhereInput | RecurringBillableWhereInput[]
    OR?: RecurringBillableWhereInput[]
    NOT?: RecurringBillableWhereInput | RecurringBillableWhereInput[]
    startDate?: DateTimeFilter<"RecurringBillable"> | Date | string
    endDate?: DateTimeNullableFilter<"RecurringBillable"> | Date | string | null
    createdAt?: DateTimeFilter<"RecurringBillable"> | Date | string
    updatedAt?: DateTimeFilter<"RecurringBillable"> | Date | string
    description?: StringFilter<"RecurringBillable"> | string
    amount?: FloatFilter<"RecurringBillable"> | number
    category?: EnumInvoiceCategoryFilter<"RecurringBillable"> | $Enums.InvoiceCategory
    cycle?: EnumInvoiceCycleFilter<"RecurringBillable"> | $Enums.InvoiceCycle
    nextInvoiceAt?: DateTimeFilter<"RecurringBillable"> | Date | string
    isActive?: BoolFilter<"RecurringBillable"> | boolean
    leaseId?: StringNullableFilter<"RecurringBillable"> | string | null
    tenantId?: StringFilter<"RecurringBillable"> | string
    propertyId?: StringNullableFilter<"RecurringBillable"> | string | null
    lease?: XOR<LeaseNullableScalarRelationFilter, LeaseWhereInput> | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    invoice?: InvoiceListRelationFilter
    property?: XOR<PropertyNullableScalarRelationFilter, PropertyWhereInput> | null
  }, "id">

  export type RecurringBillableOrderByWithAggregationInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    category?: SortOrder
    cycle?: SortOrder
    nextInvoiceAt?: SortOrder
    isActive?: SortOrder
    leaseId?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    propertyId?: SortOrderInput | SortOrder
    _count?: RecurringBillableCountOrderByAggregateInput
    _avg?: RecurringBillableAvgOrderByAggregateInput
    _max?: RecurringBillableMaxOrderByAggregateInput
    _min?: RecurringBillableMinOrderByAggregateInput
    _sum?: RecurringBillableSumOrderByAggregateInput
  }

  export type RecurringBillableScalarWhereWithAggregatesInput = {
    AND?: RecurringBillableScalarWhereWithAggregatesInput | RecurringBillableScalarWhereWithAggregatesInput[]
    OR?: RecurringBillableScalarWhereWithAggregatesInput[]
    NOT?: RecurringBillableScalarWhereWithAggregatesInput | RecurringBillableScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RecurringBillable"> | string
    startDate?: DateTimeWithAggregatesFilter<"RecurringBillable"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"RecurringBillable"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RecurringBillable"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RecurringBillable"> | Date | string
    description?: StringWithAggregatesFilter<"RecurringBillable"> | string
    amount?: FloatWithAggregatesFilter<"RecurringBillable"> | number
    category?: EnumInvoiceCategoryWithAggregatesFilter<"RecurringBillable"> | $Enums.InvoiceCategory
    cycle?: EnumInvoiceCycleWithAggregatesFilter<"RecurringBillable"> | $Enums.InvoiceCycle
    nextInvoiceAt?: DateTimeWithAggregatesFilter<"RecurringBillable"> | Date | string
    isActive?: BoolWithAggregatesFilter<"RecurringBillable"> | boolean
    leaseId?: StringNullableWithAggregatesFilter<"RecurringBillable"> | string | null
    tenantId?: StringWithAggregatesFilter<"RecurringBillable"> | string
    propertyId?: StringNullableWithAggregatesFilter<"RecurringBillable"> | string | null
  }

  export type TransactionsWhereInput = {
    AND?: TransactionsWhereInput | TransactionsWhereInput[]
    OR?: TransactionsWhereInput[]
    NOT?: TransactionsWhereInput | TransactionsWhereInput[]
    id?: StringFilter<"Transactions"> | string
    leaseId?: StringNullableFilter<"Transactions"> | string | null
    description?: StringFilter<"Transactions"> | string
    amountPaid?: FloatFilter<"Transactions"> | number
    referenceId?: StringNullableFilter<"Transactions"> | string | null
    createdAt?: DateTimeFilter<"Transactions"> | Date | string
    updatedAt?: DateTimeFilter<"Transactions"> | Date | string
    invoiceId?: StringNullableFilter<"Transactions"> | string | null
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
    lease?: XOR<LeaseNullableScalarRelationFilter, LeaseWhereInput> | null
  }

  export type TransactionsOrderByWithRelationInput = {
    id?: SortOrder
    leaseId?: SortOrderInput | SortOrder
    description?: SortOrder
    amountPaid?: SortOrder
    referenceId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invoiceId?: SortOrderInput | SortOrder
    invoice?: InvoiceOrderByWithRelationInput
    lease?: LeaseOrderByWithRelationInput
  }

  export type TransactionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransactionsWhereInput | TransactionsWhereInput[]
    OR?: TransactionsWhereInput[]
    NOT?: TransactionsWhereInput | TransactionsWhereInput[]
    leaseId?: StringNullableFilter<"Transactions"> | string | null
    description?: StringFilter<"Transactions"> | string
    amountPaid?: FloatFilter<"Transactions"> | number
    referenceId?: StringNullableFilter<"Transactions"> | string | null
    createdAt?: DateTimeFilter<"Transactions"> | Date | string
    updatedAt?: DateTimeFilter<"Transactions"> | Date | string
    invoiceId?: StringNullableFilter<"Transactions"> | string | null
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
    lease?: XOR<LeaseNullableScalarRelationFilter, LeaseWhereInput> | null
  }, "id">

  export type TransactionsOrderByWithAggregationInput = {
    id?: SortOrder
    leaseId?: SortOrderInput | SortOrder
    description?: SortOrder
    amountPaid?: SortOrder
    referenceId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invoiceId?: SortOrderInput | SortOrder
    _count?: TransactionsCountOrderByAggregateInput
    _avg?: TransactionsAvgOrderByAggregateInput
    _max?: TransactionsMaxOrderByAggregateInput
    _min?: TransactionsMinOrderByAggregateInput
    _sum?: TransactionsSumOrderByAggregateInput
  }

  export type TransactionsScalarWhereWithAggregatesInput = {
    AND?: TransactionsScalarWhereWithAggregatesInput | TransactionsScalarWhereWithAggregatesInput[]
    OR?: TransactionsScalarWhereWithAggregatesInput[]
    NOT?: TransactionsScalarWhereWithAggregatesInput | TransactionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transactions"> | string
    leaseId?: StringNullableWithAggregatesFilter<"Transactions"> | string | null
    description?: StringWithAggregatesFilter<"Transactions"> | string
    amountPaid?: FloatWithAggregatesFilter<"Transactions"> | number
    referenceId?: StringNullableWithAggregatesFilter<"Transactions"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Transactions"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Transactions"> | Date | string
    invoiceId?: StringNullableWithAggregatesFilter<"Transactions"> | string | null
  }

  export type TenantLeaseWhereInput = {
    AND?: TenantLeaseWhereInput | TenantLeaseWhereInput[]
    OR?: TenantLeaseWhereInput[]
    NOT?: TenantLeaseWhereInput | TenantLeaseWhereInput[]
    id?: StringFilter<"TenantLease"> | string
    tenantId?: StringFilter<"TenantLease"> | string
    leaseId?: StringFilter<"TenantLease"> | string
    lease?: XOR<LeaseScalarRelationFilter, LeaseWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type TenantLeaseOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    leaseId?: SortOrder
    lease?: LeaseOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
  }

  export type TenantLeaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TenantLeaseWhereInput | TenantLeaseWhereInput[]
    OR?: TenantLeaseWhereInput[]
    NOT?: TenantLeaseWhereInput | TenantLeaseWhereInput[]
    tenantId?: StringFilter<"TenantLease"> | string
    leaseId?: StringFilter<"TenantLease"> | string
    lease?: XOR<LeaseScalarRelationFilter, LeaseWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id">

  export type TenantLeaseOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    leaseId?: SortOrder
    _count?: TenantLeaseCountOrderByAggregateInput
    _max?: TenantLeaseMaxOrderByAggregateInput
    _min?: TenantLeaseMinOrderByAggregateInput
  }

  export type TenantLeaseScalarWhereWithAggregatesInput = {
    AND?: TenantLeaseScalarWhereWithAggregatesInput | TenantLeaseScalarWhereWithAggregatesInput[]
    OR?: TenantLeaseScalarWhereWithAggregatesInput[]
    NOT?: TenantLeaseScalarWhereWithAggregatesInput | TenantLeaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TenantLease"> | string
    tenantId?: StringWithAggregatesFilter<"TenantLease"> | string
    leaseId?: StringWithAggregatesFilter<"TenantLease"> | string
  }

  export type MaintenanceRequestWhereInput = {
    AND?: MaintenanceRequestWhereInput | MaintenanceRequestWhereInput[]
    OR?: MaintenanceRequestWhereInput[]
    NOT?: MaintenanceRequestWhereInput | MaintenanceRequestWhereInput[]
    id?: StringFilter<"MaintenanceRequest"> | string
    leaseId?: StringFilter<"MaintenanceRequest"> | string
    description?: StringNullableFilter<"MaintenanceRequest"> | string | null
    status?: EnumMaintenanceRequestStatusNullableFilter<"MaintenanceRequest"> | $Enums.MaintenanceRequestStatus | null
    priority?: EnumMaintenanceRequestPriorityFilter<"MaintenanceRequest"> | $Enums.MaintenanceRequestPriority
    createdAt?: DateTimeFilter<"MaintenanceRequest"> | Date | string
    updatedAt?: DateTimeFilter<"MaintenanceRequest"> | Date | string
    File?: FileListRelationFilter
    lease?: XOR<LeaseScalarRelationFilter, LeaseWhereInput>
  }

  export type MaintenanceRequestOrderByWithRelationInput = {
    id?: SortOrder
    leaseId?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    File?: FileOrderByRelationAggregateInput
    lease?: LeaseOrderByWithRelationInput
  }

  export type MaintenanceRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MaintenanceRequestWhereInput | MaintenanceRequestWhereInput[]
    OR?: MaintenanceRequestWhereInput[]
    NOT?: MaintenanceRequestWhereInput | MaintenanceRequestWhereInput[]
    leaseId?: StringFilter<"MaintenanceRequest"> | string
    description?: StringNullableFilter<"MaintenanceRequest"> | string | null
    status?: EnumMaintenanceRequestStatusNullableFilter<"MaintenanceRequest"> | $Enums.MaintenanceRequestStatus | null
    priority?: EnumMaintenanceRequestPriorityFilter<"MaintenanceRequest"> | $Enums.MaintenanceRequestPriority
    createdAt?: DateTimeFilter<"MaintenanceRequest"> | Date | string
    updatedAt?: DateTimeFilter<"MaintenanceRequest"> | Date | string
    File?: FileListRelationFilter
    lease?: XOR<LeaseScalarRelationFilter, LeaseWhereInput>
  }, "id">

  export type MaintenanceRequestOrderByWithAggregationInput = {
    id?: SortOrder
    leaseId?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MaintenanceRequestCountOrderByAggregateInput
    _max?: MaintenanceRequestMaxOrderByAggregateInput
    _min?: MaintenanceRequestMinOrderByAggregateInput
  }

  export type MaintenanceRequestScalarWhereWithAggregatesInput = {
    AND?: MaintenanceRequestScalarWhereWithAggregatesInput | MaintenanceRequestScalarWhereWithAggregatesInput[]
    OR?: MaintenanceRequestScalarWhereWithAggregatesInput[]
    NOT?: MaintenanceRequestScalarWhereWithAggregatesInput | MaintenanceRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MaintenanceRequest"> | string
    leaseId?: StringWithAggregatesFilter<"MaintenanceRequest"> | string
    description?: StringNullableWithAggregatesFilter<"MaintenanceRequest"> | string | null
    status?: EnumMaintenanceRequestStatusNullableWithAggregatesFilter<"MaintenanceRequest"> | $Enums.MaintenanceRequestStatus | null
    priority?: EnumMaintenanceRequestPriorityWithAggregatesFilter<"MaintenanceRequest"> | $Enums.MaintenanceRequestPriority
    createdAt?: DateTimeWithAggregatesFilter<"MaintenanceRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MaintenanceRequest"> | Date | string
  }

  export type FileWhereInput = {
    AND?: FileWhereInput | FileWhereInput[]
    OR?: FileWhereInput[]
    NOT?: FileWhereInput | FileWhereInput[]
    id?: StringFilter<"File"> | string
    name?: StringFilter<"File"> | string
    url?: StringFilter<"File"> | string
    ownerId?: StringFilter<"File"> | string
    tenantId?: StringNullableFilter<"File"> | string | null
    propertyId?: StringNullableFilter<"File"> | string | null
    leaseId?: StringNullableFilter<"File"> | string | null
    invoiceId?: StringNullableFilter<"File"> | string | null
    maintenanceRequestId?: StringNullableFilter<"File"> | string | null
    createdAt?: DateTimeFilter<"File"> | Date | string
    updatedAt?: DateTimeFilter<"File"> | Date | string
    size?: IntNullableFilter<"File"> | number | null
    type?: StringNullableFilter<"File"> | string | null
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
    lease?: XOR<LeaseNullableScalarRelationFilter, LeaseWhereInput> | null
    maintenanceRequest?: XOR<MaintenanceRequestNullableScalarRelationFilter, MaintenanceRequestWhereInput> | null
    property?: XOR<PropertyNullableScalarRelationFilter, PropertyWhereInput> | null
    tenant?: XOR<TenantNullableScalarRelationFilter, TenantWhereInput> | null
  }

  export type FileOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    ownerId?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    propertyId?: SortOrderInput | SortOrder
    leaseId?: SortOrderInput | SortOrder
    invoiceId?: SortOrderInput | SortOrder
    maintenanceRequestId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    size?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    invoice?: InvoiceOrderByWithRelationInput
    lease?: LeaseOrderByWithRelationInput
    maintenanceRequest?: MaintenanceRequestOrderByWithRelationInput
    property?: PropertyOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
  }

  export type FileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FileWhereInput | FileWhereInput[]
    OR?: FileWhereInput[]
    NOT?: FileWhereInput | FileWhereInput[]
    name?: StringFilter<"File"> | string
    url?: StringFilter<"File"> | string
    ownerId?: StringFilter<"File"> | string
    tenantId?: StringNullableFilter<"File"> | string | null
    propertyId?: StringNullableFilter<"File"> | string | null
    leaseId?: StringNullableFilter<"File"> | string | null
    invoiceId?: StringNullableFilter<"File"> | string | null
    maintenanceRequestId?: StringNullableFilter<"File"> | string | null
    createdAt?: DateTimeFilter<"File"> | Date | string
    updatedAt?: DateTimeFilter<"File"> | Date | string
    size?: IntNullableFilter<"File"> | number | null
    type?: StringNullableFilter<"File"> | string | null
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
    lease?: XOR<LeaseNullableScalarRelationFilter, LeaseWhereInput> | null
    maintenanceRequest?: XOR<MaintenanceRequestNullableScalarRelationFilter, MaintenanceRequestWhereInput> | null
    property?: XOR<PropertyNullableScalarRelationFilter, PropertyWhereInput> | null
    tenant?: XOR<TenantNullableScalarRelationFilter, TenantWhereInput> | null
  }, "id">

  export type FileOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    ownerId?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    propertyId?: SortOrderInput | SortOrder
    leaseId?: SortOrderInput | SortOrder
    invoiceId?: SortOrderInput | SortOrder
    maintenanceRequestId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    size?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    _count?: FileCountOrderByAggregateInput
    _avg?: FileAvgOrderByAggregateInput
    _max?: FileMaxOrderByAggregateInput
    _min?: FileMinOrderByAggregateInput
    _sum?: FileSumOrderByAggregateInput
  }

  export type FileScalarWhereWithAggregatesInput = {
    AND?: FileScalarWhereWithAggregatesInput | FileScalarWhereWithAggregatesInput[]
    OR?: FileScalarWhereWithAggregatesInput[]
    NOT?: FileScalarWhereWithAggregatesInput | FileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"File"> | string
    name?: StringWithAggregatesFilter<"File"> | string
    url?: StringWithAggregatesFilter<"File"> | string
    ownerId?: StringWithAggregatesFilter<"File"> | string
    tenantId?: StringNullableWithAggregatesFilter<"File"> | string | null
    propertyId?: StringNullableWithAggregatesFilter<"File"> | string | null
    leaseId?: StringNullableWithAggregatesFilter<"File"> | string | null
    invoiceId?: StringNullableWithAggregatesFilter<"File"> | string | null
    maintenanceRequestId?: StringNullableWithAggregatesFilter<"File"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"File"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"File"> | Date | string
    size?: IntNullableWithAggregatesFilter<"File"> | number | null
    type?: StringNullableWithAggregatesFilter<"File"> | string | null
  }

  export type UserCreateInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    idNumber?: string | null
    paystackSplitGroupId?: string | null
    paystackSubAccountId?: string | null
    paystackSubscriptionId?: string | null
    state?: string | null
    zip?: string | null
    onboardingCompleted?: boolean
    businessName?: string | null
    countryCode?: string | null
    numberOfProperties?: number | null
    numberOfUnits?: number | null
    phone?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    property?: PropertyCreateNestedManyWithoutLandlordInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    tenant?: TenantCreateNestedManyWithoutLandlordInput
    Invoice?: InvoiceCreateNestedManyWithoutLandlordInput
  }

  export type UserUncheckedCreateInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    idNumber?: string | null
    paystackSplitGroupId?: string | null
    paystackSubAccountId?: string | null
    paystackSubscriptionId?: string | null
    state?: string | null
    zip?: string | null
    onboardingCompleted?: boolean
    businessName?: string | null
    countryCode?: string | null
    numberOfProperties?: number | null
    numberOfUnits?: number | null
    phone?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    property?: PropertyUncheckedCreateNestedManyWithoutLandlordInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    tenant?: TenantUncheckedCreateNestedManyWithoutLandlordInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutLandlordInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSplitGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfProperties?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfUnits?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    property?: PropertyUpdateManyWithoutLandlordNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    tenant?: TenantUpdateManyWithoutLandlordNestedInput
    Invoice?: InvoiceUpdateManyWithoutLandlordNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSplitGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfProperties?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfUnits?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    property?: PropertyUncheckedUpdateManyWithoutLandlordNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    tenant?: TenantUncheckedUpdateManyWithoutLandlordNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutLandlordNestedInput
  }

  export type UserCreateManyInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    idNumber?: string | null
    paystackSplitGroupId?: string | null
    paystackSubAccountId?: string | null
    paystackSubscriptionId?: string | null
    state?: string | null
    zip?: string | null
    onboardingCompleted?: boolean
    businessName?: string | null
    countryCode?: string | null
    numberOfProperties?: number | null
    numberOfUnits?: number | null
    phone?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSplitGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfProperties?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfUnits?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSplitGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfProperties?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfUnits?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    userId: string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type SessionCreateManyInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    userId: string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type AccountCreateInput = {
    id: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id: string
    accountId: string
    providerId: string
    userId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyInput = {
    id: string
    accountId: string
    providerId: string
    userId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateInput = {
    id: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type VerificationUncheckedCreateInput = {
    id: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type VerificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VerificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VerificationCreateManyInput = {
    id: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type VerificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VerificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TenantCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    firstName: string
    lastName: string
    phone: string
    dateOfBirth?: Date | string | null
    tenantEmergencyContact?: NullableJsonNullValueInput | InputJsonValue
    tenantIncome?: NullableJsonNullValueInput | InputJsonValue
    additionalEmails?: TenantCreateadditionalEmailsInput | string[]
    additionalPhones?: TenantCreateadditionalPhonesInput | string[]
    emergencyContacts?: NullableJsonNullValueInput | InputJsonValue
    vehicles?: NullableJsonNullValueInput | InputJsonValue
    avatarUrl?: string | null
    fullName?: string | null
    paystackCustomerId?: string | null
    files?: FileCreateNestedManyWithoutTenantInput
    Invoice?: InvoiceCreateNestedManyWithoutTenantInput
    landlord: UserCreateNestedOneWithoutTenantInput
    tenantLease?: TenantLeaseCreateNestedManyWithoutTenantInput
    recurringBillable?: RecurringBillableCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    firstName: string
    lastName: string
    phone: string
    landlordId: string
    dateOfBirth?: Date | string | null
    tenantEmergencyContact?: NullableJsonNullValueInput | InputJsonValue
    tenantIncome?: NullableJsonNullValueInput | InputJsonValue
    additionalEmails?: TenantCreateadditionalEmailsInput | string[]
    additionalPhones?: TenantCreateadditionalPhonesInput | string[]
    emergencyContacts?: NullableJsonNullValueInput | InputJsonValue
    vehicles?: NullableJsonNullValueInput | InputJsonValue
    avatarUrl?: string | null
    fullName?: string | null
    paystackCustomerId?: string | null
    files?: FileUncheckedCreateNestedManyWithoutTenantInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    tenantLease?: TenantLeaseUncheckedCreateNestedManyWithoutTenantInput
    recurringBillable?: RecurringBillableUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantEmergencyContact?: NullableJsonNullValueInput | InputJsonValue
    tenantIncome?: NullableJsonNullValueInput | InputJsonValue
    additionalEmails?: TenantUpdateadditionalEmailsInput | string[]
    additionalPhones?: TenantUpdateadditionalPhonesInput | string[]
    emergencyContacts?: NullableJsonNullValueInput | InputJsonValue
    vehicles?: NullableJsonNullValueInput | InputJsonValue
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    paystackCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    files?: FileUpdateManyWithoutTenantNestedInput
    Invoice?: InvoiceUpdateManyWithoutTenantNestedInput
    landlord?: UserUpdateOneRequiredWithoutTenantNestedInput
    tenantLease?: TenantLeaseUpdateManyWithoutTenantNestedInput
    recurringBillable?: RecurringBillableUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    landlordId?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantEmergencyContact?: NullableJsonNullValueInput | InputJsonValue
    tenantIncome?: NullableJsonNullValueInput | InputJsonValue
    additionalEmails?: TenantUpdateadditionalEmailsInput | string[]
    additionalPhones?: TenantUpdateadditionalPhonesInput | string[]
    emergencyContacts?: NullableJsonNullValueInput | InputJsonValue
    vehicles?: NullableJsonNullValueInput | InputJsonValue
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    paystackCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    files?: FileUncheckedUpdateManyWithoutTenantNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    tenantLease?: TenantLeaseUncheckedUpdateManyWithoutTenantNestedInput
    recurringBillable?: RecurringBillableUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    firstName: string
    lastName: string
    phone: string
    landlordId: string
    dateOfBirth?: Date | string | null
    tenantEmergencyContact?: NullableJsonNullValueInput | InputJsonValue
    tenantIncome?: NullableJsonNullValueInput | InputJsonValue
    additionalEmails?: TenantCreateadditionalEmailsInput | string[]
    additionalPhones?: TenantCreateadditionalPhonesInput | string[]
    emergencyContacts?: NullableJsonNullValueInput | InputJsonValue
    vehicles?: NullableJsonNullValueInput | InputJsonValue
    avatarUrl?: string | null
    fullName?: string | null
    paystackCustomerId?: string | null
  }

  export type TenantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantEmergencyContact?: NullableJsonNullValueInput | InputJsonValue
    tenantIncome?: NullableJsonNullValueInput | InputJsonValue
    additionalEmails?: TenantUpdateadditionalEmailsInput | string[]
    additionalPhones?: TenantUpdateadditionalPhonesInput | string[]
    emergencyContacts?: NullableJsonNullValueInput | InputJsonValue
    vehicles?: NullableJsonNullValueInput | InputJsonValue
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    paystackCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TenantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    landlordId?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantEmergencyContact?: NullableJsonNullValueInput | InputJsonValue
    tenantIncome?: NullableJsonNullValueInput | InputJsonValue
    additionalEmails?: TenantUpdateadditionalEmailsInput | string[]
    additionalPhones?: TenantUpdateadditionalPhonesInput | string[]
    emergencyContacts?: NullableJsonNullValueInput | InputJsonValue
    vehicles?: NullableJsonNullValueInput | InputJsonValue
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    paystackCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertyCreateInput = {
    id?: string
    name: string
    addressLine1: string
    addressLine2?: string | null
    city: string
    state: string
    zip: string
    createdAt?: Date | string
    updatedAt?: Date | string
    imageUrl?: string | null
    propertyStatus?: $Enums.PropertyStatus
    propertyType?: $Enums.PropertyType
    amenities?: PropertyCreateamenitiesInput | string[]
    countryCode?: string
    features?: PropertyCreatefeaturesInput | string[]
    files?: FileCreateNestedManyWithoutPropertyInput
    landlord: UserCreateNestedOneWithoutPropertyInput
    unit?: UnitCreateNestedManyWithoutPropertyInput
    recurringBillable?: RecurringBillableCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateInput = {
    id?: string
    name: string
    addressLine1: string
    addressLine2?: string | null
    city: string
    state: string
    zip: string
    createdAt?: Date | string
    updatedAt?: Date | string
    imageUrl?: string | null
    propertyStatus?: $Enums.PropertyStatus
    propertyType?: $Enums.PropertyType
    amenities?: PropertyCreateamenitiesInput | string[]
    countryCode?: string
    features?: PropertyCreatefeaturesInput | string[]
    landlordId: string
    files?: FileUncheckedCreateNestedManyWithoutPropertyInput
    unit?: UnitUncheckedCreateNestedManyWithoutPropertyInput
    recurringBillable?: RecurringBillableUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    propertyStatus?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    amenities?: PropertyUpdateamenitiesInput | string[]
    countryCode?: StringFieldUpdateOperationsInput | string
    features?: PropertyUpdatefeaturesInput | string[]
    files?: FileUpdateManyWithoutPropertyNestedInput
    landlord?: UserUpdateOneRequiredWithoutPropertyNestedInput
    unit?: UnitUpdateManyWithoutPropertyNestedInput
    recurringBillable?: RecurringBillableUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    propertyStatus?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    amenities?: PropertyUpdateamenitiesInput | string[]
    countryCode?: StringFieldUpdateOperationsInput | string
    features?: PropertyUpdatefeaturesInput | string[]
    landlordId?: StringFieldUpdateOperationsInput | string
    files?: FileUncheckedUpdateManyWithoutPropertyNestedInput
    unit?: UnitUncheckedUpdateManyWithoutPropertyNestedInput
    recurringBillable?: RecurringBillableUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyCreateManyInput = {
    id?: string
    name: string
    addressLine1: string
    addressLine2?: string | null
    city: string
    state: string
    zip: string
    createdAt?: Date | string
    updatedAt?: Date | string
    imageUrl?: string | null
    propertyStatus?: $Enums.PropertyStatus
    propertyType?: $Enums.PropertyType
    amenities?: PropertyCreateamenitiesInput | string[]
    countryCode?: string
    features?: PropertyCreatefeaturesInput | string[]
    landlordId: string
  }

  export type PropertyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    propertyStatus?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    amenities?: PropertyUpdateamenitiesInput | string[]
    countryCode?: StringFieldUpdateOperationsInput | string
    features?: PropertyUpdatefeaturesInput | string[]
  }

  export type PropertyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    propertyStatus?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    amenities?: PropertyUpdateamenitiesInput | string[]
    countryCode?: StringFieldUpdateOperationsInput | string
    features?: PropertyUpdatefeaturesInput | string[]
    landlordId?: StringFieldUpdateOperationsInput | string
  }

  export type UnitCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bathrooms?: number
    bedrooms?: number
    deposit?: number
    marketRent?: number
    sqmt?: number
    lease?: LeaseCreateNestedManyWithoutUnitInput
    property: PropertyCreateNestedOneWithoutUnitInput
  }

  export type UnitUncheckedCreateInput = {
    id?: string
    propertyId: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bathrooms?: number
    bedrooms?: number
    deposit?: number
    marketRent?: number
    sqmt?: number
    lease?: LeaseUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bathrooms?: FloatFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    marketRent?: FloatFieldUpdateOperationsInput | number
    sqmt?: FloatFieldUpdateOperationsInput | number
    lease?: LeaseUpdateManyWithoutUnitNestedInput
    property?: PropertyUpdateOneRequiredWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bathrooms?: FloatFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    marketRent?: FloatFieldUpdateOperationsInput | number
    sqmt?: FloatFieldUpdateOperationsInput | number
    lease?: LeaseUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitCreateManyInput = {
    id?: string
    propertyId: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bathrooms?: number
    bedrooms?: number
    deposit?: number
    marketRent?: number
    sqmt?: number
  }

  export type UnitUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bathrooms?: FloatFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    marketRent?: FloatFieldUpdateOperationsInput | number
    sqmt?: FloatFieldUpdateOperationsInput | number
  }

  export type UnitUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bathrooms?: FloatFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    marketRent?: FloatFieldUpdateOperationsInput | number
    sqmt?: FloatFieldUpdateOperationsInput | number
  }

  export type LeaseCreateInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    rent: number
    deposit: number
    status: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    rentDueCurrency: string
    automaticInvoice?: boolean
    invoiceCycle?: $Enums.InvoiceCycle
    leaseType: $Enums.LeaseTermType
    File?: FileCreateNestedManyWithoutLeaseInput
    invoice?: InvoiceCreateNestedManyWithoutLeaseInput
    unit?: UnitCreateNestedOneWithoutLeaseInput
    maintenanceRequest?: MaintenanceRequestCreateNestedManyWithoutLeaseInput
    tenantLease?: TenantLeaseCreateNestedManyWithoutLeaseInput
    transactions?: TransactionsCreateNestedManyWithoutLeaseInput
    recurringBillable?: RecurringBillableCreateNestedManyWithoutLeaseInput
  }

  export type LeaseUncheckedCreateInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    rent: number
    deposit: number
    status: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    rentDueCurrency: string
    unitId?: string | null
    automaticInvoice?: boolean
    invoiceCycle?: $Enums.InvoiceCycle
    leaseType: $Enums.LeaseTermType
    File?: FileUncheckedCreateNestedManyWithoutLeaseInput
    invoice?: InvoiceUncheckedCreateNestedManyWithoutLeaseInput
    maintenanceRequest?: MaintenanceRequestUncheckedCreateNestedManyWithoutLeaseInput
    tenantLease?: TenantLeaseUncheckedCreateNestedManyWithoutLeaseInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutLeaseInput
    recurringBillable?: RecurringBillableUncheckedCreateNestedManyWithoutLeaseInput
  }

  export type LeaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rentDueCurrency?: StringFieldUpdateOperationsInput | string
    automaticInvoice?: BoolFieldUpdateOperationsInput | boolean
    invoiceCycle?: EnumInvoiceCycleFieldUpdateOperationsInput | $Enums.InvoiceCycle
    leaseType?: EnumLeaseTermTypeFieldUpdateOperationsInput | $Enums.LeaseTermType
    File?: FileUpdateManyWithoutLeaseNestedInput
    invoice?: InvoiceUpdateManyWithoutLeaseNestedInput
    unit?: UnitUpdateOneWithoutLeaseNestedInput
    maintenanceRequest?: MaintenanceRequestUpdateManyWithoutLeaseNestedInput
    tenantLease?: TenantLeaseUpdateManyWithoutLeaseNestedInput
    transactions?: TransactionsUpdateManyWithoutLeaseNestedInput
    recurringBillable?: RecurringBillableUpdateManyWithoutLeaseNestedInput
  }

  export type LeaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rentDueCurrency?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    automaticInvoice?: BoolFieldUpdateOperationsInput | boolean
    invoiceCycle?: EnumInvoiceCycleFieldUpdateOperationsInput | $Enums.InvoiceCycle
    leaseType?: EnumLeaseTermTypeFieldUpdateOperationsInput | $Enums.LeaseTermType
    File?: FileUncheckedUpdateManyWithoutLeaseNestedInput
    invoice?: InvoiceUncheckedUpdateManyWithoutLeaseNestedInput
    maintenanceRequest?: MaintenanceRequestUncheckedUpdateManyWithoutLeaseNestedInput
    tenantLease?: TenantLeaseUncheckedUpdateManyWithoutLeaseNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutLeaseNestedInput
    recurringBillable?: RecurringBillableUncheckedUpdateManyWithoutLeaseNestedInput
  }

  export type LeaseCreateManyInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    rent: number
    deposit: number
    status: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    rentDueCurrency: string
    unitId?: string | null
    automaticInvoice?: boolean
    invoiceCycle?: $Enums.InvoiceCycle
    leaseType: $Enums.LeaseTermType
  }

  export type LeaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rentDueCurrency?: StringFieldUpdateOperationsInput | string
    automaticInvoice?: BoolFieldUpdateOperationsInput | boolean
    invoiceCycle?: EnumInvoiceCycleFieldUpdateOperationsInput | $Enums.InvoiceCycle
    leaseType?: EnumLeaseTermTypeFieldUpdateOperationsInput | $Enums.LeaseTermType
  }

  export type LeaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rentDueCurrency?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    automaticInvoice?: BoolFieldUpdateOperationsInput | boolean
    invoiceCycle?: EnumInvoiceCycleFieldUpdateOperationsInput | $Enums.InvoiceCycle
    leaseType?: EnumLeaseTermTypeFieldUpdateOperationsInput | $Enums.LeaseTermType
  }

  export type InvoiceCreateInput = {
    id?: string
    description: string
    dueAmount: number
    category: $Enums.InvoiceCategory
    status: $Enums.InvoiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paystackId: string
    dueDate?: Date | string | null
    lineItems?: NullableJsonNullValueInput | InputJsonValue
    File?: FileCreateNestedManyWithoutInvoiceInput
    lease?: LeaseCreateNestedOneWithoutInvoiceInput
    tenant: TenantCreateNestedOneWithoutInvoiceInput
    transactions?: TransactionsCreateNestedManyWithoutInvoiceInput
    recurringBillable?: RecurringBillableCreateNestedOneWithoutInvoiceInput
    landlord: UserCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    leaseId?: string | null
    description: string
    dueAmount: number
    category: $Enums.InvoiceCategory
    status: $Enums.InvoiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paystackId: string
    dueDate?: Date | string | null
    lineItems?: NullableJsonNullValueInput | InputJsonValue
    landlordId: string
    tenantId: string
    recurringBillableId?: string | null
    File?: FileUncheckedCreateNestedManyWithoutInvoiceInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dueAmount?: FloatFieldUpdateOperationsInput | number
    category?: EnumInvoiceCategoryFieldUpdateOperationsInput | $Enums.InvoiceCategory
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paystackId?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lineItems?: NullableJsonNullValueInput | InputJsonValue
    File?: FileUpdateManyWithoutInvoiceNestedInput
    lease?: LeaseUpdateOneWithoutInvoiceNestedInput
    tenant?: TenantUpdateOneRequiredWithoutInvoiceNestedInput
    transactions?: TransactionsUpdateManyWithoutInvoiceNestedInput
    recurringBillable?: RecurringBillableUpdateOneWithoutInvoiceNestedInput
    landlord?: UserUpdateOneRequiredWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaseId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    dueAmount?: FloatFieldUpdateOperationsInput | number
    category?: EnumInvoiceCategoryFieldUpdateOperationsInput | $Enums.InvoiceCategory
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paystackId?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lineItems?: NullableJsonNullValueInput | InputJsonValue
    landlordId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    recurringBillableId?: NullableStringFieldUpdateOperationsInput | string | null
    File?: FileUncheckedUpdateManyWithoutInvoiceNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateManyInput = {
    id?: string
    leaseId?: string | null
    description: string
    dueAmount: number
    category: $Enums.InvoiceCategory
    status: $Enums.InvoiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paystackId: string
    dueDate?: Date | string | null
    lineItems?: NullableJsonNullValueInput | InputJsonValue
    landlordId: string
    tenantId: string
    recurringBillableId?: string | null
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dueAmount?: FloatFieldUpdateOperationsInput | number
    category?: EnumInvoiceCategoryFieldUpdateOperationsInput | $Enums.InvoiceCategory
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paystackId?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lineItems?: NullableJsonNullValueInput | InputJsonValue
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaseId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    dueAmount?: FloatFieldUpdateOperationsInput | number
    category?: EnumInvoiceCategoryFieldUpdateOperationsInput | $Enums.InvoiceCategory
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paystackId?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lineItems?: NullableJsonNullValueInput | InputJsonValue
    landlordId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    recurringBillableId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecurringBillableCreateInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    amount: number
    category: $Enums.InvoiceCategory
    cycle?: $Enums.InvoiceCycle
    nextInvoiceAt: Date | string
    isActive?: boolean
    lease?: LeaseCreateNestedOneWithoutRecurringBillableInput
    tenant: TenantCreateNestedOneWithoutRecurringBillableInput
    invoice?: InvoiceCreateNestedManyWithoutRecurringBillableInput
    property?: PropertyCreateNestedOneWithoutRecurringBillableInput
  }

  export type RecurringBillableUncheckedCreateInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    amount: number
    category: $Enums.InvoiceCategory
    cycle?: $Enums.InvoiceCycle
    nextInvoiceAt: Date | string
    isActive?: boolean
    leaseId?: string | null
    tenantId: string
    propertyId?: string | null
    invoice?: InvoiceUncheckedCreateNestedManyWithoutRecurringBillableInput
  }

  export type RecurringBillableUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    category?: EnumInvoiceCategoryFieldUpdateOperationsInput | $Enums.InvoiceCategory
    cycle?: EnumInvoiceCycleFieldUpdateOperationsInput | $Enums.InvoiceCycle
    nextInvoiceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lease?: LeaseUpdateOneWithoutRecurringBillableNestedInput
    tenant?: TenantUpdateOneRequiredWithoutRecurringBillableNestedInput
    invoice?: InvoiceUpdateManyWithoutRecurringBillableNestedInput
    property?: PropertyUpdateOneWithoutRecurringBillableNestedInput
  }

  export type RecurringBillableUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    category?: EnumInvoiceCategoryFieldUpdateOperationsInput | $Enums.InvoiceCategory
    cycle?: EnumInvoiceCycleFieldUpdateOperationsInput | $Enums.InvoiceCycle
    nextInvoiceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    leaseId?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: InvoiceUncheckedUpdateManyWithoutRecurringBillableNestedInput
  }

  export type RecurringBillableCreateManyInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    amount: number
    category: $Enums.InvoiceCategory
    cycle?: $Enums.InvoiceCycle
    nextInvoiceAt: Date | string
    isActive?: boolean
    leaseId?: string | null
    tenantId: string
    propertyId?: string | null
  }

  export type RecurringBillableUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    category?: EnumInvoiceCategoryFieldUpdateOperationsInput | $Enums.InvoiceCategory
    cycle?: EnumInvoiceCycleFieldUpdateOperationsInput | $Enums.InvoiceCycle
    nextInvoiceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RecurringBillableUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    category?: EnumInvoiceCategoryFieldUpdateOperationsInput | $Enums.InvoiceCategory
    cycle?: EnumInvoiceCycleFieldUpdateOperationsInput | $Enums.InvoiceCycle
    nextInvoiceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    leaseId?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionsCreateInput = {
    id?: string
    description: string
    amountPaid: number
    referenceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice?: InvoiceCreateNestedOneWithoutTransactionsInput
    lease?: LeaseCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionsUncheckedCreateInput = {
    id?: string
    leaseId?: string | null
    description: string
    amountPaid: number
    referenceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceId?: string | null
  }

  export type TransactionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneWithoutTransactionsNestedInput
    lease?: LeaseUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaseId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionsCreateManyInput = {
    id?: string
    leaseId?: string | null
    description: string
    amountPaid: number
    referenceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceId?: string | null
  }

  export type TransactionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaseId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TenantLeaseCreateInput = {
    id?: string
    lease: LeaseCreateNestedOneWithoutTenantLeaseInput
    tenant: TenantCreateNestedOneWithoutTenantLeaseInput
  }

  export type TenantLeaseUncheckedCreateInput = {
    id?: string
    tenantId: string
    leaseId: string
  }

  export type TenantLeaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lease?: LeaseUpdateOneRequiredWithoutTenantLeaseNestedInput
    tenant?: TenantUpdateOneRequiredWithoutTenantLeaseNestedInput
  }

  export type TenantLeaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    leaseId?: StringFieldUpdateOperationsInput | string
  }

  export type TenantLeaseCreateManyInput = {
    id?: string
    tenantId: string
    leaseId: string
  }

  export type TenantLeaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type TenantLeaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    leaseId?: StringFieldUpdateOperationsInput | string
  }

  export type MaintenanceRequestCreateInput = {
    id?: string
    description?: string | null
    status?: $Enums.MaintenanceRequestStatus | null
    priority: $Enums.MaintenanceRequestPriority
    createdAt?: Date | string
    updatedAt?: Date | string
    File?: FileCreateNestedManyWithoutMaintenanceRequestInput
    lease: LeaseCreateNestedOneWithoutMaintenanceRequestInput
  }

  export type MaintenanceRequestUncheckedCreateInput = {
    id?: string
    leaseId: string
    description?: string | null
    status?: $Enums.MaintenanceRequestStatus | null
    priority: $Enums.MaintenanceRequestPriority
    createdAt?: Date | string
    updatedAt?: Date | string
    File?: FileUncheckedCreateNestedManyWithoutMaintenanceRequestInput
  }

  export type MaintenanceRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumMaintenanceRequestStatusFieldUpdateOperationsInput | $Enums.MaintenanceRequestStatus | null
    priority?: EnumMaintenanceRequestPriorityFieldUpdateOperationsInput | $Enums.MaintenanceRequestPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    File?: FileUpdateManyWithoutMaintenanceRequestNestedInput
    lease?: LeaseUpdateOneRequiredWithoutMaintenanceRequestNestedInput
  }

  export type MaintenanceRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaseId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumMaintenanceRequestStatusFieldUpdateOperationsInput | $Enums.MaintenanceRequestStatus | null
    priority?: EnumMaintenanceRequestPriorityFieldUpdateOperationsInput | $Enums.MaintenanceRequestPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    File?: FileUncheckedUpdateManyWithoutMaintenanceRequestNestedInput
  }

  export type MaintenanceRequestCreateManyInput = {
    id?: string
    leaseId: string
    description?: string | null
    status?: $Enums.MaintenanceRequestStatus | null
    priority: $Enums.MaintenanceRequestPriority
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaintenanceRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumMaintenanceRequestStatusFieldUpdateOperationsInput | $Enums.MaintenanceRequestStatus | null
    priority?: EnumMaintenanceRequestPriorityFieldUpdateOperationsInput | $Enums.MaintenanceRequestPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaseId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumMaintenanceRequestStatusFieldUpdateOperationsInput | $Enums.MaintenanceRequestStatus | null
    priority?: EnumMaintenanceRequestPriorityFieldUpdateOperationsInput | $Enums.MaintenanceRequestPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileCreateInput = {
    id?: string
    name: string
    url: string
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    size?: number | null
    type?: string | null
    invoice?: InvoiceCreateNestedOneWithoutFileInput
    lease?: LeaseCreateNestedOneWithoutFileInput
    maintenanceRequest?: MaintenanceRequestCreateNestedOneWithoutFileInput
    property?: PropertyCreateNestedOneWithoutFilesInput
    tenant?: TenantCreateNestedOneWithoutFilesInput
  }

  export type FileUncheckedCreateInput = {
    id?: string
    name: string
    url: string
    ownerId: string
    tenantId?: string | null
    propertyId?: string | null
    leaseId?: string | null
    invoiceId?: string | null
    maintenanceRequestId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    size?: number | null
    type?: string | null
  }

  export type FileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: InvoiceUpdateOneWithoutFileNestedInput
    lease?: LeaseUpdateOneWithoutFileNestedInput
    maintenanceRequest?: MaintenanceRequestUpdateOneWithoutFileNestedInput
    property?: PropertyUpdateOneWithoutFilesNestedInput
    tenant?: TenantUpdateOneWithoutFilesNestedInput
  }

  export type FileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    leaseId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FileCreateManyInput = {
    id?: string
    name: string
    url: string
    ownerId: string
    tenantId?: string | null
    propertyId?: string | null
    leaseId?: string | null
    invoiceId?: string | null
    maintenanceRequestId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    size?: number | null
    type?: string | null
  }

  export type FileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    leaseId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type PropertyListRelationFilter = {
    every?: PropertyWhereInput
    some?: PropertyWhereInput
    none?: PropertyWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type TenantListRelationFilter = {
    every?: TenantWhereInput
    some?: TenantWhereInput
    none?: TenantWhereInput
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    idNumber?: SortOrder
    paystackSplitGroupId?: SortOrder
    paystackSubAccountId?: SortOrder
    paystackSubscriptionId?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    onboardingCompleted?: SortOrder
    businessName?: SortOrder
    countryCode?: SortOrder
    numberOfProperties?: SortOrder
    numberOfUnits?: SortOrder
    phone?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    numberOfProperties?: SortOrder
    numberOfUnits?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    idNumber?: SortOrder
    paystackSplitGroupId?: SortOrder
    paystackSubAccountId?: SortOrder
    paystackSubscriptionId?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    onboardingCompleted?: SortOrder
    businessName?: SortOrder
    countryCode?: SortOrder
    numberOfProperties?: SortOrder
    numberOfUnits?: SortOrder
    phone?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    idNumber?: SortOrder
    paystackSplitGroupId?: SortOrder
    paystackSubAccountId?: SortOrder
    paystackSubscriptionId?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    onboardingCompleted?: SortOrder
    businessName?: SortOrder
    countryCode?: SortOrder
    numberOfProperties?: SortOrder
    numberOfUnits?: SortOrder
    phone?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    numberOfProperties?: SortOrder
    numberOfUnits?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type VerificationCountOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMinOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type FileListRelationFilter = {
    every?: FileWhereInput
    some?: FileWhereInput
    none?: FileWhereInput
  }

  export type TenantLeaseListRelationFilter = {
    every?: TenantLeaseWhereInput
    some?: TenantLeaseWhereInput
    none?: TenantLeaseWhereInput
  }

  export type RecurringBillableListRelationFilter = {
    every?: RecurringBillableWhereInput
    some?: RecurringBillableWhereInput
    none?: RecurringBillableWhereInput
  }

  export type FileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantLeaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecurringBillableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    landlordId?: SortOrder
    dateOfBirth?: SortOrder
    tenantEmergencyContact?: SortOrder
    tenantIncome?: SortOrder
    additionalEmails?: SortOrder
    additionalPhones?: SortOrder
    emergencyContacts?: SortOrder
    vehicles?: SortOrder
    avatarUrl?: SortOrder
    fullName?: SortOrder
    paystackCustomerId?: SortOrder
  }

  export type TenantMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    landlordId?: SortOrder
    dateOfBirth?: SortOrder
    avatarUrl?: SortOrder
    fullName?: SortOrder
    paystackCustomerId?: SortOrder
  }

  export type TenantMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    landlordId?: SortOrder
    dateOfBirth?: SortOrder
    avatarUrl?: SortOrder
    fullName?: SortOrder
    paystackCustomerId?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumPropertyStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyStatus | EnumPropertyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyStatusFilter<$PrismaModel> | $Enums.PropertyStatus
  }

  export type EnumPropertyTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyType | EnumPropertyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyTypeFilter<$PrismaModel> | $Enums.PropertyType
  }

  export type UnitListRelationFilter = {
    every?: UnitWhereInput
    some?: UnitWhereInput
    none?: UnitWhereInput
  }

  export type UnitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    imageUrl?: SortOrder
    propertyStatus?: SortOrder
    propertyType?: SortOrder
    amenities?: SortOrder
    countryCode?: SortOrder
    features?: SortOrder
    landlordId?: SortOrder
  }

  export type PropertyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    imageUrl?: SortOrder
    propertyStatus?: SortOrder
    propertyType?: SortOrder
    countryCode?: SortOrder
    landlordId?: SortOrder
  }

  export type PropertyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    imageUrl?: SortOrder
    propertyStatus?: SortOrder
    propertyType?: SortOrder
    countryCode?: SortOrder
    landlordId?: SortOrder
  }

  export type EnumPropertyStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyStatus | EnumPropertyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyStatusWithAggregatesFilter<$PrismaModel> | $Enums.PropertyStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPropertyStatusFilter<$PrismaModel>
    _max?: NestedEnumPropertyStatusFilter<$PrismaModel>
  }

  export type EnumPropertyTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyType | EnumPropertyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyTypeWithAggregatesFilter<$PrismaModel> | $Enums.PropertyType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPropertyTypeFilter<$PrismaModel>
    _max?: NestedEnumPropertyTypeFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type LeaseListRelationFilter = {
    every?: LeaseWhereInput
    some?: LeaseWhereInput
    none?: LeaseWhereInput
  }

  export type PropertyScalarRelationFilter = {
    is?: PropertyWhereInput
    isNot?: PropertyWhereInput
  }

  export type LeaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UnitCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bathrooms?: SortOrder
    bedrooms?: SortOrder
    deposit?: SortOrder
    marketRent?: SortOrder
    sqmt?: SortOrder
  }

  export type UnitAvgOrderByAggregateInput = {
    bathrooms?: SortOrder
    bedrooms?: SortOrder
    deposit?: SortOrder
    marketRent?: SortOrder
    sqmt?: SortOrder
  }

  export type UnitMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bathrooms?: SortOrder
    bedrooms?: SortOrder
    deposit?: SortOrder
    marketRent?: SortOrder
    sqmt?: SortOrder
  }

  export type UnitMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bathrooms?: SortOrder
    bedrooms?: SortOrder
    deposit?: SortOrder
    marketRent?: SortOrder
    sqmt?: SortOrder
  }

  export type UnitSumOrderByAggregateInput = {
    bathrooms?: SortOrder
    bedrooms?: SortOrder
    deposit?: SortOrder
    marketRent?: SortOrder
    sqmt?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumLeaseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaseStatus | EnumLeaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaseStatus[] | ListEnumLeaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaseStatus[] | ListEnumLeaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaseStatusFilter<$PrismaModel> | $Enums.LeaseStatus
  }

  export type EnumInvoiceCycleFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceCycle | EnumInvoiceCycleFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceCycle[] | ListEnumInvoiceCycleFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceCycle[] | ListEnumInvoiceCycleFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceCycleFilter<$PrismaModel> | $Enums.InvoiceCycle
  }

  export type EnumLeaseTermTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaseTermType | EnumLeaseTermTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LeaseTermType[] | ListEnumLeaseTermTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaseTermType[] | ListEnumLeaseTermTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaseTermTypeFilter<$PrismaModel> | $Enums.LeaseTermType
  }

  export type UnitNullableScalarRelationFilter = {
    is?: UnitWhereInput | null
    isNot?: UnitWhereInput | null
  }

  export type MaintenanceRequestListRelationFilter = {
    every?: MaintenanceRequestWhereInput
    some?: MaintenanceRequestWhereInput
    none?: MaintenanceRequestWhereInput
  }

  export type TransactionsListRelationFilter = {
    every?: TransactionsWhereInput
    some?: TransactionsWhereInput
    none?: TransactionsWhereInput
  }

  export type MaintenanceRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeaseCountOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    rent?: SortOrder
    deposit?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rentDueCurrency?: SortOrder
    unitId?: SortOrder
    automaticInvoice?: SortOrder
    invoiceCycle?: SortOrder
    leaseType?: SortOrder
  }

  export type LeaseAvgOrderByAggregateInput = {
    rent?: SortOrder
    deposit?: SortOrder
  }

  export type LeaseMaxOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    rent?: SortOrder
    deposit?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rentDueCurrency?: SortOrder
    unitId?: SortOrder
    automaticInvoice?: SortOrder
    invoiceCycle?: SortOrder
    leaseType?: SortOrder
  }

  export type LeaseMinOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    rent?: SortOrder
    deposit?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rentDueCurrency?: SortOrder
    unitId?: SortOrder
    automaticInvoice?: SortOrder
    invoiceCycle?: SortOrder
    leaseType?: SortOrder
  }

  export type LeaseSumOrderByAggregateInput = {
    rent?: SortOrder
    deposit?: SortOrder
  }

  export type EnumLeaseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaseStatus | EnumLeaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaseStatus[] | ListEnumLeaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaseStatus[] | ListEnumLeaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaseStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeaseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaseStatusFilter<$PrismaModel>
    _max?: NestedEnumLeaseStatusFilter<$PrismaModel>
  }

  export type EnumInvoiceCycleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceCycle | EnumInvoiceCycleFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceCycle[] | ListEnumInvoiceCycleFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceCycle[] | ListEnumInvoiceCycleFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceCycleWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceCycle
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceCycleFilter<$PrismaModel>
    _max?: NestedEnumInvoiceCycleFilter<$PrismaModel>
  }

  export type EnumLeaseTermTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaseTermType | EnumLeaseTermTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LeaseTermType[] | ListEnumLeaseTermTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaseTermType[] | ListEnumLeaseTermTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaseTermTypeWithAggregatesFilter<$PrismaModel> | $Enums.LeaseTermType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaseTermTypeFilter<$PrismaModel>
    _max?: NestedEnumLeaseTermTypeFilter<$PrismaModel>
  }

  export type EnumInvoiceCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceCategory | EnumInvoiceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceCategory[] | ListEnumInvoiceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceCategory[] | ListEnumInvoiceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceCategoryFilter<$PrismaModel> | $Enums.InvoiceCategory
  }

  export type EnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type LeaseNullableScalarRelationFilter = {
    is?: LeaseWhereInput | null
    isNot?: LeaseWhereInput | null
  }

  export type TenantScalarRelationFilter = {
    is?: TenantWhereInput
    isNot?: TenantWhereInput
  }

  export type RecurringBillableNullableScalarRelationFilter = {
    is?: RecurringBillableWhereInput | null
    isNot?: RecurringBillableWhereInput | null
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    leaseId?: SortOrder
    description?: SortOrder
    dueAmount?: SortOrder
    category?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paystackId?: SortOrder
    dueDate?: SortOrder
    lineItems?: SortOrder
    landlordId?: SortOrder
    tenantId?: SortOrder
    recurringBillableId?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    dueAmount?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    leaseId?: SortOrder
    description?: SortOrder
    dueAmount?: SortOrder
    category?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paystackId?: SortOrder
    dueDate?: SortOrder
    landlordId?: SortOrder
    tenantId?: SortOrder
    recurringBillableId?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    leaseId?: SortOrder
    description?: SortOrder
    dueAmount?: SortOrder
    category?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paystackId?: SortOrder
    dueDate?: SortOrder
    landlordId?: SortOrder
    tenantId?: SortOrder
    recurringBillableId?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    dueAmount?: SortOrder
  }

  export type EnumInvoiceCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceCategory | EnumInvoiceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceCategory[] | ListEnumInvoiceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceCategory[] | ListEnumInvoiceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceCategoryWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceCategoryFilter<$PrismaModel>
    _max?: NestedEnumInvoiceCategoryFilter<$PrismaModel>
  }

  export type EnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type PropertyNullableScalarRelationFilter = {
    is?: PropertyWhereInput | null
    isNot?: PropertyWhereInput | null
  }

  export type RecurringBillableCountOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    category?: SortOrder
    cycle?: SortOrder
    nextInvoiceAt?: SortOrder
    isActive?: SortOrder
    leaseId?: SortOrder
    tenantId?: SortOrder
    propertyId?: SortOrder
  }

  export type RecurringBillableAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type RecurringBillableMaxOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    category?: SortOrder
    cycle?: SortOrder
    nextInvoiceAt?: SortOrder
    isActive?: SortOrder
    leaseId?: SortOrder
    tenantId?: SortOrder
    propertyId?: SortOrder
  }

  export type RecurringBillableMinOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    category?: SortOrder
    cycle?: SortOrder
    nextInvoiceAt?: SortOrder
    isActive?: SortOrder
    leaseId?: SortOrder
    tenantId?: SortOrder
    propertyId?: SortOrder
  }

  export type RecurringBillableSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type InvoiceNullableScalarRelationFilter = {
    is?: InvoiceWhereInput | null
    isNot?: InvoiceWhereInput | null
  }

  export type TransactionsCountOrderByAggregateInput = {
    id?: SortOrder
    leaseId?: SortOrder
    description?: SortOrder
    amountPaid?: SortOrder
    referenceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invoiceId?: SortOrder
  }

  export type TransactionsAvgOrderByAggregateInput = {
    amountPaid?: SortOrder
  }

  export type TransactionsMaxOrderByAggregateInput = {
    id?: SortOrder
    leaseId?: SortOrder
    description?: SortOrder
    amountPaid?: SortOrder
    referenceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invoiceId?: SortOrder
  }

  export type TransactionsMinOrderByAggregateInput = {
    id?: SortOrder
    leaseId?: SortOrder
    description?: SortOrder
    amountPaid?: SortOrder
    referenceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invoiceId?: SortOrder
  }

  export type TransactionsSumOrderByAggregateInput = {
    amountPaid?: SortOrder
  }

  export type LeaseScalarRelationFilter = {
    is?: LeaseWhereInput
    isNot?: LeaseWhereInput
  }

  export type TenantLeaseCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    leaseId?: SortOrder
  }

  export type TenantLeaseMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    leaseId?: SortOrder
  }

  export type TenantLeaseMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    leaseId?: SortOrder
  }

  export type EnumMaintenanceRequestStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenanceRequestStatus | EnumMaintenanceRequestStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.MaintenanceRequestStatus[] | ListEnumMaintenanceRequestStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MaintenanceRequestStatus[] | ListEnumMaintenanceRequestStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMaintenanceRequestStatusNullableFilter<$PrismaModel> | $Enums.MaintenanceRequestStatus | null
  }

  export type EnumMaintenanceRequestPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenanceRequestPriority | EnumMaintenanceRequestPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.MaintenanceRequestPriority[] | ListEnumMaintenanceRequestPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaintenanceRequestPriority[] | ListEnumMaintenanceRequestPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumMaintenanceRequestPriorityFilter<$PrismaModel> | $Enums.MaintenanceRequestPriority
  }

  export type MaintenanceRequestCountOrderByAggregateInput = {
    id?: SortOrder
    leaseId?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaintenanceRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    leaseId?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaintenanceRequestMinOrderByAggregateInput = {
    id?: SortOrder
    leaseId?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumMaintenanceRequestStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenanceRequestStatus | EnumMaintenanceRequestStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.MaintenanceRequestStatus[] | ListEnumMaintenanceRequestStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MaintenanceRequestStatus[] | ListEnumMaintenanceRequestStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMaintenanceRequestStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.MaintenanceRequestStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumMaintenanceRequestStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumMaintenanceRequestStatusNullableFilter<$PrismaModel>
  }

  export type EnumMaintenanceRequestPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenanceRequestPriority | EnumMaintenanceRequestPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.MaintenanceRequestPriority[] | ListEnumMaintenanceRequestPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaintenanceRequestPriority[] | ListEnumMaintenanceRequestPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumMaintenanceRequestPriorityWithAggregatesFilter<$PrismaModel> | $Enums.MaintenanceRequestPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMaintenanceRequestPriorityFilter<$PrismaModel>
    _max?: NestedEnumMaintenanceRequestPriorityFilter<$PrismaModel>
  }

  export type MaintenanceRequestNullableScalarRelationFilter = {
    is?: MaintenanceRequestWhereInput | null
    isNot?: MaintenanceRequestWhereInput | null
  }

  export type TenantNullableScalarRelationFilter = {
    is?: TenantWhereInput | null
    isNot?: TenantWhereInput | null
  }

  export type FileCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    ownerId?: SortOrder
    tenantId?: SortOrder
    propertyId?: SortOrder
    leaseId?: SortOrder
    invoiceId?: SortOrder
    maintenanceRequestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    size?: SortOrder
    type?: SortOrder
  }

  export type FileAvgOrderByAggregateInput = {
    size?: SortOrder
  }

  export type FileMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    ownerId?: SortOrder
    tenantId?: SortOrder
    propertyId?: SortOrder
    leaseId?: SortOrder
    invoiceId?: SortOrder
    maintenanceRequestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    size?: SortOrder
    type?: SortOrder
  }

  export type FileMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    ownerId?: SortOrder
    tenantId?: SortOrder
    propertyId?: SortOrder
    leaseId?: SortOrder
    invoiceId?: SortOrder
    maintenanceRequestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    size?: SortOrder
    type?: SortOrder
  }

  export type FileSumOrderByAggregateInput = {
    size?: SortOrder
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type PropertyCreateNestedManyWithoutLandlordInput = {
    create?: XOR<PropertyCreateWithoutLandlordInput, PropertyUncheckedCreateWithoutLandlordInput> | PropertyCreateWithoutLandlordInput[] | PropertyUncheckedCreateWithoutLandlordInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutLandlordInput | PropertyCreateOrConnectWithoutLandlordInput[]
    createMany?: PropertyCreateManyLandlordInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type TenantCreateNestedManyWithoutLandlordInput = {
    create?: XOR<TenantCreateWithoutLandlordInput, TenantUncheckedCreateWithoutLandlordInput> | TenantCreateWithoutLandlordInput[] | TenantUncheckedCreateWithoutLandlordInput[]
    connectOrCreate?: TenantCreateOrConnectWithoutLandlordInput | TenantCreateOrConnectWithoutLandlordInput[]
    createMany?: TenantCreateManyLandlordInputEnvelope
    connect?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutLandlordInput = {
    create?: XOR<InvoiceCreateWithoutLandlordInput, InvoiceUncheckedCreateWithoutLandlordInput> | InvoiceCreateWithoutLandlordInput[] | InvoiceUncheckedCreateWithoutLandlordInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutLandlordInput | InvoiceCreateOrConnectWithoutLandlordInput[]
    createMany?: InvoiceCreateManyLandlordInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type PropertyUncheckedCreateNestedManyWithoutLandlordInput = {
    create?: XOR<PropertyCreateWithoutLandlordInput, PropertyUncheckedCreateWithoutLandlordInput> | PropertyCreateWithoutLandlordInput[] | PropertyUncheckedCreateWithoutLandlordInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutLandlordInput | PropertyCreateOrConnectWithoutLandlordInput[]
    createMany?: PropertyCreateManyLandlordInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type TenantUncheckedCreateNestedManyWithoutLandlordInput = {
    create?: XOR<TenantCreateWithoutLandlordInput, TenantUncheckedCreateWithoutLandlordInput> | TenantCreateWithoutLandlordInput[] | TenantUncheckedCreateWithoutLandlordInput[]
    connectOrCreate?: TenantCreateOrConnectWithoutLandlordInput | TenantCreateOrConnectWithoutLandlordInput[]
    createMany?: TenantCreateManyLandlordInputEnvelope
    connect?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutLandlordInput = {
    create?: XOR<InvoiceCreateWithoutLandlordInput, InvoiceUncheckedCreateWithoutLandlordInput> | InvoiceCreateWithoutLandlordInput[] | InvoiceUncheckedCreateWithoutLandlordInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutLandlordInput | InvoiceCreateOrConnectWithoutLandlordInput[]
    createMany?: InvoiceCreateManyLandlordInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type PropertyUpdateManyWithoutLandlordNestedInput = {
    create?: XOR<PropertyCreateWithoutLandlordInput, PropertyUncheckedCreateWithoutLandlordInput> | PropertyCreateWithoutLandlordInput[] | PropertyUncheckedCreateWithoutLandlordInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutLandlordInput | PropertyCreateOrConnectWithoutLandlordInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutLandlordInput | PropertyUpsertWithWhereUniqueWithoutLandlordInput[]
    createMany?: PropertyCreateManyLandlordInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutLandlordInput | PropertyUpdateWithWhereUniqueWithoutLandlordInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutLandlordInput | PropertyUpdateManyWithWhereWithoutLandlordInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type TenantUpdateManyWithoutLandlordNestedInput = {
    create?: XOR<TenantCreateWithoutLandlordInput, TenantUncheckedCreateWithoutLandlordInput> | TenantCreateWithoutLandlordInput[] | TenantUncheckedCreateWithoutLandlordInput[]
    connectOrCreate?: TenantCreateOrConnectWithoutLandlordInput | TenantCreateOrConnectWithoutLandlordInput[]
    upsert?: TenantUpsertWithWhereUniqueWithoutLandlordInput | TenantUpsertWithWhereUniqueWithoutLandlordInput[]
    createMany?: TenantCreateManyLandlordInputEnvelope
    set?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    disconnect?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    delete?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    connect?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    update?: TenantUpdateWithWhereUniqueWithoutLandlordInput | TenantUpdateWithWhereUniqueWithoutLandlordInput[]
    updateMany?: TenantUpdateManyWithWhereWithoutLandlordInput | TenantUpdateManyWithWhereWithoutLandlordInput[]
    deleteMany?: TenantScalarWhereInput | TenantScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutLandlordNestedInput = {
    create?: XOR<InvoiceCreateWithoutLandlordInput, InvoiceUncheckedCreateWithoutLandlordInput> | InvoiceCreateWithoutLandlordInput[] | InvoiceUncheckedCreateWithoutLandlordInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutLandlordInput | InvoiceCreateOrConnectWithoutLandlordInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutLandlordInput | InvoiceUpsertWithWhereUniqueWithoutLandlordInput[]
    createMany?: InvoiceCreateManyLandlordInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutLandlordInput | InvoiceUpdateWithWhereUniqueWithoutLandlordInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutLandlordInput | InvoiceUpdateManyWithWhereWithoutLandlordInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type PropertyUncheckedUpdateManyWithoutLandlordNestedInput = {
    create?: XOR<PropertyCreateWithoutLandlordInput, PropertyUncheckedCreateWithoutLandlordInput> | PropertyCreateWithoutLandlordInput[] | PropertyUncheckedCreateWithoutLandlordInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutLandlordInput | PropertyCreateOrConnectWithoutLandlordInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutLandlordInput | PropertyUpsertWithWhereUniqueWithoutLandlordInput[]
    createMany?: PropertyCreateManyLandlordInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutLandlordInput | PropertyUpdateWithWhereUniqueWithoutLandlordInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutLandlordInput | PropertyUpdateManyWithWhereWithoutLandlordInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type TenantUncheckedUpdateManyWithoutLandlordNestedInput = {
    create?: XOR<TenantCreateWithoutLandlordInput, TenantUncheckedCreateWithoutLandlordInput> | TenantCreateWithoutLandlordInput[] | TenantUncheckedCreateWithoutLandlordInput[]
    connectOrCreate?: TenantCreateOrConnectWithoutLandlordInput | TenantCreateOrConnectWithoutLandlordInput[]
    upsert?: TenantUpsertWithWhereUniqueWithoutLandlordInput | TenantUpsertWithWhereUniqueWithoutLandlordInput[]
    createMany?: TenantCreateManyLandlordInputEnvelope
    set?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    disconnect?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    delete?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    connect?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    update?: TenantUpdateWithWhereUniqueWithoutLandlordInput | TenantUpdateWithWhereUniqueWithoutLandlordInput[]
    updateMany?: TenantUpdateManyWithWhereWithoutLandlordInput | TenantUpdateManyWithWhereWithoutLandlordInput[]
    deleteMany?: TenantScalarWhereInput | TenantScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutLandlordNestedInput = {
    create?: XOR<InvoiceCreateWithoutLandlordInput, InvoiceUncheckedCreateWithoutLandlordInput> | InvoiceCreateWithoutLandlordInput[] | InvoiceUncheckedCreateWithoutLandlordInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutLandlordInput | InvoiceCreateOrConnectWithoutLandlordInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutLandlordInput | InvoiceUpsertWithWhereUniqueWithoutLandlordInput[]
    createMany?: InvoiceCreateManyLandlordInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutLandlordInput | InvoiceUpdateWithWhereUniqueWithoutLandlordInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutLandlordInput | InvoiceUpdateManyWithWhereWithoutLandlordInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type TenantCreateadditionalEmailsInput = {
    set: string[]
  }

  export type TenantCreateadditionalPhonesInput = {
    set: string[]
  }

  export type FileCreateNestedManyWithoutTenantInput = {
    create?: XOR<FileCreateWithoutTenantInput, FileUncheckedCreateWithoutTenantInput> | FileCreateWithoutTenantInput[] | FileUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: FileCreateOrConnectWithoutTenantInput | FileCreateOrConnectWithoutTenantInput[]
    createMany?: FileCreateManyTenantInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutTenantInput = {
    create?: XOR<InvoiceCreateWithoutTenantInput, InvoiceUncheckedCreateWithoutTenantInput> | InvoiceCreateWithoutTenantInput[] | InvoiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutTenantInput | InvoiceCreateOrConnectWithoutTenantInput[]
    createMany?: InvoiceCreateManyTenantInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput
    connect?: UserWhereUniqueInput
  }

  export type TenantLeaseCreateNestedManyWithoutTenantInput = {
    create?: XOR<TenantLeaseCreateWithoutTenantInput, TenantLeaseUncheckedCreateWithoutTenantInput> | TenantLeaseCreateWithoutTenantInput[] | TenantLeaseUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantLeaseCreateOrConnectWithoutTenantInput | TenantLeaseCreateOrConnectWithoutTenantInput[]
    createMany?: TenantLeaseCreateManyTenantInputEnvelope
    connect?: TenantLeaseWhereUniqueInput | TenantLeaseWhereUniqueInput[]
  }

  export type RecurringBillableCreateNestedManyWithoutTenantInput = {
    create?: XOR<RecurringBillableCreateWithoutTenantInput, RecurringBillableUncheckedCreateWithoutTenantInput> | RecurringBillableCreateWithoutTenantInput[] | RecurringBillableUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RecurringBillableCreateOrConnectWithoutTenantInput | RecurringBillableCreateOrConnectWithoutTenantInput[]
    createMany?: RecurringBillableCreateManyTenantInputEnvelope
    connect?: RecurringBillableWhereUniqueInput | RecurringBillableWhereUniqueInput[]
  }

  export type FileUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<FileCreateWithoutTenantInput, FileUncheckedCreateWithoutTenantInput> | FileCreateWithoutTenantInput[] | FileUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: FileCreateOrConnectWithoutTenantInput | FileCreateOrConnectWithoutTenantInput[]
    createMany?: FileCreateManyTenantInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<InvoiceCreateWithoutTenantInput, InvoiceUncheckedCreateWithoutTenantInput> | InvoiceCreateWithoutTenantInput[] | InvoiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutTenantInput | InvoiceCreateOrConnectWithoutTenantInput[]
    createMany?: InvoiceCreateManyTenantInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type TenantLeaseUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<TenantLeaseCreateWithoutTenantInput, TenantLeaseUncheckedCreateWithoutTenantInput> | TenantLeaseCreateWithoutTenantInput[] | TenantLeaseUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantLeaseCreateOrConnectWithoutTenantInput | TenantLeaseCreateOrConnectWithoutTenantInput[]
    createMany?: TenantLeaseCreateManyTenantInputEnvelope
    connect?: TenantLeaseWhereUniqueInput | TenantLeaseWhereUniqueInput[]
  }

  export type RecurringBillableUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<RecurringBillableCreateWithoutTenantInput, RecurringBillableUncheckedCreateWithoutTenantInput> | RecurringBillableCreateWithoutTenantInput[] | RecurringBillableUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RecurringBillableCreateOrConnectWithoutTenantInput | RecurringBillableCreateOrConnectWithoutTenantInput[]
    createMany?: RecurringBillableCreateManyTenantInputEnvelope
    connect?: RecurringBillableWhereUniqueInput | RecurringBillableWhereUniqueInput[]
  }

  export type TenantUpdateadditionalEmailsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TenantUpdateadditionalPhonesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type FileUpdateManyWithoutTenantNestedInput = {
    create?: XOR<FileCreateWithoutTenantInput, FileUncheckedCreateWithoutTenantInput> | FileCreateWithoutTenantInput[] | FileUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: FileCreateOrConnectWithoutTenantInput | FileCreateOrConnectWithoutTenantInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutTenantInput | FileUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: FileCreateManyTenantInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutTenantInput | FileUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: FileUpdateManyWithWhereWithoutTenantInput | FileUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutTenantNestedInput = {
    create?: XOR<InvoiceCreateWithoutTenantInput, InvoiceUncheckedCreateWithoutTenantInput> | InvoiceCreateWithoutTenantInput[] | InvoiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutTenantInput | InvoiceCreateOrConnectWithoutTenantInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutTenantInput | InvoiceUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: InvoiceCreateManyTenantInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutTenantInput | InvoiceUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutTenantInput | InvoiceUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput
    upsert?: UserUpsertWithoutTenantInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTenantInput, UserUpdateWithoutTenantInput>, UserUncheckedUpdateWithoutTenantInput>
  }

  export type TenantLeaseUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TenantLeaseCreateWithoutTenantInput, TenantLeaseUncheckedCreateWithoutTenantInput> | TenantLeaseCreateWithoutTenantInput[] | TenantLeaseUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantLeaseCreateOrConnectWithoutTenantInput | TenantLeaseCreateOrConnectWithoutTenantInput[]
    upsert?: TenantLeaseUpsertWithWhereUniqueWithoutTenantInput | TenantLeaseUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TenantLeaseCreateManyTenantInputEnvelope
    set?: TenantLeaseWhereUniqueInput | TenantLeaseWhereUniqueInput[]
    disconnect?: TenantLeaseWhereUniqueInput | TenantLeaseWhereUniqueInput[]
    delete?: TenantLeaseWhereUniqueInput | TenantLeaseWhereUniqueInput[]
    connect?: TenantLeaseWhereUniqueInput | TenantLeaseWhereUniqueInput[]
    update?: TenantLeaseUpdateWithWhereUniqueWithoutTenantInput | TenantLeaseUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TenantLeaseUpdateManyWithWhereWithoutTenantInput | TenantLeaseUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TenantLeaseScalarWhereInput | TenantLeaseScalarWhereInput[]
  }

  export type RecurringBillableUpdateManyWithoutTenantNestedInput = {
    create?: XOR<RecurringBillableCreateWithoutTenantInput, RecurringBillableUncheckedCreateWithoutTenantInput> | RecurringBillableCreateWithoutTenantInput[] | RecurringBillableUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RecurringBillableCreateOrConnectWithoutTenantInput | RecurringBillableCreateOrConnectWithoutTenantInput[]
    upsert?: RecurringBillableUpsertWithWhereUniqueWithoutTenantInput | RecurringBillableUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: RecurringBillableCreateManyTenantInputEnvelope
    set?: RecurringBillableWhereUniqueInput | RecurringBillableWhereUniqueInput[]
    disconnect?: RecurringBillableWhereUniqueInput | RecurringBillableWhereUniqueInput[]
    delete?: RecurringBillableWhereUniqueInput | RecurringBillableWhereUniqueInput[]
    connect?: RecurringBillableWhereUniqueInput | RecurringBillableWhereUniqueInput[]
    update?: RecurringBillableUpdateWithWhereUniqueWithoutTenantInput | RecurringBillableUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: RecurringBillableUpdateManyWithWhereWithoutTenantInput | RecurringBillableUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: RecurringBillableScalarWhereInput | RecurringBillableScalarWhereInput[]
  }

  export type FileUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<FileCreateWithoutTenantInput, FileUncheckedCreateWithoutTenantInput> | FileCreateWithoutTenantInput[] | FileUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: FileCreateOrConnectWithoutTenantInput | FileCreateOrConnectWithoutTenantInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutTenantInput | FileUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: FileCreateManyTenantInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutTenantInput | FileUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: FileUpdateManyWithWhereWithoutTenantInput | FileUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<InvoiceCreateWithoutTenantInput, InvoiceUncheckedCreateWithoutTenantInput> | InvoiceCreateWithoutTenantInput[] | InvoiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutTenantInput | InvoiceCreateOrConnectWithoutTenantInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutTenantInput | InvoiceUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: InvoiceCreateManyTenantInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutTenantInput | InvoiceUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutTenantInput | InvoiceUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type TenantLeaseUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TenantLeaseCreateWithoutTenantInput, TenantLeaseUncheckedCreateWithoutTenantInput> | TenantLeaseCreateWithoutTenantInput[] | TenantLeaseUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantLeaseCreateOrConnectWithoutTenantInput | TenantLeaseCreateOrConnectWithoutTenantInput[]
    upsert?: TenantLeaseUpsertWithWhereUniqueWithoutTenantInput | TenantLeaseUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TenantLeaseCreateManyTenantInputEnvelope
    set?: TenantLeaseWhereUniqueInput | TenantLeaseWhereUniqueInput[]
    disconnect?: TenantLeaseWhereUniqueInput | TenantLeaseWhereUniqueInput[]
    delete?: TenantLeaseWhereUniqueInput | TenantLeaseWhereUniqueInput[]
    connect?: TenantLeaseWhereUniqueInput | TenantLeaseWhereUniqueInput[]
    update?: TenantLeaseUpdateWithWhereUniqueWithoutTenantInput | TenantLeaseUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TenantLeaseUpdateManyWithWhereWithoutTenantInput | TenantLeaseUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TenantLeaseScalarWhereInput | TenantLeaseScalarWhereInput[]
  }

  export type RecurringBillableUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<RecurringBillableCreateWithoutTenantInput, RecurringBillableUncheckedCreateWithoutTenantInput> | RecurringBillableCreateWithoutTenantInput[] | RecurringBillableUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RecurringBillableCreateOrConnectWithoutTenantInput | RecurringBillableCreateOrConnectWithoutTenantInput[]
    upsert?: RecurringBillableUpsertWithWhereUniqueWithoutTenantInput | RecurringBillableUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: RecurringBillableCreateManyTenantInputEnvelope
    set?: RecurringBillableWhereUniqueInput | RecurringBillableWhereUniqueInput[]
    disconnect?: RecurringBillableWhereUniqueInput | RecurringBillableWhereUniqueInput[]
    delete?: RecurringBillableWhereUniqueInput | RecurringBillableWhereUniqueInput[]
    connect?: RecurringBillableWhereUniqueInput | RecurringBillableWhereUniqueInput[]
    update?: RecurringBillableUpdateWithWhereUniqueWithoutTenantInput | RecurringBillableUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: RecurringBillableUpdateManyWithWhereWithoutTenantInput | RecurringBillableUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: RecurringBillableScalarWhereInput | RecurringBillableScalarWhereInput[]
  }

  export type PropertyCreateamenitiesInput = {
    set: string[]
  }

  export type PropertyCreatefeaturesInput = {
    set: string[]
  }

  export type FileCreateNestedManyWithoutPropertyInput = {
    create?: XOR<FileCreateWithoutPropertyInput, FileUncheckedCreateWithoutPropertyInput> | FileCreateWithoutPropertyInput[] | FileUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: FileCreateOrConnectWithoutPropertyInput | FileCreateOrConnectWithoutPropertyInput[]
    createMany?: FileCreateManyPropertyInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutPropertyInput = {
    create?: XOR<UserCreateWithoutPropertyInput, UserUncheckedCreateWithoutPropertyInput>
    connectOrCreate?: UserCreateOrConnectWithoutPropertyInput
    connect?: UserWhereUniqueInput
  }

  export type UnitCreateNestedManyWithoutPropertyInput = {
    create?: XOR<UnitCreateWithoutPropertyInput, UnitUncheckedCreateWithoutPropertyInput> | UnitCreateWithoutPropertyInput[] | UnitUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutPropertyInput | UnitCreateOrConnectWithoutPropertyInput[]
    createMany?: UnitCreateManyPropertyInputEnvelope
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
  }

  export type RecurringBillableCreateNestedManyWithoutPropertyInput = {
    create?: XOR<RecurringBillableCreateWithoutPropertyInput, RecurringBillableUncheckedCreateWithoutPropertyInput> | RecurringBillableCreateWithoutPropertyInput[] | RecurringBillableUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: RecurringBillableCreateOrConnectWithoutPropertyInput | RecurringBillableCreateOrConnectWithoutPropertyInput[]
    createMany?: RecurringBillableCreateManyPropertyInputEnvelope
    connect?: RecurringBillableWhereUniqueInput | RecurringBillableWhereUniqueInput[]
  }

  export type FileUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<FileCreateWithoutPropertyInput, FileUncheckedCreateWithoutPropertyInput> | FileCreateWithoutPropertyInput[] | FileUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: FileCreateOrConnectWithoutPropertyInput | FileCreateOrConnectWithoutPropertyInput[]
    createMany?: FileCreateManyPropertyInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type UnitUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<UnitCreateWithoutPropertyInput, UnitUncheckedCreateWithoutPropertyInput> | UnitCreateWithoutPropertyInput[] | UnitUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutPropertyInput | UnitCreateOrConnectWithoutPropertyInput[]
    createMany?: UnitCreateManyPropertyInputEnvelope
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
  }

  export type RecurringBillableUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<RecurringBillableCreateWithoutPropertyInput, RecurringBillableUncheckedCreateWithoutPropertyInput> | RecurringBillableCreateWithoutPropertyInput[] | RecurringBillableUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: RecurringBillableCreateOrConnectWithoutPropertyInput | RecurringBillableCreateOrConnectWithoutPropertyInput[]
    createMany?: RecurringBillableCreateManyPropertyInputEnvelope
    connect?: RecurringBillableWhereUniqueInput | RecurringBillableWhereUniqueInput[]
  }

  export type EnumPropertyStatusFieldUpdateOperationsInput = {
    set?: $Enums.PropertyStatus
  }

  export type EnumPropertyTypeFieldUpdateOperationsInput = {
    set?: $Enums.PropertyType
  }

  export type PropertyUpdateamenitiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PropertyUpdatefeaturesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type FileUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<FileCreateWithoutPropertyInput, FileUncheckedCreateWithoutPropertyInput> | FileCreateWithoutPropertyInput[] | FileUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: FileCreateOrConnectWithoutPropertyInput | FileCreateOrConnectWithoutPropertyInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutPropertyInput | FileUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: FileCreateManyPropertyInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutPropertyInput | FileUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: FileUpdateManyWithWhereWithoutPropertyInput | FileUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutPropertyNestedInput = {
    create?: XOR<UserCreateWithoutPropertyInput, UserUncheckedCreateWithoutPropertyInput>
    connectOrCreate?: UserCreateOrConnectWithoutPropertyInput
    upsert?: UserUpsertWithoutPropertyInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPropertyInput, UserUpdateWithoutPropertyInput>, UserUncheckedUpdateWithoutPropertyInput>
  }

  export type UnitUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<UnitCreateWithoutPropertyInput, UnitUncheckedCreateWithoutPropertyInput> | UnitCreateWithoutPropertyInput[] | UnitUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutPropertyInput | UnitCreateOrConnectWithoutPropertyInput[]
    upsert?: UnitUpsertWithWhereUniqueWithoutPropertyInput | UnitUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: UnitCreateManyPropertyInputEnvelope
    set?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    disconnect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    delete?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    update?: UnitUpdateWithWhereUniqueWithoutPropertyInput | UnitUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: UnitUpdateManyWithWhereWithoutPropertyInput | UnitUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: UnitScalarWhereInput | UnitScalarWhereInput[]
  }

  export type RecurringBillableUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<RecurringBillableCreateWithoutPropertyInput, RecurringBillableUncheckedCreateWithoutPropertyInput> | RecurringBillableCreateWithoutPropertyInput[] | RecurringBillableUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: RecurringBillableCreateOrConnectWithoutPropertyInput | RecurringBillableCreateOrConnectWithoutPropertyInput[]
    upsert?: RecurringBillableUpsertWithWhereUniqueWithoutPropertyInput | RecurringBillableUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: RecurringBillableCreateManyPropertyInputEnvelope
    set?: RecurringBillableWhereUniqueInput | RecurringBillableWhereUniqueInput[]
    disconnect?: RecurringBillableWhereUniqueInput | RecurringBillableWhereUniqueInput[]
    delete?: RecurringBillableWhereUniqueInput | RecurringBillableWhereUniqueInput[]
    connect?: RecurringBillableWhereUniqueInput | RecurringBillableWhereUniqueInput[]
    update?: RecurringBillableUpdateWithWhereUniqueWithoutPropertyInput | RecurringBillableUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: RecurringBillableUpdateManyWithWhereWithoutPropertyInput | RecurringBillableUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: RecurringBillableScalarWhereInput | RecurringBillableScalarWhereInput[]
  }

  export type FileUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<FileCreateWithoutPropertyInput, FileUncheckedCreateWithoutPropertyInput> | FileCreateWithoutPropertyInput[] | FileUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: FileCreateOrConnectWithoutPropertyInput | FileCreateOrConnectWithoutPropertyInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutPropertyInput | FileUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: FileCreateManyPropertyInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutPropertyInput | FileUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: FileUpdateManyWithWhereWithoutPropertyInput | FileUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type UnitUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<UnitCreateWithoutPropertyInput, UnitUncheckedCreateWithoutPropertyInput> | UnitCreateWithoutPropertyInput[] | UnitUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutPropertyInput | UnitCreateOrConnectWithoutPropertyInput[]
    upsert?: UnitUpsertWithWhereUniqueWithoutPropertyInput | UnitUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: UnitCreateManyPropertyInputEnvelope
    set?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    disconnect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    delete?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    update?: UnitUpdateWithWhereUniqueWithoutPropertyInput | UnitUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: UnitUpdateManyWithWhereWithoutPropertyInput | UnitUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: UnitScalarWhereInput | UnitScalarWhereInput[]
  }

  export type RecurringBillableUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<RecurringBillableCreateWithoutPropertyInput, RecurringBillableUncheckedCreateWithoutPropertyInput> | RecurringBillableCreateWithoutPropertyInput[] | RecurringBillableUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: RecurringBillableCreateOrConnectWithoutPropertyInput | RecurringBillableCreateOrConnectWithoutPropertyInput[]
    upsert?: RecurringBillableUpsertWithWhereUniqueWithoutPropertyInput | RecurringBillableUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: RecurringBillableCreateManyPropertyInputEnvelope
    set?: RecurringBillableWhereUniqueInput | RecurringBillableWhereUniqueInput[]
    disconnect?: RecurringBillableWhereUniqueInput | RecurringBillableWhereUniqueInput[]
    delete?: RecurringBillableWhereUniqueInput | RecurringBillableWhereUniqueInput[]
    connect?: RecurringBillableWhereUniqueInput | RecurringBillableWhereUniqueInput[]
    update?: RecurringBillableUpdateWithWhereUniqueWithoutPropertyInput | RecurringBillableUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: RecurringBillableUpdateManyWithWhereWithoutPropertyInput | RecurringBillableUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: RecurringBillableScalarWhereInput | RecurringBillableScalarWhereInput[]
  }

  export type LeaseCreateNestedManyWithoutUnitInput = {
    create?: XOR<LeaseCreateWithoutUnitInput, LeaseUncheckedCreateWithoutUnitInput> | LeaseCreateWithoutUnitInput[] | LeaseUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: LeaseCreateOrConnectWithoutUnitInput | LeaseCreateOrConnectWithoutUnitInput[]
    createMany?: LeaseCreateManyUnitInputEnvelope
    connect?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
  }

  export type PropertyCreateNestedOneWithoutUnitInput = {
    create?: XOR<PropertyCreateWithoutUnitInput, PropertyUncheckedCreateWithoutUnitInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutUnitInput
    connect?: PropertyWhereUniqueInput
  }

  export type LeaseUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<LeaseCreateWithoutUnitInput, LeaseUncheckedCreateWithoutUnitInput> | LeaseCreateWithoutUnitInput[] | LeaseUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: LeaseCreateOrConnectWithoutUnitInput | LeaseCreateOrConnectWithoutUnitInput[]
    createMany?: LeaseCreateManyUnitInputEnvelope
    connect?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type LeaseUpdateManyWithoutUnitNestedInput = {
    create?: XOR<LeaseCreateWithoutUnitInput, LeaseUncheckedCreateWithoutUnitInput> | LeaseCreateWithoutUnitInput[] | LeaseUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: LeaseCreateOrConnectWithoutUnitInput | LeaseCreateOrConnectWithoutUnitInput[]
    upsert?: LeaseUpsertWithWhereUniqueWithoutUnitInput | LeaseUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: LeaseCreateManyUnitInputEnvelope
    set?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    disconnect?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    delete?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    connect?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    update?: LeaseUpdateWithWhereUniqueWithoutUnitInput | LeaseUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: LeaseUpdateManyWithWhereWithoutUnitInput | LeaseUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: LeaseScalarWhereInput | LeaseScalarWhereInput[]
  }

  export type PropertyUpdateOneRequiredWithoutUnitNestedInput = {
    create?: XOR<PropertyCreateWithoutUnitInput, PropertyUncheckedCreateWithoutUnitInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutUnitInput
    upsert?: PropertyUpsertWithoutUnitInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutUnitInput, PropertyUpdateWithoutUnitInput>, PropertyUncheckedUpdateWithoutUnitInput>
  }

  export type LeaseUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<LeaseCreateWithoutUnitInput, LeaseUncheckedCreateWithoutUnitInput> | LeaseCreateWithoutUnitInput[] | LeaseUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: LeaseCreateOrConnectWithoutUnitInput | LeaseCreateOrConnectWithoutUnitInput[]
    upsert?: LeaseUpsertWithWhereUniqueWithoutUnitInput | LeaseUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: LeaseCreateManyUnitInputEnvelope
    set?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    disconnect?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    delete?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    connect?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    update?: LeaseUpdateWithWhereUniqueWithoutUnitInput | LeaseUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: LeaseUpdateManyWithWhereWithoutUnitInput | LeaseUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: LeaseScalarWhereInput | LeaseScalarWhereInput[]
  }

  export type FileCreateNestedManyWithoutLeaseInput = {
    create?: XOR<FileCreateWithoutLeaseInput, FileUncheckedCreateWithoutLeaseInput> | FileCreateWithoutLeaseInput[] | FileUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: FileCreateOrConnectWithoutLeaseInput | FileCreateOrConnectWithoutLeaseInput[]
    createMany?: FileCreateManyLeaseInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutLeaseInput = {
    create?: XOR<InvoiceCreateWithoutLeaseInput, InvoiceUncheckedCreateWithoutLeaseInput> | InvoiceCreateWithoutLeaseInput[] | InvoiceUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutLeaseInput | InvoiceCreateOrConnectWithoutLeaseInput[]
    createMany?: InvoiceCreateManyLeaseInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type UnitCreateNestedOneWithoutLeaseInput = {
    create?: XOR<UnitCreateWithoutLeaseInput, UnitUncheckedCreateWithoutLeaseInput>
    connectOrCreate?: UnitCreateOrConnectWithoutLeaseInput
    connect?: UnitWhereUniqueInput
  }

  export type MaintenanceRequestCreateNestedManyWithoutLeaseInput = {
    create?: XOR<MaintenanceRequestCreateWithoutLeaseInput, MaintenanceRequestUncheckedCreateWithoutLeaseInput> | MaintenanceRequestCreateWithoutLeaseInput[] | MaintenanceRequestUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: MaintenanceRequestCreateOrConnectWithoutLeaseInput | MaintenanceRequestCreateOrConnectWithoutLeaseInput[]
    createMany?: MaintenanceRequestCreateManyLeaseInputEnvelope
    connect?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
  }

  export type TenantLeaseCreateNestedManyWithoutLeaseInput = {
    create?: XOR<TenantLeaseCreateWithoutLeaseInput, TenantLeaseUncheckedCreateWithoutLeaseInput> | TenantLeaseCreateWithoutLeaseInput[] | TenantLeaseUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: TenantLeaseCreateOrConnectWithoutLeaseInput | TenantLeaseCreateOrConnectWithoutLeaseInput[]
    createMany?: TenantLeaseCreateManyLeaseInputEnvelope
    connect?: TenantLeaseWhereUniqueInput | TenantLeaseWhereUniqueInput[]
  }

  export type TransactionsCreateNestedManyWithoutLeaseInput = {
    create?: XOR<TransactionsCreateWithoutLeaseInput, TransactionsUncheckedCreateWithoutLeaseInput> | TransactionsCreateWithoutLeaseInput[] | TransactionsUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutLeaseInput | TransactionsCreateOrConnectWithoutLeaseInput[]
    createMany?: TransactionsCreateManyLeaseInputEnvelope
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
  }

  export type RecurringBillableCreateNestedManyWithoutLeaseInput = {
    create?: XOR<RecurringBillableCreateWithoutLeaseInput, RecurringBillableUncheckedCreateWithoutLeaseInput> | RecurringBillableCreateWithoutLeaseInput[] | RecurringBillableUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: RecurringBillableCreateOrConnectWithoutLeaseInput | RecurringBillableCreateOrConnectWithoutLeaseInput[]
    createMany?: RecurringBillableCreateManyLeaseInputEnvelope
    connect?: RecurringBillableWhereUniqueInput | RecurringBillableWhereUniqueInput[]
  }

  export type FileUncheckedCreateNestedManyWithoutLeaseInput = {
    create?: XOR<FileCreateWithoutLeaseInput, FileUncheckedCreateWithoutLeaseInput> | FileCreateWithoutLeaseInput[] | FileUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: FileCreateOrConnectWithoutLeaseInput | FileCreateOrConnectWithoutLeaseInput[]
    createMany?: FileCreateManyLeaseInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutLeaseInput = {
    create?: XOR<InvoiceCreateWithoutLeaseInput, InvoiceUncheckedCreateWithoutLeaseInput> | InvoiceCreateWithoutLeaseInput[] | InvoiceUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutLeaseInput | InvoiceCreateOrConnectWithoutLeaseInput[]
    createMany?: InvoiceCreateManyLeaseInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type MaintenanceRequestUncheckedCreateNestedManyWithoutLeaseInput = {
    create?: XOR<MaintenanceRequestCreateWithoutLeaseInput, MaintenanceRequestUncheckedCreateWithoutLeaseInput> | MaintenanceRequestCreateWithoutLeaseInput[] | MaintenanceRequestUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: MaintenanceRequestCreateOrConnectWithoutLeaseInput | MaintenanceRequestCreateOrConnectWithoutLeaseInput[]
    createMany?: MaintenanceRequestCreateManyLeaseInputEnvelope
    connect?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
  }

  export type TenantLeaseUncheckedCreateNestedManyWithoutLeaseInput = {
    create?: XOR<TenantLeaseCreateWithoutLeaseInput, TenantLeaseUncheckedCreateWithoutLeaseInput> | TenantLeaseCreateWithoutLeaseInput[] | TenantLeaseUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: TenantLeaseCreateOrConnectWithoutLeaseInput | TenantLeaseCreateOrConnectWithoutLeaseInput[]
    createMany?: TenantLeaseCreateManyLeaseInputEnvelope
    connect?: TenantLeaseWhereUniqueInput | TenantLeaseWhereUniqueInput[]
  }

  export type TransactionsUncheckedCreateNestedManyWithoutLeaseInput = {
    create?: XOR<TransactionsCreateWithoutLeaseInput, TransactionsUncheckedCreateWithoutLeaseInput> | TransactionsCreateWithoutLeaseInput[] | TransactionsUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutLeaseInput | TransactionsCreateOrConnectWithoutLeaseInput[]
    createMany?: TransactionsCreateManyLeaseInputEnvelope
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
  }

  export type RecurringBillableUncheckedCreateNestedManyWithoutLeaseInput = {
    create?: XOR<RecurringBillableCreateWithoutLeaseInput, RecurringBillableUncheckedCreateWithoutLeaseInput> | RecurringBillableCreateWithoutLeaseInput[] | RecurringBillableUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: RecurringBillableCreateOrConnectWithoutLeaseInput | RecurringBillableCreateOrConnectWithoutLeaseInput[]
    createMany?: RecurringBillableCreateManyLeaseInputEnvelope
    connect?: RecurringBillableWhereUniqueInput | RecurringBillableWhereUniqueInput[]
  }

  export type EnumLeaseStatusFieldUpdateOperationsInput = {
    set?: $Enums.LeaseStatus
  }

  export type EnumInvoiceCycleFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceCycle
  }

  export type EnumLeaseTermTypeFieldUpdateOperationsInput = {
    set?: $Enums.LeaseTermType
  }

  export type FileUpdateManyWithoutLeaseNestedInput = {
    create?: XOR<FileCreateWithoutLeaseInput, FileUncheckedCreateWithoutLeaseInput> | FileCreateWithoutLeaseInput[] | FileUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: FileCreateOrConnectWithoutLeaseInput | FileCreateOrConnectWithoutLeaseInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutLeaseInput | FileUpsertWithWhereUniqueWithoutLeaseInput[]
    createMany?: FileCreateManyLeaseInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutLeaseInput | FileUpdateWithWhereUniqueWithoutLeaseInput[]
    updateMany?: FileUpdateManyWithWhereWithoutLeaseInput | FileUpdateManyWithWhereWithoutLeaseInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutLeaseNestedInput = {
    create?: XOR<InvoiceCreateWithoutLeaseInput, InvoiceUncheckedCreateWithoutLeaseInput> | InvoiceCreateWithoutLeaseInput[] | InvoiceUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutLeaseInput | InvoiceCreateOrConnectWithoutLeaseInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutLeaseInput | InvoiceUpsertWithWhereUniqueWithoutLeaseInput[]
    createMany?: InvoiceCreateManyLeaseInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutLeaseInput | InvoiceUpdateWithWhereUniqueWithoutLeaseInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutLeaseInput | InvoiceUpdateManyWithWhereWithoutLeaseInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type UnitUpdateOneWithoutLeaseNestedInput = {
    create?: XOR<UnitCreateWithoutLeaseInput, UnitUncheckedCreateWithoutLeaseInput>
    connectOrCreate?: UnitCreateOrConnectWithoutLeaseInput
    upsert?: UnitUpsertWithoutLeaseInput
    disconnect?: UnitWhereInput | boolean
    delete?: UnitWhereInput | boolean
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutLeaseInput, UnitUpdateWithoutLeaseInput>, UnitUncheckedUpdateWithoutLeaseInput>
  }

  export type MaintenanceRequestUpdateManyWithoutLeaseNestedInput = {
    create?: XOR<MaintenanceRequestCreateWithoutLeaseInput, MaintenanceRequestUncheckedCreateWithoutLeaseInput> | MaintenanceRequestCreateWithoutLeaseInput[] | MaintenanceRequestUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: MaintenanceRequestCreateOrConnectWithoutLeaseInput | MaintenanceRequestCreateOrConnectWithoutLeaseInput[]
    upsert?: MaintenanceRequestUpsertWithWhereUniqueWithoutLeaseInput | MaintenanceRequestUpsertWithWhereUniqueWithoutLeaseInput[]
    createMany?: MaintenanceRequestCreateManyLeaseInputEnvelope
    set?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    disconnect?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    delete?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    connect?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    update?: MaintenanceRequestUpdateWithWhereUniqueWithoutLeaseInput | MaintenanceRequestUpdateWithWhereUniqueWithoutLeaseInput[]
    updateMany?: MaintenanceRequestUpdateManyWithWhereWithoutLeaseInput | MaintenanceRequestUpdateManyWithWhereWithoutLeaseInput[]
    deleteMany?: MaintenanceRequestScalarWhereInput | MaintenanceRequestScalarWhereInput[]
  }

  export type TenantLeaseUpdateManyWithoutLeaseNestedInput = {
    create?: XOR<TenantLeaseCreateWithoutLeaseInput, TenantLeaseUncheckedCreateWithoutLeaseInput> | TenantLeaseCreateWithoutLeaseInput[] | TenantLeaseUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: TenantLeaseCreateOrConnectWithoutLeaseInput | TenantLeaseCreateOrConnectWithoutLeaseInput[]
    upsert?: TenantLeaseUpsertWithWhereUniqueWithoutLeaseInput | TenantLeaseUpsertWithWhereUniqueWithoutLeaseInput[]
    createMany?: TenantLeaseCreateManyLeaseInputEnvelope
    set?: TenantLeaseWhereUniqueInput | TenantLeaseWhereUniqueInput[]
    disconnect?: TenantLeaseWhereUniqueInput | TenantLeaseWhereUniqueInput[]
    delete?: TenantLeaseWhereUniqueInput | TenantLeaseWhereUniqueInput[]
    connect?: TenantLeaseWhereUniqueInput | TenantLeaseWhereUniqueInput[]
    update?: TenantLeaseUpdateWithWhereUniqueWithoutLeaseInput | TenantLeaseUpdateWithWhereUniqueWithoutLeaseInput[]
    updateMany?: TenantLeaseUpdateManyWithWhereWithoutLeaseInput | TenantLeaseUpdateManyWithWhereWithoutLeaseInput[]
    deleteMany?: TenantLeaseScalarWhereInput | TenantLeaseScalarWhereInput[]
  }

  export type TransactionsUpdateManyWithoutLeaseNestedInput = {
    create?: XOR<TransactionsCreateWithoutLeaseInput, TransactionsUncheckedCreateWithoutLeaseInput> | TransactionsCreateWithoutLeaseInput[] | TransactionsUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutLeaseInput | TransactionsCreateOrConnectWithoutLeaseInput[]
    upsert?: TransactionsUpsertWithWhereUniqueWithoutLeaseInput | TransactionsUpsertWithWhereUniqueWithoutLeaseInput[]
    createMany?: TransactionsCreateManyLeaseInputEnvelope
    set?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    disconnect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    delete?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    update?: TransactionsUpdateWithWhereUniqueWithoutLeaseInput | TransactionsUpdateWithWhereUniqueWithoutLeaseInput[]
    updateMany?: TransactionsUpdateManyWithWhereWithoutLeaseInput | TransactionsUpdateManyWithWhereWithoutLeaseInput[]
    deleteMany?: TransactionsScalarWhereInput | TransactionsScalarWhereInput[]
  }

  export type RecurringBillableUpdateManyWithoutLeaseNestedInput = {
    create?: XOR<RecurringBillableCreateWithoutLeaseInput, RecurringBillableUncheckedCreateWithoutLeaseInput> | RecurringBillableCreateWithoutLeaseInput[] | RecurringBillableUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: RecurringBillableCreateOrConnectWithoutLeaseInput | RecurringBillableCreateOrConnectWithoutLeaseInput[]
    upsert?: RecurringBillableUpsertWithWhereUniqueWithoutLeaseInput | RecurringBillableUpsertWithWhereUniqueWithoutLeaseInput[]
    createMany?: RecurringBillableCreateManyLeaseInputEnvelope
    set?: RecurringBillableWhereUniqueInput | RecurringBillableWhereUniqueInput[]
    disconnect?: RecurringBillableWhereUniqueInput | RecurringBillableWhereUniqueInput[]
    delete?: RecurringBillableWhereUniqueInput | RecurringBillableWhereUniqueInput[]
    connect?: RecurringBillableWhereUniqueInput | RecurringBillableWhereUniqueInput[]
    update?: RecurringBillableUpdateWithWhereUniqueWithoutLeaseInput | RecurringBillableUpdateWithWhereUniqueWithoutLeaseInput[]
    updateMany?: RecurringBillableUpdateManyWithWhereWithoutLeaseInput | RecurringBillableUpdateManyWithWhereWithoutLeaseInput[]
    deleteMany?: RecurringBillableScalarWhereInput | RecurringBillableScalarWhereInput[]
  }

  export type FileUncheckedUpdateManyWithoutLeaseNestedInput = {
    create?: XOR<FileCreateWithoutLeaseInput, FileUncheckedCreateWithoutLeaseInput> | FileCreateWithoutLeaseInput[] | FileUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: FileCreateOrConnectWithoutLeaseInput | FileCreateOrConnectWithoutLeaseInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutLeaseInput | FileUpsertWithWhereUniqueWithoutLeaseInput[]
    createMany?: FileCreateManyLeaseInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutLeaseInput | FileUpdateWithWhereUniqueWithoutLeaseInput[]
    updateMany?: FileUpdateManyWithWhereWithoutLeaseInput | FileUpdateManyWithWhereWithoutLeaseInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutLeaseNestedInput = {
    create?: XOR<InvoiceCreateWithoutLeaseInput, InvoiceUncheckedCreateWithoutLeaseInput> | InvoiceCreateWithoutLeaseInput[] | InvoiceUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutLeaseInput | InvoiceCreateOrConnectWithoutLeaseInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutLeaseInput | InvoiceUpsertWithWhereUniqueWithoutLeaseInput[]
    createMany?: InvoiceCreateManyLeaseInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutLeaseInput | InvoiceUpdateWithWhereUniqueWithoutLeaseInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutLeaseInput | InvoiceUpdateManyWithWhereWithoutLeaseInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type MaintenanceRequestUncheckedUpdateManyWithoutLeaseNestedInput = {
    create?: XOR<MaintenanceRequestCreateWithoutLeaseInput, MaintenanceRequestUncheckedCreateWithoutLeaseInput> | MaintenanceRequestCreateWithoutLeaseInput[] | MaintenanceRequestUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: MaintenanceRequestCreateOrConnectWithoutLeaseInput | MaintenanceRequestCreateOrConnectWithoutLeaseInput[]
    upsert?: MaintenanceRequestUpsertWithWhereUniqueWithoutLeaseInput | MaintenanceRequestUpsertWithWhereUniqueWithoutLeaseInput[]
    createMany?: MaintenanceRequestCreateManyLeaseInputEnvelope
    set?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    disconnect?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    delete?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    connect?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    update?: MaintenanceRequestUpdateWithWhereUniqueWithoutLeaseInput | MaintenanceRequestUpdateWithWhereUniqueWithoutLeaseInput[]
    updateMany?: MaintenanceRequestUpdateManyWithWhereWithoutLeaseInput | MaintenanceRequestUpdateManyWithWhereWithoutLeaseInput[]
    deleteMany?: MaintenanceRequestScalarWhereInput | MaintenanceRequestScalarWhereInput[]
  }

  export type TenantLeaseUncheckedUpdateManyWithoutLeaseNestedInput = {
    create?: XOR<TenantLeaseCreateWithoutLeaseInput, TenantLeaseUncheckedCreateWithoutLeaseInput> | TenantLeaseCreateWithoutLeaseInput[] | TenantLeaseUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: TenantLeaseCreateOrConnectWithoutLeaseInput | TenantLeaseCreateOrConnectWithoutLeaseInput[]
    upsert?: TenantLeaseUpsertWithWhereUniqueWithoutLeaseInput | TenantLeaseUpsertWithWhereUniqueWithoutLeaseInput[]
    createMany?: TenantLeaseCreateManyLeaseInputEnvelope
    set?: TenantLeaseWhereUniqueInput | TenantLeaseWhereUniqueInput[]
    disconnect?: TenantLeaseWhereUniqueInput | TenantLeaseWhereUniqueInput[]
    delete?: TenantLeaseWhereUniqueInput | TenantLeaseWhereUniqueInput[]
    connect?: TenantLeaseWhereUniqueInput | TenantLeaseWhereUniqueInput[]
    update?: TenantLeaseUpdateWithWhereUniqueWithoutLeaseInput | TenantLeaseUpdateWithWhereUniqueWithoutLeaseInput[]
    updateMany?: TenantLeaseUpdateManyWithWhereWithoutLeaseInput | TenantLeaseUpdateManyWithWhereWithoutLeaseInput[]
    deleteMany?: TenantLeaseScalarWhereInput | TenantLeaseScalarWhereInput[]
  }

  export type TransactionsUncheckedUpdateManyWithoutLeaseNestedInput = {
    create?: XOR<TransactionsCreateWithoutLeaseInput, TransactionsUncheckedCreateWithoutLeaseInput> | TransactionsCreateWithoutLeaseInput[] | TransactionsUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutLeaseInput | TransactionsCreateOrConnectWithoutLeaseInput[]
    upsert?: TransactionsUpsertWithWhereUniqueWithoutLeaseInput | TransactionsUpsertWithWhereUniqueWithoutLeaseInput[]
    createMany?: TransactionsCreateManyLeaseInputEnvelope
    set?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    disconnect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    delete?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    update?: TransactionsUpdateWithWhereUniqueWithoutLeaseInput | TransactionsUpdateWithWhereUniqueWithoutLeaseInput[]
    updateMany?: TransactionsUpdateManyWithWhereWithoutLeaseInput | TransactionsUpdateManyWithWhereWithoutLeaseInput[]
    deleteMany?: TransactionsScalarWhereInput | TransactionsScalarWhereInput[]
  }

  export type RecurringBillableUncheckedUpdateManyWithoutLeaseNestedInput = {
    create?: XOR<RecurringBillableCreateWithoutLeaseInput, RecurringBillableUncheckedCreateWithoutLeaseInput> | RecurringBillableCreateWithoutLeaseInput[] | RecurringBillableUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: RecurringBillableCreateOrConnectWithoutLeaseInput | RecurringBillableCreateOrConnectWithoutLeaseInput[]
    upsert?: RecurringBillableUpsertWithWhereUniqueWithoutLeaseInput | RecurringBillableUpsertWithWhereUniqueWithoutLeaseInput[]
    createMany?: RecurringBillableCreateManyLeaseInputEnvelope
    set?: RecurringBillableWhereUniqueInput | RecurringBillableWhereUniqueInput[]
    disconnect?: RecurringBillableWhereUniqueInput | RecurringBillableWhereUniqueInput[]
    delete?: RecurringBillableWhereUniqueInput | RecurringBillableWhereUniqueInput[]
    connect?: RecurringBillableWhereUniqueInput | RecurringBillableWhereUniqueInput[]
    update?: RecurringBillableUpdateWithWhereUniqueWithoutLeaseInput | RecurringBillableUpdateWithWhereUniqueWithoutLeaseInput[]
    updateMany?: RecurringBillableUpdateManyWithWhereWithoutLeaseInput | RecurringBillableUpdateManyWithWhereWithoutLeaseInput[]
    deleteMany?: RecurringBillableScalarWhereInput | RecurringBillableScalarWhereInput[]
  }

  export type FileCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<FileCreateWithoutInvoiceInput, FileUncheckedCreateWithoutInvoiceInput> | FileCreateWithoutInvoiceInput[] | FileUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: FileCreateOrConnectWithoutInvoiceInput | FileCreateOrConnectWithoutInvoiceInput[]
    createMany?: FileCreateManyInvoiceInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type LeaseCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<LeaseCreateWithoutInvoiceInput, LeaseUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: LeaseCreateOrConnectWithoutInvoiceInput
    connect?: LeaseWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<TenantCreateWithoutInvoiceInput, TenantUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: TenantCreateOrConnectWithoutInvoiceInput
    connect?: TenantWhereUniqueInput
  }

  export type TransactionsCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<TransactionsCreateWithoutInvoiceInput, TransactionsUncheckedCreateWithoutInvoiceInput> | TransactionsCreateWithoutInvoiceInput[] | TransactionsUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutInvoiceInput | TransactionsCreateOrConnectWithoutInvoiceInput[]
    createMany?: TransactionsCreateManyInvoiceInputEnvelope
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
  }

  export type RecurringBillableCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<RecurringBillableCreateWithoutInvoiceInput, RecurringBillableUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: RecurringBillableCreateOrConnectWithoutInvoiceInput
    connect?: RecurringBillableWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<UserCreateWithoutInvoiceInput, UserUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvoiceInput
    connect?: UserWhereUniqueInput
  }

  export type FileUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<FileCreateWithoutInvoiceInput, FileUncheckedCreateWithoutInvoiceInput> | FileCreateWithoutInvoiceInput[] | FileUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: FileCreateOrConnectWithoutInvoiceInput | FileCreateOrConnectWithoutInvoiceInput[]
    createMany?: FileCreateManyInvoiceInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type TransactionsUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<TransactionsCreateWithoutInvoiceInput, TransactionsUncheckedCreateWithoutInvoiceInput> | TransactionsCreateWithoutInvoiceInput[] | TransactionsUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutInvoiceInput | TransactionsCreateOrConnectWithoutInvoiceInput[]
    createMany?: TransactionsCreateManyInvoiceInputEnvelope
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
  }

  export type EnumInvoiceCategoryFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceCategory
  }

  export type EnumInvoiceStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceStatus
  }

  export type FileUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<FileCreateWithoutInvoiceInput, FileUncheckedCreateWithoutInvoiceInput> | FileCreateWithoutInvoiceInput[] | FileUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: FileCreateOrConnectWithoutInvoiceInput | FileCreateOrConnectWithoutInvoiceInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutInvoiceInput | FileUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: FileCreateManyInvoiceInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutInvoiceInput | FileUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: FileUpdateManyWithWhereWithoutInvoiceInput | FileUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type LeaseUpdateOneWithoutInvoiceNestedInput = {
    create?: XOR<LeaseCreateWithoutInvoiceInput, LeaseUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: LeaseCreateOrConnectWithoutInvoiceInput
    upsert?: LeaseUpsertWithoutInvoiceInput
    disconnect?: LeaseWhereInput | boolean
    delete?: LeaseWhereInput | boolean
    connect?: LeaseWhereUniqueInput
    update?: XOR<XOR<LeaseUpdateToOneWithWhereWithoutInvoiceInput, LeaseUpdateWithoutInvoiceInput>, LeaseUncheckedUpdateWithoutInvoiceInput>
  }

  export type TenantUpdateOneRequiredWithoutInvoiceNestedInput = {
    create?: XOR<TenantCreateWithoutInvoiceInput, TenantUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: TenantCreateOrConnectWithoutInvoiceInput
    upsert?: TenantUpsertWithoutInvoiceInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutInvoiceInput, TenantUpdateWithoutInvoiceInput>, TenantUncheckedUpdateWithoutInvoiceInput>
  }

  export type TransactionsUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<TransactionsCreateWithoutInvoiceInput, TransactionsUncheckedCreateWithoutInvoiceInput> | TransactionsCreateWithoutInvoiceInput[] | TransactionsUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutInvoiceInput | TransactionsCreateOrConnectWithoutInvoiceInput[]
    upsert?: TransactionsUpsertWithWhereUniqueWithoutInvoiceInput | TransactionsUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: TransactionsCreateManyInvoiceInputEnvelope
    set?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    disconnect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    delete?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    update?: TransactionsUpdateWithWhereUniqueWithoutInvoiceInput | TransactionsUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: TransactionsUpdateManyWithWhereWithoutInvoiceInput | TransactionsUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: TransactionsScalarWhereInput | TransactionsScalarWhereInput[]
  }

  export type RecurringBillableUpdateOneWithoutInvoiceNestedInput = {
    create?: XOR<RecurringBillableCreateWithoutInvoiceInput, RecurringBillableUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: RecurringBillableCreateOrConnectWithoutInvoiceInput
    upsert?: RecurringBillableUpsertWithoutInvoiceInput
    disconnect?: RecurringBillableWhereInput | boolean
    delete?: RecurringBillableWhereInput | boolean
    connect?: RecurringBillableWhereUniqueInput
    update?: XOR<XOR<RecurringBillableUpdateToOneWithWhereWithoutInvoiceInput, RecurringBillableUpdateWithoutInvoiceInput>, RecurringBillableUncheckedUpdateWithoutInvoiceInput>
  }

  export type UserUpdateOneRequiredWithoutInvoiceNestedInput = {
    create?: XOR<UserCreateWithoutInvoiceInput, UserUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvoiceInput
    upsert?: UserUpsertWithoutInvoiceInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvoiceInput, UserUpdateWithoutInvoiceInput>, UserUncheckedUpdateWithoutInvoiceInput>
  }

  export type FileUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<FileCreateWithoutInvoiceInput, FileUncheckedCreateWithoutInvoiceInput> | FileCreateWithoutInvoiceInput[] | FileUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: FileCreateOrConnectWithoutInvoiceInput | FileCreateOrConnectWithoutInvoiceInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutInvoiceInput | FileUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: FileCreateManyInvoiceInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutInvoiceInput | FileUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: FileUpdateManyWithWhereWithoutInvoiceInput | FileUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type TransactionsUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<TransactionsCreateWithoutInvoiceInput, TransactionsUncheckedCreateWithoutInvoiceInput> | TransactionsCreateWithoutInvoiceInput[] | TransactionsUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutInvoiceInput | TransactionsCreateOrConnectWithoutInvoiceInput[]
    upsert?: TransactionsUpsertWithWhereUniqueWithoutInvoiceInput | TransactionsUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: TransactionsCreateManyInvoiceInputEnvelope
    set?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    disconnect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    delete?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    update?: TransactionsUpdateWithWhereUniqueWithoutInvoiceInput | TransactionsUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: TransactionsUpdateManyWithWhereWithoutInvoiceInput | TransactionsUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: TransactionsScalarWhereInput | TransactionsScalarWhereInput[]
  }

  export type LeaseCreateNestedOneWithoutRecurringBillableInput = {
    create?: XOR<LeaseCreateWithoutRecurringBillableInput, LeaseUncheckedCreateWithoutRecurringBillableInput>
    connectOrCreate?: LeaseCreateOrConnectWithoutRecurringBillableInput
    connect?: LeaseWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutRecurringBillableInput = {
    create?: XOR<TenantCreateWithoutRecurringBillableInput, TenantUncheckedCreateWithoutRecurringBillableInput>
    connectOrCreate?: TenantCreateOrConnectWithoutRecurringBillableInput
    connect?: TenantWhereUniqueInput
  }

  export type InvoiceCreateNestedManyWithoutRecurringBillableInput = {
    create?: XOR<InvoiceCreateWithoutRecurringBillableInput, InvoiceUncheckedCreateWithoutRecurringBillableInput> | InvoiceCreateWithoutRecurringBillableInput[] | InvoiceUncheckedCreateWithoutRecurringBillableInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutRecurringBillableInput | InvoiceCreateOrConnectWithoutRecurringBillableInput[]
    createMany?: InvoiceCreateManyRecurringBillableInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type PropertyCreateNestedOneWithoutRecurringBillableInput = {
    create?: XOR<PropertyCreateWithoutRecurringBillableInput, PropertyUncheckedCreateWithoutRecurringBillableInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutRecurringBillableInput
    connect?: PropertyWhereUniqueInput
  }

  export type InvoiceUncheckedCreateNestedManyWithoutRecurringBillableInput = {
    create?: XOR<InvoiceCreateWithoutRecurringBillableInput, InvoiceUncheckedCreateWithoutRecurringBillableInput> | InvoiceCreateWithoutRecurringBillableInput[] | InvoiceUncheckedCreateWithoutRecurringBillableInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutRecurringBillableInput | InvoiceCreateOrConnectWithoutRecurringBillableInput[]
    createMany?: InvoiceCreateManyRecurringBillableInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type LeaseUpdateOneWithoutRecurringBillableNestedInput = {
    create?: XOR<LeaseCreateWithoutRecurringBillableInput, LeaseUncheckedCreateWithoutRecurringBillableInput>
    connectOrCreate?: LeaseCreateOrConnectWithoutRecurringBillableInput
    upsert?: LeaseUpsertWithoutRecurringBillableInput
    disconnect?: LeaseWhereInput | boolean
    delete?: LeaseWhereInput | boolean
    connect?: LeaseWhereUniqueInput
    update?: XOR<XOR<LeaseUpdateToOneWithWhereWithoutRecurringBillableInput, LeaseUpdateWithoutRecurringBillableInput>, LeaseUncheckedUpdateWithoutRecurringBillableInput>
  }

  export type TenantUpdateOneRequiredWithoutRecurringBillableNestedInput = {
    create?: XOR<TenantCreateWithoutRecurringBillableInput, TenantUncheckedCreateWithoutRecurringBillableInput>
    connectOrCreate?: TenantCreateOrConnectWithoutRecurringBillableInput
    upsert?: TenantUpsertWithoutRecurringBillableInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutRecurringBillableInput, TenantUpdateWithoutRecurringBillableInput>, TenantUncheckedUpdateWithoutRecurringBillableInput>
  }

  export type InvoiceUpdateManyWithoutRecurringBillableNestedInput = {
    create?: XOR<InvoiceCreateWithoutRecurringBillableInput, InvoiceUncheckedCreateWithoutRecurringBillableInput> | InvoiceCreateWithoutRecurringBillableInput[] | InvoiceUncheckedCreateWithoutRecurringBillableInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutRecurringBillableInput | InvoiceCreateOrConnectWithoutRecurringBillableInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutRecurringBillableInput | InvoiceUpsertWithWhereUniqueWithoutRecurringBillableInput[]
    createMany?: InvoiceCreateManyRecurringBillableInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutRecurringBillableInput | InvoiceUpdateWithWhereUniqueWithoutRecurringBillableInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutRecurringBillableInput | InvoiceUpdateManyWithWhereWithoutRecurringBillableInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PropertyUpdateOneWithoutRecurringBillableNestedInput = {
    create?: XOR<PropertyCreateWithoutRecurringBillableInput, PropertyUncheckedCreateWithoutRecurringBillableInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutRecurringBillableInput
    upsert?: PropertyUpsertWithoutRecurringBillableInput
    disconnect?: PropertyWhereInput | boolean
    delete?: PropertyWhereInput | boolean
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutRecurringBillableInput, PropertyUpdateWithoutRecurringBillableInput>, PropertyUncheckedUpdateWithoutRecurringBillableInput>
  }

  export type InvoiceUncheckedUpdateManyWithoutRecurringBillableNestedInput = {
    create?: XOR<InvoiceCreateWithoutRecurringBillableInput, InvoiceUncheckedCreateWithoutRecurringBillableInput> | InvoiceCreateWithoutRecurringBillableInput[] | InvoiceUncheckedCreateWithoutRecurringBillableInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutRecurringBillableInput | InvoiceCreateOrConnectWithoutRecurringBillableInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutRecurringBillableInput | InvoiceUpsertWithWhereUniqueWithoutRecurringBillableInput[]
    createMany?: InvoiceCreateManyRecurringBillableInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutRecurringBillableInput | InvoiceUpdateWithWhereUniqueWithoutRecurringBillableInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutRecurringBillableInput | InvoiceUpdateManyWithWhereWithoutRecurringBillableInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type InvoiceCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<InvoiceCreateWithoutTransactionsInput, InvoiceUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutTransactionsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type LeaseCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<LeaseCreateWithoutTransactionsInput, LeaseUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: LeaseCreateOrConnectWithoutTransactionsInput
    connect?: LeaseWhereUniqueInput
  }

  export type InvoiceUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<InvoiceCreateWithoutTransactionsInput, InvoiceUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutTransactionsInput
    upsert?: InvoiceUpsertWithoutTransactionsInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutTransactionsInput, InvoiceUpdateWithoutTransactionsInput>, InvoiceUncheckedUpdateWithoutTransactionsInput>
  }

  export type LeaseUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<LeaseCreateWithoutTransactionsInput, LeaseUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: LeaseCreateOrConnectWithoutTransactionsInput
    upsert?: LeaseUpsertWithoutTransactionsInput
    disconnect?: LeaseWhereInput | boolean
    delete?: LeaseWhereInput | boolean
    connect?: LeaseWhereUniqueInput
    update?: XOR<XOR<LeaseUpdateToOneWithWhereWithoutTransactionsInput, LeaseUpdateWithoutTransactionsInput>, LeaseUncheckedUpdateWithoutTransactionsInput>
  }

  export type LeaseCreateNestedOneWithoutTenantLeaseInput = {
    create?: XOR<LeaseCreateWithoutTenantLeaseInput, LeaseUncheckedCreateWithoutTenantLeaseInput>
    connectOrCreate?: LeaseCreateOrConnectWithoutTenantLeaseInput
    connect?: LeaseWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutTenantLeaseInput = {
    create?: XOR<TenantCreateWithoutTenantLeaseInput, TenantUncheckedCreateWithoutTenantLeaseInput>
    connectOrCreate?: TenantCreateOrConnectWithoutTenantLeaseInput
    connect?: TenantWhereUniqueInput
  }

  export type LeaseUpdateOneRequiredWithoutTenantLeaseNestedInput = {
    create?: XOR<LeaseCreateWithoutTenantLeaseInput, LeaseUncheckedCreateWithoutTenantLeaseInput>
    connectOrCreate?: LeaseCreateOrConnectWithoutTenantLeaseInput
    upsert?: LeaseUpsertWithoutTenantLeaseInput
    connect?: LeaseWhereUniqueInput
    update?: XOR<XOR<LeaseUpdateToOneWithWhereWithoutTenantLeaseInput, LeaseUpdateWithoutTenantLeaseInput>, LeaseUncheckedUpdateWithoutTenantLeaseInput>
  }

  export type TenantUpdateOneRequiredWithoutTenantLeaseNestedInput = {
    create?: XOR<TenantCreateWithoutTenantLeaseInput, TenantUncheckedCreateWithoutTenantLeaseInput>
    connectOrCreate?: TenantCreateOrConnectWithoutTenantLeaseInput
    upsert?: TenantUpsertWithoutTenantLeaseInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutTenantLeaseInput, TenantUpdateWithoutTenantLeaseInput>, TenantUncheckedUpdateWithoutTenantLeaseInput>
  }

  export type FileCreateNestedManyWithoutMaintenanceRequestInput = {
    create?: XOR<FileCreateWithoutMaintenanceRequestInput, FileUncheckedCreateWithoutMaintenanceRequestInput> | FileCreateWithoutMaintenanceRequestInput[] | FileUncheckedCreateWithoutMaintenanceRequestInput[]
    connectOrCreate?: FileCreateOrConnectWithoutMaintenanceRequestInput | FileCreateOrConnectWithoutMaintenanceRequestInput[]
    createMany?: FileCreateManyMaintenanceRequestInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type LeaseCreateNestedOneWithoutMaintenanceRequestInput = {
    create?: XOR<LeaseCreateWithoutMaintenanceRequestInput, LeaseUncheckedCreateWithoutMaintenanceRequestInput>
    connectOrCreate?: LeaseCreateOrConnectWithoutMaintenanceRequestInput
    connect?: LeaseWhereUniqueInput
  }

  export type FileUncheckedCreateNestedManyWithoutMaintenanceRequestInput = {
    create?: XOR<FileCreateWithoutMaintenanceRequestInput, FileUncheckedCreateWithoutMaintenanceRequestInput> | FileCreateWithoutMaintenanceRequestInput[] | FileUncheckedCreateWithoutMaintenanceRequestInput[]
    connectOrCreate?: FileCreateOrConnectWithoutMaintenanceRequestInput | FileCreateOrConnectWithoutMaintenanceRequestInput[]
    createMany?: FileCreateManyMaintenanceRequestInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type NullableEnumMaintenanceRequestStatusFieldUpdateOperationsInput = {
    set?: $Enums.MaintenanceRequestStatus | null
  }

  export type EnumMaintenanceRequestPriorityFieldUpdateOperationsInput = {
    set?: $Enums.MaintenanceRequestPriority
  }

  export type FileUpdateManyWithoutMaintenanceRequestNestedInput = {
    create?: XOR<FileCreateWithoutMaintenanceRequestInput, FileUncheckedCreateWithoutMaintenanceRequestInput> | FileCreateWithoutMaintenanceRequestInput[] | FileUncheckedCreateWithoutMaintenanceRequestInput[]
    connectOrCreate?: FileCreateOrConnectWithoutMaintenanceRequestInput | FileCreateOrConnectWithoutMaintenanceRequestInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutMaintenanceRequestInput | FileUpsertWithWhereUniqueWithoutMaintenanceRequestInput[]
    createMany?: FileCreateManyMaintenanceRequestInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutMaintenanceRequestInput | FileUpdateWithWhereUniqueWithoutMaintenanceRequestInput[]
    updateMany?: FileUpdateManyWithWhereWithoutMaintenanceRequestInput | FileUpdateManyWithWhereWithoutMaintenanceRequestInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type LeaseUpdateOneRequiredWithoutMaintenanceRequestNestedInput = {
    create?: XOR<LeaseCreateWithoutMaintenanceRequestInput, LeaseUncheckedCreateWithoutMaintenanceRequestInput>
    connectOrCreate?: LeaseCreateOrConnectWithoutMaintenanceRequestInput
    upsert?: LeaseUpsertWithoutMaintenanceRequestInput
    connect?: LeaseWhereUniqueInput
    update?: XOR<XOR<LeaseUpdateToOneWithWhereWithoutMaintenanceRequestInput, LeaseUpdateWithoutMaintenanceRequestInput>, LeaseUncheckedUpdateWithoutMaintenanceRequestInput>
  }

  export type FileUncheckedUpdateManyWithoutMaintenanceRequestNestedInput = {
    create?: XOR<FileCreateWithoutMaintenanceRequestInput, FileUncheckedCreateWithoutMaintenanceRequestInput> | FileCreateWithoutMaintenanceRequestInput[] | FileUncheckedCreateWithoutMaintenanceRequestInput[]
    connectOrCreate?: FileCreateOrConnectWithoutMaintenanceRequestInput | FileCreateOrConnectWithoutMaintenanceRequestInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutMaintenanceRequestInput | FileUpsertWithWhereUniqueWithoutMaintenanceRequestInput[]
    createMany?: FileCreateManyMaintenanceRequestInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutMaintenanceRequestInput | FileUpdateWithWhereUniqueWithoutMaintenanceRequestInput[]
    updateMany?: FileUpdateManyWithWhereWithoutMaintenanceRequestInput | FileUpdateManyWithWhereWithoutMaintenanceRequestInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type InvoiceCreateNestedOneWithoutFileInput = {
    create?: XOR<InvoiceCreateWithoutFileInput, InvoiceUncheckedCreateWithoutFileInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutFileInput
    connect?: InvoiceWhereUniqueInput
  }

  export type LeaseCreateNestedOneWithoutFileInput = {
    create?: XOR<LeaseCreateWithoutFileInput, LeaseUncheckedCreateWithoutFileInput>
    connectOrCreate?: LeaseCreateOrConnectWithoutFileInput
    connect?: LeaseWhereUniqueInput
  }

  export type MaintenanceRequestCreateNestedOneWithoutFileInput = {
    create?: XOR<MaintenanceRequestCreateWithoutFileInput, MaintenanceRequestUncheckedCreateWithoutFileInput>
    connectOrCreate?: MaintenanceRequestCreateOrConnectWithoutFileInput
    connect?: MaintenanceRequestWhereUniqueInput
  }

  export type PropertyCreateNestedOneWithoutFilesInput = {
    create?: XOR<PropertyCreateWithoutFilesInput, PropertyUncheckedCreateWithoutFilesInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutFilesInput
    connect?: PropertyWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutFilesInput = {
    create?: XOR<TenantCreateWithoutFilesInput, TenantUncheckedCreateWithoutFilesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutFilesInput
    connect?: TenantWhereUniqueInput
  }

  export type InvoiceUpdateOneWithoutFileNestedInput = {
    create?: XOR<InvoiceCreateWithoutFileInput, InvoiceUncheckedCreateWithoutFileInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutFileInput
    upsert?: InvoiceUpsertWithoutFileInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutFileInput, InvoiceUpdateWithoutFileInput>, InvoiceUncheckedUpdateWithoutFileInput>
  }

  export type LeaseUpdateOneWithoutFileNestedInput = {
    create?: XOR<LeaseCreateWithoutFileInput, LeaseUncheckedCreateWithoutFileInput>
    connectOrCreate?: LeaseCreateOrConnectWithoutFileInput
    upsert?: LeaseUpsertWithoutFileInput
    disconnect?: LeaseWhereInput | boolean
    delete?: LeaseWhereInput | boolean
    connect?: LeaseWhereUniqueInput
    update?: XOR<XOR<LeaseUpdateToOneWithWhereWithoutFileInput, LeaseUpdateWithoutFileInput>, LeaseUncheckedUpdateWithoutFileInput>
  }

  export type MaintenanceRequestUpdateOneWithoutFileNestedInput = {
    create?: XOR<MaintenanceRequestCreateWithoutFileInput, MaintenanceRequestUncheckedCreateWithoutFileInput>
    connectOrCreate?: MaintenanceRequestCreateOrConnectWithoutFileInput
    upsert?: MaintenanceRequestUpsertWithoutFileInput
    disconnect?: MaintenanceRequestWhereInput | boolean
    delete?: MaintenanceRequestWhereInput | boolean
    connect?: MaintenanceRequestWhereUniqueInput
    update?: XOR<XOR<MaintenanceRequestUpdateToOneWithWhereWithoutFileInput, MaintenanceRequestUpdateWithoutFileInput>, MaintenanceRequestUncheckedUpdateWithoutFileInput>
  }

  export type PropertyUpdateOneWithoutFilesNestedInput = {
    create?: XOR<PropertyCreateWithoutFilesInput, PropertyUncheckedCreateWithoutFilesInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutFilesInput
    upsert?: PropertyUpsertWithoutFilesInput
    disconnect?: PropertyWhereInput | boolean
    delete?: PropertyWhereInput | boolean
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutFilesInput, PropertyUpdateWithoutFilesInput>, PropertyUncheckedUpdateWithoutFilesInput>
  }

  export type TenantUpdateOneWithoutFilesNestedInput = {
    create?: XOR<TenantCreateWithoutFilesInput, TenantUncheckedCreateWithoutFilesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutFilesInput
    upsert?: TenantUpsertWithoutFilesInput
    disconnect?: TenantWhereInput | boolean
    delete?: TenantWhereInput | boolean
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutFilesInput, TenantUpdateWithoutFilesInput>, TenantUncheckedUpdateWithoutFilesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumPropertyStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyStatus | EnumPropertyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyStatusFilter<$PrismaModel> | $Enums.PropertyStatus
  }

  export type NestedEnumPropertyTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyType | EnumPropertyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyTypeFilter<$PrismaModel> | $Enums.PropertyType
  }

  export type NestedEnumPropertyStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyStatus | EnumPropertyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyStatusWithAggregatesFilter<$PrismaModel> | $Enums.PropertyStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPropertyStatusFilter<$PrismaModel>
    _max?: NestedEnumPropertyStatusFilter<$PrismaModel>
  }

  export type NestedEnumPropertyTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyType | EnumPropertyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyTypeWithAggregatesFilter<$PrismaModel> | $Enums.PropertyType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPropertyTypeFilter<$PrismaModel>
    _max?: NestedEnumPropertyTypeFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumLeaseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaseStatus | EnumLeaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaseStatus[] | ListEnumLeaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaseStatus[] | ListEnumLeaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaseStatusFilter<$PrismaModel> | $Enums.LeaseStatus
  }

  export type NestedEnumInvoiceCycleFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceCycle | EnumInvoiceCycleFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceCycle[] | ListEnumInvoiceCycleFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceCycle[] | ListEnumInvoiceCycleFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceCycleFilter<$PrismaModel> | $Enums.InvoiceCycle
  }

  export type NestedEnumLeaseTermTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaseTermType | EnumLeaseTermTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LeaseTermType[] | ListEnumLeaseTermTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaseTermType[] | ListEnumLeaseTermTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaseTermTypeFilter<$PrismaModel> | $Enums.LeaseTermType
  }

  export type NestedEnumLeaseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaseStatus | EnumLeaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaseStatus[] | ListEnumLeaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaseStatus[] | ListEnumLeaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaseStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeaseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaseStatusFilter<$PrismaModel>
    _max?: NestedEnumLeaseStatusFilter<$PrismaModel>
  }

  export type NestedEnumInvoiceCycleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceCycle | EnumInvoiceCycleFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceCycle[] | ListEnumInvoiceCycleFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceCycle[] | ListEnumInvoiceCycleFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceCycleWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceCycle
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceCycleFilter<$PrismaModel>
    _max?: NestedEnumInvoiceCycleFilter<$PrismaModel>
  }

  export type NestedEnumLeaseTermTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaseTermType | EnumLeaseTermTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LeaseTermType[] | ListEnumLeaseTermTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaseTermType[] | ListEnumLeaseTermTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaseTermTypeWithAggregatesFilter<$PrismaModel> | $Enums.LeaseTermType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaseTermTypeFilter<$PrismaModel>
    _max?: NestedEnumLeaseTermTypeFilter<$PrismaModel>
  }

  export type NestedEnumInvoiceCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceCategory | EnumInvoiceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceCategory[] | ListEnumInvoiceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceCategory[] | ListEnumInvoiceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceCategoryFilter<$PrismaModel> | $Enums.InvoiceCategory
  }

  export type NestedEnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type NestedEnumInvoiceCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceCategory | EnumInvoiceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceCategory[] | ListEnumInvoiceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceCategory[] | ListEnumInvoiceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceCategoryWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceCategoryFilter<$PrismaModel>
    _max?: NestedEnumInvoiceCategoryFilter<$PrismaModel>
  }

  export type NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type NestedEnumMaintenanceRequestStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenanceRequestStatus | EnumMaintenanceRequestStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.MaintenanceRequestStatus[] | ListEnumMaintenanceRequestStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MaintenanceRequestStatus[] | ListEnumMaintenanceRequestStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMaintenanceRequestStatusNullableFilter<$PrismaModel> | $Enums.MaintenanceRequestStatus | null
  }

  export type NestedEnumMaintenanceRequestPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenanceRequestPriority | EnumMaintenanceRequestPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.MaintenanceRequestPriority[] | ListEnumMaintenanceRequestPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaintenanceRequestPriority[] | ListEnumMaintenanceRequestPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumMaintenanceRequestPriorityFilter<$PrismaModel> | $Enums.MaintenanceRequestPriority
  }

  export type NestedEnumMaintenanceRequestStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenanceRequestStatus | EnumMaintenanceRequestStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.MaintenanceRequestStatus[] | ListEnumMaintenanceRequestStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MaintenanceRequestStatus[] | ListEnumMaintenanceRequestStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMaintenanceRequestStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.MaintenanceRequestStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumMaintenanceRequestStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumMaintenanceRequestStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumMaintenanceRequestPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenanceRequestPriority | EnumMaintenanceRequestPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.MaintenanceRequestPriority[] | ListEnumMaintenanceRequestPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaintenanceRequestPriority[] | ListEnumMaintenanceRequestPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumMaintenanceRequestPriorityWithAggregatesFilter<$PrismaModel> | $Enums.MaintenanceRequestPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMaintenanceRequestPriorityFilter<$PrismaModel>
    _max?: NestedEnumMaintenanceRequestPriorityFilter<$PrismaModel>
  }

  export type AccountCreateWithoutUserInput = {
    id: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PropertyCreateWithoutLandlordInput = {
    id?: string
    name: string
    addressLine1: string
    addressLine2?: string | null
    city: string
    state: string
    zip: string
    createdAt?: Date | string
    updatedAt?: Date | string
    imageUrl?: string | null
    propertyStatus?: $Enums.PropertyStatus
    propertyType?: $Enums.PropertyType
    amenities?: PropertyCreateamenitiesInput | string[]
    countryCode?: string
    features?: PropertyCreatefeaturesInput | string[]
    files?: FileCreateNestedManyWithoutPropertyInput
    unit?: UnitCreateNestedManyWithoutPropertyInput
    recurringBillable?: RecurringBillableCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutLandlordInput = {
    id?: string
    name: string
    addressLine1: string
    addressLine2?: string | null
    city: string
    state: string
    zip: string
    createdAt?: Date | string
    updatedAt?: Date | string
    imageUrl?: string | null
    propertyStatus?: $Enums.PropertyStatus
    propertyType?: $Enums.PropertyType
    amenities?: PropertyCreateamenitiesInput | string[]
    countryCode?: string
    features?: PropertyCreatefeaturesInput | string[]
    files?: FileUncheckedCreateNestedManyWithoutPropertyInput
    unit?: UnitUncheckedCreateNestedManyWithoutPropertyInput
    recurringBillable?: RecurringBillableUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutLandlordInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutLandlordInput, PropertyUncheckedCreateWithoutLandlordInput>
  }

  export type PropertyCreateManyLandlordInputEnvelope = {
    data: PropertyCreateManyLandlordInput | PropertyCreateManyLandlordInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TenantCreateWithoutLandlordInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    firstName: string
    lastName: string
    phone: string
    dateOfBirth?: Date | string | null
    tenantEmergencyContact?: NullableJsonNullValueInput | InputJsonValue
    tenantIncome?: NullableJsonNullValueInput | InputJsonValue
    additionalEmails?: TenantCreateadditionalEmailsInput | string[]
    additionalPhones?: TenantCreateadditionalPhonesInput | string[]
    emergencyContacts?: NullableJsonNullValueInput | InputJsonValue
    vehicles?: NullableJsonNullValueInput | InputJsonValue
    avatarUrl?: string | null
    fullName?: string | null
    paystackCustomerId?: string | null
    files?: FileCreateNestedManyWithoutTenantInput
    Invoice?: InvoiceCreateNestedManyWithoutTenantInput
    tenantLease?: TenantLeaseCreateNestedManyWithoutTenantInput
    recurringBillable?: RecurringBillableCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutLandlordInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    firstName: string
    lastName: string
    phone: string
    dateOfBirth?: Date | string | null
    tenantEmergencyContact?: NullableJsonNullValueInput | InputJsonValue
    tenantIncome?: NullableJsonNullValueInput | InputJsonValue
    additionalEmails?: TenantCreateadditionalEmailsInput | string[]
    additionalPhones?: TenantCreateadditionalPhonesInput | string[]
    emergencyContacts?: NullableJsonNullValueInput | InputJsonValue
    vehicles?: NullableJsonNullValueInput | InputJsonValue
    avatarUrl?: string | null
    fullName?: string | null
    paystackCustomerId?: string | null
    files?: FileUncheckedCreateNestedManyWithoutTenantInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    tenantLease?: TenantLeaseUncheckedCreateNestedManyWithoutTenantInput
    recurringBillable?: RecurringBillableUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutLandlordInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutLandlordInput, TenantUncheckedCreateWithoutLandlordInput>
  }

  export type TenantCreateManyLandlordInputEnvelope = {
    data: TenantCreateManyLandlordInput | TenantCreateManyLandlordInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutLandlordInput = {
    id?: string
    description: string
    dueAmount: number
    category: $Enums.InvoiceCategory
    status: $Enums.InvoiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paystackId: string
    dueDate?: Date | string | null
    lineItems?: NullableJsonNullValueInput | InputJsonValue
    File?: FileCreateNestedManyWithoutInvoiceInput
    lease?: LeaseCreateNestedOneWithoutInvoiceInput
    tenant: TenantCreateNestedOneWithoutInvoiceInput
    transactions?: TransactionsCreateNestedManyWithoutInvoiceInput
    recurringBillable?: RecurringBillableCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutLandlordInput = {
    id?: string
    leaseId?: string | null
    description: string
    dueAmount: number
    category: $Enums.InvoiceCategory
    status: $Enums.InvoiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paystackId: string
    dueDate?: Date | string | null
    lineItems?: NullableJsonNullValueInput | InputJsonValue
    tenantId: string
    recurringBillableId?: string | null
    File?: FileUncheckedCreateNestedManyWithoutInvoiceInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutLandlordInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutLandlordInput, InvoiceUncheckedCreateWithoutLandlordInput>
  }

  export type InvoiceCreateManyLandlordInputEnvelope = {
    data: InvoiceCreateManyLandlordInput | InvoiceCreateManyLandlordInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
  }

  export type PropertyUpsertWithWhereUniqueWithoutLandlordInput = {
    where: PropertyWhereUniqueInput
    update: XOR<PropertyUpdateWithoutLandlordInput, PropertyUncheckedUpdateWithoutLandlordInput>
    create: XOR<PropertyCreateWithoutLandlordInput, PropertyUncheckedCreateWithoutLandlordInput>
  }

  export type PropertyUpdateWithWhereUniqueWithoutLandlordInput = {
    where: PropertyWhereUniqueInput
    data: XOR<PropertyUpdateWithoutLandlordInput, PropertyUncheckedUpdateWithoutLandlordInput>
  }

  export type PropertyUpdateManyWithWhereWithoutLandlordInput = {
    where: PropertyScalarWhereInput
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyWithoutLandlordInput>
  }

  export type PropertyScalarWhereInput = {
    AND?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
    OR?: PropertyScalarWhereInput[]
    NOT?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
    id?: StringFilter<"Property"> | string
    name?: StringFilter<"Property"> | string
    addressLine1?: StringFilter<"Property"> | string
    addressLine2?: StringNullableFilter<"Property"> | string | null
    city?: StringFilter<"Property"> | string
    state?: StringFilter<"Property"> | string
    zip?: StringFilter<"Property"> | string
    createdAt?: DateTimeFilter<"Property"> | Date | string
    updatedAt?: DateTimeFilter<"Property"> | Date | string
    imageUrl?: StringNullableFilter<"Property"> | string | null
    propertyStatus?: EnumPropertyStatusFilter<"Property"> | $Enums.PropertyStatus
    propertyType?: EnumPropertyTypeFilter<"Property"> | $Enums.PropertyType
    amenities?: StringNullableListFilter<"Property">
    countryCode?: StringFilter<"Property"> | string
    features?: StringNullableListFilter<"Property">
    landlordId?: StringFilter<"Property"> | string
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    token?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
  }

  export type TenantUpsertWithWhereUniqueWithoutLandlordInput = {
    where: TenantWhereUniqueInput
    update: XOR<TenantUpdateWithoutLandlordInput, TenantUncheckedUpdateWithoutLandlordInput>
    create: XOR<TenantCreateWithoutLandlordInput, TenantUncheckedCreateWithoutLandlordInput>
  }

  export type TenantUpdateWithWhereUniqueWithoutLandlordInput = {
    where: TenantWhereUniqueInput
    data: XOR<TenantUpdateWithoutLandlordInput, TenantUncheckedUpdateWithoutLandlordInput>
  }

  export type TenantUpdateManyWithWhereWithoutLandlordInput = {
    where: TenantScalarWhereInput
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyWithoutLandlordInput>
  }

  export type TenantScalarWhereInput = {
    AND?: TenantScalarWhereInput | TenantScalarWhereInput[]
    OR?: TenantScalarWhereInput[]
    NOT?: TenantScalarWhereInput | TenantScalarWhereInput[]
    id?: StringFilter<"Tenant"> | string
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    email?: StringFilter<"Tenant"> | string
    firstName?: StringFilter<"Tenant"> | string
    lastName?: StringFilter<"Tenant"> | string
    phone?: StringFilter<"Tenant"> | string
    landlordId?: StringFilter<"Tenant"> | string
    dateOfBirth?: DateTimeNullableFilter<"Tenant"> | Date | string | null
    tenantEmergencyContact?: JsonNullableFilter<"Tenant">
    tenantIncome?: JsonNullableFilter<"Tenant">
    additionalEmails?: StringNullableListFilter<"Tenant">
    additionalPhones?: StringNullableListFilter<"Tenant">
    emergencyContacts?: JsonNullableFilter<"Tenant">
    vehicles?: JsonNullableFilter<"Tenant">
    avatarUrl?: StringNullableFilter<"Tenant"> | string | null
    fullName?: StringNullableFilter<"Tenant"> | string | null
    paystackCustomerId?: StringNullableFilter<"Tenant"> | string | null
  }

  export type InvoiceUpsertWithWhereUniqueWithoutLandlordInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutLandlordInput, InvoiceUncheckedUpdateWithoutLandlordInput>
    create: XOR<InvoiceCreateWithoutLandlordInput, InvoiceUncheckedCreateWithoutLandlordInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutLandlordInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutLandlordInput, InvoiceUncheckedUpdateWithoutLandlordInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutLandlordInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutLandlordInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: StringFilter<"Invoice"> | string
    leaseId?: StringNullableFilter<"Invoice"> | string | null
    description?: StringFilter<"Invoice"> | string
    dueAmount?: FloatFilter<"Invoice"> | number
    category?: EnumInvoiceCategoryFilter<"Invoice"> | $Enums.InvoiceCategory
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    paystackId?: StringFilter<"Invoice"> | string
    dueDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    lineItems?: JsonNullableFilter<"Invoice">
    landlordId?: StringFilter<"Invoice"> | string
    tenantId?: StringFilter<"Invoice"> | string
    recurringBillableId?: StringNullableFilter<"Invoice"> | string | null
  }

  export type UserCreateWithoutSessionsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    idNumber?: string | null
    paystackSplitGroupId?: string | null
    paystackSubAccountId?: string | null
    paystackSubscriptionId?: string | null
    state?: string | null
    zip?: string | null
    onboardingCompleted?: boolean
    businessName?: string | null
    countryCode?: string | null
    numberOfProperties?: number | null
    numberOfUnits?: number | null
    phone?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    property?: PropertyCreateNestedManyWithoutLandlordInput
    tenant?: TenantCreateNestedManyWithoutLandlordInput
    Invoice?: InvoiceCreateNestedManyWithoutLandlordInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    idNumber?: string | null
    paystackSplitGroupId?: string | null
    paystackSubAccountId?: string | null
    paystackSubscriptionId?: string | null
    state?: string | null
    zip?: string | null
    onboardingCompleted?: boolean
    businessName?: string | null
    countryCode?: string | null
    numberOfProperties?: number | null
    numberOfUnits?: number | null
    phone?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    property?: PropertyUncheckedCreateNestedManyWithoutLandlordInput
    tenant?: TenantUncheckedCreateNestedManyWithoutLandlordInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutLandlordInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSplitGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfProperties?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfUnits?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    property?: PropertyUpdateManyWithoutLandlordNestedInput
    tenant?: TenantUpdateManyWithoutLandlordNestedInput
    Invoice?: InvoiceUpdateManyWithoutLandlordNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSplitGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfProperties?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfUnits?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    property?: PropertyUncheckedUpdateManyWithoutLandlordNestedInput
    tenant?: TenantUncheckedUpdateManyWithoutLandlordNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutLandlordNestedInput
  }

  export type UserCreateWithoutAccountsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    idNumber?: string | null
    paystackSplitGroupId?: string | null
    paystackSubAccountId?: string | null
    paystackSubscriptionId?: string | null
    state?: string | null
    zip?: string | null
    onboardingCompleted?: boolean
    businessName?: string | null
    countryCode?: string | null
    numberOfProperties?: number | null
    numberOfUnits?: number | null
    phone?: string | null
    property?: PropertyCreateNestedManyWithoutLandlordInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    tenant?: TenantCreateNestedManyWithoutLandlordInput
    Invoice?: InvoiceCreateNestedManyWithoutLandlordInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    idNumber?: string | null
    paystackSplitGroupId?: string | null
    paystackSubAccountId?: string | null
    paystackSubscriptionId?: string | null
    state?: string | null
    zip?: string | null
    onboardingCompleted?: boolean
    businessName?: string | null
    countryCode?: string | null
    numberOfProperties?: number | null
    numberOfUnits?: number | null
    phone?: string | null
    property?: PropertyUncheckedCreateNestedManyWithoutLandlordInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    tenant?: TenantUncheckedCreateNestedManyWithoutLandlordInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutLandlordInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSplitGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfProperties?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfUnits?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    property?: PropertyUpdateManyWithoutLandlordNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    tenant?: TenantUpdateManyWithoutLandlordNestedInput
    Invoice?: InvoiceUpdateManyWithoutLandlordNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSplitGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfProperties?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfUnits?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    property?: PropertyUncheckedUpdateManyWithoutLandlordNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    tenant?: TenantUncheckedUpdateManyWithoutLandlordNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutLandlordNestedInput
  }

  export type FileCreateWithoutTenantInput = {
    id?: string
    name: string
    url: string
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    size?: number | null
    type?: string | null
    invoice?: InvoiceCreateNestedOneWithoutFileInput
    lease?: LeaseCreateNestedOneWithoutFileInput
    maintenanceRequest?: MaintenanceRequestCreateNestedOneWithoutFileInput
    property?: PropertyCreateNestedOneWithoutFilesInput
  }

  export type FileUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    url: string
    ownerId: string
    propertyId?: string | null
    leaseId?: string | null
    invoiceId?: string | null
    maintenanceRequestId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    size?: number | null
    type?: string | null
  }

  export type FileCreateOrConnectWithoutTenantInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutTenantInput, FileUncheckedCreateWithoutTenantInput>
  }

  export type FileCreateManyTenantInputEnvelope = {
    data: FileCreateManyTenantInput | FileCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutTenantInput = {
    id?: string
    description: string
    dueAmount: number
    category: $Enums.InvoiceCategory
    status: $Enums.InvoiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paystackId: string
    dueDate?: Date | string | null
    lineItems?: NullableJsonNullValueInput | InputJsonValue
    File?: FileCreateNestedManyWithoutInvoiceInput
    lease?: LeaseCreateNestedOneWithoutInvoiceInput
    transactions?: TransactionsCreateNestedManyWithoutInvoiceInput
    recurringBillable?: RecurringBillableCreateNestedOneWithoutInvoiceInput
    landlord: UserCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutTenantInput = {
    id?: string
    leaseId?: string | null
    description: string
    dueAmount: number
    category: $Enums.InvoiceCategory
    status: $Enums.InvoiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paystackId: string
    dueDate?: Date | string | null
    lineItems?: NullableJsonNullValueInput | InputJsonValue
    landlordId: string
    recurringBillableId?: string | null
    File?: FileUncheckedCreateNestedManyWithoutInvoiceInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutTenantInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutTenantInput, InvoiceUncheckedCreateWithoutTenantInput>
  }

  export type InvoiceCreateManyTenantInputEnvelope = {
    data: InvoiceCreateManyTenantInput | InvoiceCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutTenantInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    idNumber?: string | null
    paystackSplitGroupId?: string | null
    paystackSubAccountId?: string | null
    paystackSubscriptionId?: string | null
    state?: string | null
    zip?: string | null
    onboardingCompleted?: boolean
    businessName?: string | null
    countryCode?: string | null
    numberOfProperties?: number | null
    numberOfUnits?: number | null
    phone?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    property?: PropertyCreateNestedManyWithoutLandlordInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    Invoice?: InvoiceCreateNestedManyWithoutLandlordInput
  }

  export type UserUncheckedCreateWithoutTenantInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    idNumber?: string | null
    paystackSplitGroupId?: string | null
    paystackSubAccountId?: string | null
    paystackSubscriptionId?: string | null
    state?: string | null
    zip?: string | null
    onboardingCompleted?: boolean
    businessName?: string | null
    countryCode?: string | null
    numberOfProperties?: number | null
    numberOfUnits?: number | null
    phone?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    property?: PropertyUncheckedCreateNestedManyWithoutLandlordInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutLandlordInput
  }

  export type UserCreateOrConnectWithoutTenantInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type TenantLeaseCreateWithoutTenantInput = {
    id?: string
    lease: LeaseCreateNestedOneWithoutTenantLeaseInput
  }

  export type TenantLeaseUncheckedCreateWithoutTenantInput = {
    id?: string
    leaseId: string
  }

  export type TenantLeaseCreateOrConnectWithoutTenantInput = {
    where: TenantLeaseWhereUniqueInput
    create: XOR<TenantLeaseCreateWithoutTenantInput, TenantLeaseUncheckedCreateWithoutTenantInput>
  }

  export type TenantLeaseCreateManyTenantInputEnvelope = {
    data: TenantLeaseCreateManyTenantInput | TenantLeaseCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type RecurringBillableCreateWithoutTenantInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    amount: number
    category: $Enums.InvoiceCategory
    cycle?: $Enums.InvoiceCycle
    nextInvoiceAt: Date | string
    isActive?: boolean
    lease?: LeaseCreateNestedOneWithoutRecurringBillableInput
    invoice?: InvoiceCreateNestedManyWithoutRecurringBillableInput
    property?: PropertyCreateNestedOneWithoutRecurringBillableInput
  }

  export type RecurringBillableUncheckedCreateWithoutTenantInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    amount: number
    category: $Enums.InvoiceCategory
    cycle?: $Enums.InvoiceCycle
    nextInvoiceAt: Date | string
    isActive?: boolean
    leaseId?: string | null
    propertyId?: string | null
    invoice?: InvoiceUncheckedCreateNestedManyWithoutRecurringBillableInput
  }

  export type RecurringBillableCreateOrConnectWithoutTenantInput = {
    where: RecurringBillableWhereUniqueInput
    create: XOR<RecurringBillableCreateWithoutTenantInput, RecurringBillableUncheckedCreateWithoutTenantInput>
  }

  export type RecurringBillableCreateManyTenantInputEnvelope = {
    data: RecurringBillableCreateManyTenantInput | RecurringBillableCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type FileUpsertWithWhereUniqueWithoutTenantInput = {
    where: FileWhereUniqueInput
    update: XOR<FileUpdateWithoutTenantInput, FileUncheckedUpdateWithoutTenantInput>
    create: XOR<FileCreateWithoutTenantInput, FileUncheckedCreateWithoutTenantInput>
  }

  export type FileUpdateWithWhereUniqueWithoutTenantInput = {
    where: FileWhereUniqueInput
    data: XOR<FileUpdateWithoutTenantInput, FileUncheckedUpdateWithoutTenantInput>
  }

  export type FileUpdateManyWithWhereWithoutTenantInput = {
    where: FileScalarWhereInput
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyWithoutTenantInput>
  }

  export type FileScalarWhereInput = {
    AND?: FileScalarWhereInput | FileScalarWhereInput[]
    OR?: FileScalarWhereInput[]
    NOT?: FileScalarWhereInput | FileScalarWhereInput[]
    id?: StringFilter<"File"> | string
    name?: StringFilter<"File"> | string
    url?: StringFilter<"File"> | string
    ownerId?: StringFilter<"File"> | string
    tenantId?: StringNullableFilter<"File"> | string | null
    propertyId?: StringNullableFilter<"File"> | string | null
    leaseId?: StringNullableFilter<"File"> | string | null
    invoiceId?: StringNullableFilter<"File"> | string | null
    maintenanceRequestId?: StringNullableFilter<"File"> | string | null
    createdAt?: DateTimeFilter<"File"> | Date | string
    updatedAt?: DateTimeFilter<"File"> | Date | string
    size?: IntNullableFilter<"File"> | number | null
    type?: StringNullableFilter<"File"> | string | null
  }

  export type InvoiceUpsertWithWhereUniqueWithoutTenantInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutTenantInput, InvoiceUncheckedUpdateWithoutTenantInput>
    create: XOR<InvoiceCreateWithoutTenantInput, InvoiceUncheckedCreateWithoutTenantInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutTenantInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutTenantInput, InvoiceUncheckedUpdateWithoutTenantInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutTenantInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutTenantInput>
  }

  export type UserUpsertWithoutTenantInput = {
    update: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTenantInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
  }

  export type UserUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSplitGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfProperties?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfUnits?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    property?: PropertyUpdateManyWithoutLandlordNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    Invoice?: InvoiceUpdateManyWithoutLandlordNestedInput
  }

  export type UserUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSplitGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfProperties?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfUnits?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    property?: PropertyUncheckedUpdateManyWithoutLandlordNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutLandlordNestedInput
  }

  export type TenantLeaseUpsertWithWhereUniqueWithoutTenantInput = {
    where: TenantLeaseWhereUniqueInput
    update: XOR<TenantLeaseUpdateWithoutTenantInput, TenantLeaseUncheckedUpdateWithoutTenantInput>
    create: XOR<TenantLeaseCreateWithoutTenantInput, TenantLeaseUncheckedCreateWithoutTenantInput>
  }

  export type TenantLeaseUpdateWithWhereUniqueWithoutTenantInput = {
    where: TenantLeaseWhereUniqueInput
    data: XOR<TenantLeaseUpdateWithoutTenantInput, TenantLeaseUncheckedUpdateWithoutTenantInput>
  }

  export type TenantLeaseUpdateManyWithWhereWithoutTenantInput = {
    where: TenantLeaseScalarWhereInput
    data: XOR<TenantLeaseUpdateManyMutationInput, TenantLeaseUncheckedUpdateManyWithoutTenantInput>
  }

  export type TenantLeaseScalarWhereInput = {
    AND?: TenantLeaseScalarWhereInput | TenantLeaseScalarWhereInput[]
    OR?: TenantLeaseScalarWhereInput[]
    NOT?: TenantLeaseScalarWhereInput | TenantLeaseScalarWhereInput[]
    id?: StringFilter<"TenantLease"> | string
    tenantId?: StringFilter<"TenantLease"> | string
    leaseId?: StringFilter<"TenantLease"> | string
  }

  export type RecurringBillableUpsertWithWhereUniqueWithoutTenantInput = {
    where: RecurringBillableWhereUniqueInput
    update: XOR<RecurringBillableUpdateWithoutTenantInput, RecurringBillableUncheckedUpdateWithoutTenantInput>
    create: XOR<RecurringBillableCreateWithoutTenantInput, RecurringBillableUncheckedCreateWithoutTenantInput>
  }

  export type RecurringBillableUpdateWithWhereUniqueWithoutTenantInput = {
    where: RecurringBillableWhereUniqueInput
    data: XOR<RecurringBillableUpdateWithoutTenantInput, RecurringBillableUncheckedUpdateWithoutTenantInput>
  }

  export type RecurringBillableUpdateManyWithWhereWithoutTenantInput = {
    where: RecurringBillableScalarWhereInput
    data: XOR<RecurringBillableUpdateManyMutationInput, RecurringBillableUncheckedUpdateManyWithoutTenantInput>
  }

  export type RecurringBillableScalarWhereInput = {
    AND?: RecurringBillableScalarWhereInput | RecurringBillableScalarWhereInput[]
    OR?: RecurringBillableScalarWhereInput[]
    NOT?: RecurringBillableScalarWhereInput | RecurringBillableScalarWhereInput[]
    id?: StringFilter<"RecurringBillable"> | string
    startDate?: DateTimeFilter<"RecurringBillable"> | Date | string
    endDate?: DateTimeNullableFilter<"RecurringBillable"> | Date | string | null
    createdAt?: DateTimeFilter<"RecurringBillable"> | Date | string
    updatedAt?: DateTimeFilter<"RecurringBillable"> | Date | string
    description?: StringFilter<"RecurringBillable"> | string
    amount?: FloatFilter<"RecurringBillable"> | number
    category?: EnumInvoiceCategoryFilter<"RecurringBillable"> | $Enums.InvoiceCategory
    cycle?: EnumInvoiceCycleFilter<"RecurringBillable"> | $Enums.InvoiceCycle
    nextInvoiceAt?: DateTimeFilter<"RecurringBillable"> | Date | string
    isActive?: BoolFilter<"RecurringBillable"> | boolean
    leaseId?: StringNullableFilter<"RecurringBillable"> | string | null
    tenantId?: StringFilter<"RecurringBillable"> | string
    propertyId?: StringNullableFilter<"RecurringBillable"> | string | null
  }

  export type FileCreateWithoutPropertyInput = {
    id?: string
    name: string
    url: string
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    size?: number | null
    type?: string | null
    invoice?: InvoiceCreateNestedOneWithoutFileInput
    lease?: LeaseCreateNestedOneWithoutFileInput
    maintenanceRequest?: MaintenanceRequestCreateNestedOneWithoutFileInput
    tenant?: TenantCreateNestedOneWithoutFilesInput
  }

  export type FileUncheckedCreateWithoutPropertyInput = {
    id?: string
    name: string
    url: string
    ownerId: string
    tenantId?: string | null
    leaseId?: string | null
    invoiceId?: string | null
    maintenanceRequestId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    size?: number | null
    type?: string | null
  }

  export type FileCreateOrConnectWithoutPropertyInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutPropertyInput, FileUncheckedCreateWithoutPropertyInput>
  }

  export type FileCreateManyPropertyInputEnvelope = {
    data: FileCreateManyPropertyInput | FileCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutPropertyInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    idNumber?: string | null
    paystackSplitGroupId?: string | null
    paystackSubAccountId?: string | null
    paystackSubscriptionId?: string | null
    state?: string | null
    zip?: string | null
    onboardingCompleted?: boolean
    businessName?: string | null
    countryCode?: string | null
    numberOfProperties?: number | null
    numberOfUnits?: number | null
    phone?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    tenant?: TenantCreateNestedManyWithoutLandlordInput
    Invoice?: InvoiceCreateNestedManyWithoutLandlordInput
  }

  export type UserUncheckedCreateWithoutPropertyInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    idNumber?: string | null
    paystackSplitGroupId?: string | null
    paystackSubAccountId?: string | null
    paystackSubscriptionId?: string | null
    state?: string | null
    zip?: string | null
    onboardingCompleted?: boolean
    businessName?: string | null
    countryCode?: string | null
    numberOfProperties?: number | null
    numberOfUnits?: number | null
    phone?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    tenant?: TenantUncheckedCreateNestedManyWithoutLandlordInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutLandlordInput
  }

  export type UserCreateOrConnectWithoutPropertyInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPropertyInput, UserUncheckedCreateWithoutPropertyInput>
  }

  export type UnitCreateWithoutPropertyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bathrooms?: number
    bedrooms?: number
    deposit?: number
    marketRent?: number
    sqmt?: number
    lease?: LeaseCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutPropertyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bathrooms?: number
    bedrooms?: number
    deposit?: number
    marketRent?: number
    sqmt?: number
    lease?: LeaseUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutPropertyInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutPropertyInput, UnitUncheckedCreateWithoutPropertyInput>
  }

  export type UnitCreateManyPropertyInputEnvelope = {
    data: UnitCreateManyPropertyInput | UnitCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type RecurringBillableCreateWithoutPropertyInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    amount: number
    category: $Enums.InvoiceCategory
    cycle?: $Enums.InvoiceCycle
    nextInvoiceAt: Date | string
    isActive?: boolean
    lease?: LeaseCreateNestedOneWithoutRecurringBillableInput
    tenant: TenantCreateNestedOneWithoutRecurringBillableInput
    invoice?: InvoiceCreateNestedManyWithoutRecurringBillableInput
  }

  export type RecurringBillableUncheckedCreateWithoutPropertyInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    amount: number
    category: $Enums.InvoiceCategory
    cycle?: $Enums.InvoiceCycle
    nextInvoiceAt: Date | string
    isActive?: boolean
    leaseId?: string | null
    tenantId: string
    invoice?: InvoiceUncheckedCreateNestedManyWithoutRecurringBillableInput
  }

  export type RecurringBillableCreateOrConnectWithoutPropertyInput = {
    where: RecurringBillableWhereUniqueInput
    create: XOR<RecurringBillableCreateWithoutPropertyInput, RecurringBillableUncheckedCreateWithoutPropertyInput>
  }

  export type RecurringBillableCreateManyPropertyInputEnvelope = {
    data: RecurringBillableCreateManyPropertyInput | RecurringBillableCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type FileUpsertWithWhereUniqueWithoutPropertyInput = {
    where: FileWhereUniqueInput
    update: XOR<FileUpdateWithoutPropertyInput, FileUncheckedUpdateWithoutPropertyInput>
    create: XOR<FileCreateWithoutPropertyInput, FileUncheckedCreateWithoutPropertyInput>
  }

  export type FileUpdateWithWhereUniqueWithoutPropertyInput = {
    where: FileWhereUniqueInput
    data: XOR<FileUpdateWithoutPropertyInput, FileUncheckedUpdateWithoutPropertyInput>
  }

  export type FileUpdateManyWithWhereWithoutPropertyInput = {
    where: FileScalarWhereInput
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyWithoutPropertyInput>
  }

  export type UserUpsertWithoutPropertyInput = {
    update: XOR<UserUpdateWithoutPropertyInput, UserUncheckedUpdateWithoutPropertyInput>
    create: XOR<UserCreateWithoutPropertyInput, UserUncheckedCreateWithoutPropertyInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPropertyInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPropertyInput, UserUncheckedUpdateWithoutPropertyInput>
  }

  export type UserUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSplitGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfProperties?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfUnits?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    tenant?: TenantUpdateManyWithoutLandlordNestedInput
    Invoice?: InvoiceUpdateManyWithoutLandlordNestedInput
  }

  export type UserUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSplitGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfProperties?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfUnits?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    tenant?: TenantUncheckedUpdateManyWithoutLandlordNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutLandlordNestedInput
  }

  export type UnitUpsertWithWhereUniqueWithoutPropertyInput = {
    where: UnitWhereUniqueInput
    update: XOR<UnitUpdateWithoutPropertyInput, UnitUncheckedUpdateWithoutPropertyInput>
    create: XOR<UnitCreateWithoutPropertyInput, UnitUncheckedCreateWithoutPropertyInput>
  }

  export type UnitUpdateWithWhereUniqueWithoutPropertyInput = {
    where: UnitWhereUniqueInput
    data: XOR<UnitUpdateWithoutPropertyInput, UnitUncheckedUpdateWithoutPropertyInput>
  }

  export type UnitUpdateManyWithWhereWithoutPropertyInput = {
    where: UnitScalarWhereInput
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyWithoutPropertyInput>
  }

  export type UnitScalarWhereInput = {
    AND?: UnitScalarWhereInput | UnitScalarWhereInput[]
    OR?: UnitScalarWhereInput[]
    NOT?: UnitScalarWhereInput | UnitScalarWhereInput[]
    id?: StringFilter<"Unit"> | string
    propertyId?: StringFilter<"Unit"> | string
    name?: StringFilter<"Unit"> | string
    createdAt?: DateTimeFilter<"Unit"> | Date | string
    updatedAt?: DateTimeFilter<"Unit"> | Date | string
    bathrooms?: FloatFilter<"Unit"> | number
    bedrooms?: IntFilter<"Unit"> | number
    deposit?: FloatFilter<"Unit"> | number
    marketRent?: FloatFilter<"Unit"> | number
    sqmt?: FloatFilter<"Unit"> | number
  }

  export type RecurringBillableUpsertWithWhereUniqueWithoutPropertyInput = {
    where: RecurringBillableWhereUniqueInput
    update: XOR<RecurringBillableUpdateWithoutPropertyInput, RecurringBillableUncheckedUpdateWithoutPropertyInput>
    create: XOR<RecurringBillableCreateWithoutPropertyInput, RecurringBillableUncheckedCreateWithoutPropertyInput>
  }

  export type RecurringBillableUpdateWithWhereUniqueWithoutPropertyInput = {
    where: RecurringBillableWhereUniqueInput
    data: XOR<RecurringBillableUpdateWithoutPropertyInput, RecurringBillableUncheckedUpdateWithoutPropertyInput>
  }

  export type RecurringBillableUpdateManyWithWhereWithoutPropertyInput = {
    where: RecurringBillableScalarWhereInput
    data: XOR<RecurringBillableUpdateManyMutationInput, RecurringBillableUncheckedUpdateManyWithoutPropertyInput>
  }

  export type LeaseCreateWithoutUnitInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    rent: number
    deposit: number
    status: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    rentDueCurrency: string
    automaticInvoice?: boolean
    invoiceCycle?: $Enums.InvoiceCycle
    leaseType: $Enums.LeaseTermType
    File?: FileCreateNestedManyWithoutLeaseInput
    invoice?: InvoiceCreateNestedManyWithoutLeaseInput
    maintenanceRequest?: MaintenanceRequestCreateNestedManyWithoutLeaseInput
    tenantLease?: TenantLeaseCreateNestedManyWithoutLeaseInput
    transactions?: TransactionsCreateNestedManyWithoutLeaseInput
    recurringBillable?: RecurringBillableCreateNestedManyWithoutLeaseInput
  }

  export type LeaseUncheckedCreateWithoutUnitInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    rent: number
    deposit: number
    status: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    rentDueCurrency: string
    automaticInvoice?: boolean
    invoiceCycle?: $Enums.InvoiceCycle
    leaseType: $Enums.LeaseTermType
    File?: FileUncheckedCreateNestedManyWithoutLeaseInput
    invoice?: InvoiceUncheckedCreateNestedManyWithoutLeaseInput
    maintenanceRequest?: MaintenanceRequestUncheckedCreateNestedManyWithoutLeaseInput
    tenantLease?: TenantLeaseUncheckedCreateNestedManyWithoutLeaseInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutLeaseInput
    recurringBillable?: RecurringBillableUncheckedCreateNestedManyWithoutLeaseInput
  }

  export type LeaseCreateOrConnectWithoutUnitInput = {
    where: LeaseWhereUniqueInput
    create: XOR<LeaseCreateWithoutUnitInput, LeaseUncheckedCreateWithoutUnitInput>
  }

  export type LeaseCreateManyUnitInputEnvelope = {
    data: LeaseCreateManyUnitInput | LeaseCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type PropertyCreateWithoutUnitInput = {
    id?: string
    name: string
    addressLine1: string
    addressLine2?: string | null
    city: string
    state: string
    zip: string
    createdAt?: Date | string
    updatedAt?: Date | string
    imageUrl?: string | null
    propertyStatus?: $Enums.PropertyStatus
    propertyType?: $Enums.PropertyType
    amenities?: PropertyCreateamenitiesInput | string[]
    countryCode?: string
    features?: PropertyCreatefeaturesInput | string[]
    files?: FileCreateNestedManyWithoutPropertyInput
    landlord: UserCreateNestedOneWithoutPropertyInput
    recurringBillable?: RecurringBillableCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutUnitInput = {
    id?: string
    name: string
    addressLine1: string
    addressLine2?: string | null
    city: string
    state: string
    zip: string
    createdAt?: Date | string
    updatedAt?: Date | string
    imageUrl?: string | null
    propertyStatus?: $Enums.PropertyStatus
    propertyType?: $Enums.PropertyType
    amenities?: PropertyCreateamenitiesInput | string[]
    countryCode?: string
    features?: PropertyCreatefeaturesInput | string[]
    landlordId: string
    files?: FileUncheckedCreateNestedManyWithoutPropertyInput
    recurringBillable?: RecurringBillableUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutUnitInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutUnitInput, PropertyUncheckedCreateWithoutUnitInput>
  }

  export type LeaseUpsertWithWhereUniqueWithoutUnitInput = {
    where: LeaseWhereUniqueInput
    update: XOR<LeaseUpdateWithoutUnitInput, LeaseUncheckedUpdateWithoutUnitInput>
    create: XOR<LeaseCreateWithoutUnitInput, LeaseUncheckedCreateWithoutUnitInput>
  }

  export type LeaseUpdateWithWhereUniqueWithoutUnitInput = {
    where: LeaseWhereUniqueInput
    data: XOR<LeaseUpdateWithoutUnitInput, LeaseUncheckedUpdateWithoutUnitInput>
  }

  export type LeaseUpdateManyWithWhereWithoutUnitInput = {
    where: LeaseScalarWhereInput
    data: XOR<LeaseUpdateManyMutationInput, LeaseUncheckedUpdateManyWithoutUnitInput>
  }

  export type LeaseScalarWhereInput = {
    AND?: LeaseScalarWhereInput | LeaseScalarWhereInput[]
    OR?: LeaseScalarWhereInput[]
    NOT?: LeaseScalarWhereInput | LeaseScalarWhereInput[]
    id?: StringFilter<"Lease"> | string
    startDate?: DateTimeFilter<"Lease"> | Date | string
    endDate?: DateTimeNullableFilter<"Lease"> | Date | string | null
    rent?: FloatFilter<"Lease"> | number
    deposit?: FloatFilter<"Lease"> | number
    status?: EnumLeaseStatusFilter<"Lease"> | $Enums.LeaseStatus
    createdAt?: DateTimeFilter<"Lease"> | Date | string
    updatedAt?: DateTimeFilter<"Lease"> | Date | string
    rentDueCurrency?: StringFilter<"Lease"> | string
    unitId?: StringNullableFilter<"Lease"> | string | null
    automaticInvoice?: BoolFilter<"Lease"> | boolean
    invoiceCycle?: EnumInvoiceCycleFilter<"Lease"> | $Enums.InvoiceCycle
    leaseType?: EnumLeaseTermTypeFilter<"Lease"> | $Enums.LeaseTermType
  }

  export type PropertyUpsertWithoutUnitInput = {
    update: XOR<PropertyUpdateWithoutUnitInput, PropertyUncheckedUpdateWithoutUnitInput>
    create: XOR<PropertyCreateWithoutUnitInput, PropertyUncheckedCreateWithoutUnitInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutUnitInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutUnitInput, PropertyUncheckedUpdateWithoutUnitInput>
  }

  export type PropertyUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    propertyStatus?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    amenities?: PropertyUpdateamenitiesInput | string[]
    countryCode?: StringFieldUpdateOperationsInput | string
    features?: PropertyUpdatefeaturesInput | string[]
    files?: FileUpdateManyWithoutPropertyNestedInput
    landlord?: UserUpdateOneRequiredWithoutPropertyNestedInput
    recurringBillable?: RecurringBillableUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    propertyStatus?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    amenities?: PropertyUpdateamenitiesInput | string[]
    countryCode?: StringFieldUpdateOperationsInput | string
    features?: PropertyUpdatefeaturesInput | string[]
    landlordId?: StringFieldUpdateOperationsInput | string
    files?: FileUncheckedUpdateManyWithoutPropertyNestedInput
    recurringBillable?: RecurringBillableUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type FileCreateWithoutLeaseInput = {
    id?: string
    name: string
    url: string
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    size?: number | null
    type?: string | null
    invoice?: InvoiceCreateNestedOneWithoutFileInput
    maintenanceRequest?: MaintenanceRequestCreateNestedOneWithoutFileInput
    property?: PropertyCreateNestedOneWithoutFilesInput
    tenant?: TenantCreateNestedOneWithoutFilesInput
  }

  export type FileUncheckedCreateWithoutLeaseInput = {
    id?: string
    name: string
    url: string
    ownerId: string
    tenantId?: string | null
    propertyId?: string | null
    invoiceId?: string | null
    maintenanceRequestId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    size?: number | null
    type?: string | null
  }

  export type FileCreateOrConnectWithoutLeaseInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutLeaseInput, FileUncheckedCreateWithoutLeaseInput>
  }

  export type FileCreateManyLeaseInputEnvelope = {
    data: FileCreateManyLeaseInput | FileCreateManyLeaseInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutLeaseInput = {
    id?: string
    description: string
    dueAmount: number
    category: $Enums.InvoiceCategory
    status: $Enums.InvoiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paystackId: string
    dueDate?: Date | string | null
    lineItems?: NullableJsonNullValueInput | InputJsonValue
    File?: FileCreateNestedManyWithoutInvoiceInput
    tenant: TenantCreateNestedOneWithoutInvoiceInput
    transactions?: TransactionsCreateNestedManyWithoutInvoiceInput
    recurringBillable?: RecurringBillableCreateNestedOneWithoutInvoiceInput
    landlord: UserCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutLeaseInput = {
    id?: string
    description: string
    dueAmount: number
    category: $Enums.InvoiceCategory
    status: $Enums.InvoiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paystackId: string
    dueDate?: Date | string | null
    lineItems?: NullableJsonNullValueInput | InputJsonValue
    landlordId: string
    tenantId: string
    recurringBillableId?: string | null
    File?: FileUncheckedCreateNestedManyWithoutInvoiceInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutLeaseInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutLeaseInput, InvoiceUncheckedCreateWithoutLeaseInput>
  }

  export type InvoiceCreateManyLeaseInputEnvelope = {
    data: InvoiceCreateManyLeaseInput | InvoiceCreateManyLeaseInput[]
    skipDuplicates?: boolean
  }

  export type UnitCreateWithoutLeaseInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bathrooms?: number
    bedrooms?: number
    deposit?: number
    marketRent?: number
    sqmt?: number
    property: PropertyCreateNestedOneWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutLeaseInput = {
    id?: string
    propertyId: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bathrooms?: number
    bedrooms?: number
    deposit?: number
    marketRent?: number
    sqmt?: number
  }

  export type UnitCreateOrConnectWithoutLeaseInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutLeaseInput, UnitUncheckedCreateWithoutLeaseInput>
  }

  export type MaintenanceRequestCreateWithoutLeaseInput = {
    id?: string
    description?: string | null
    status?: $Enums.MaintenanceRequestStatus | null
    priority: $Enums.MaintenanceRequestPriority
    createdAt?: Date | string
    updatedAt?: Date | string
    File?: FileCreateNestedManyWithoutMaintenanceRequestInput
  }

  export type MaintenanceRequestUncheckedCreateWithoutLeaseInput = {
    id?: string
    description?: string | null
    status?: $Enums.MaintenanceRequestStatus | null
    priority: $Enums.MaintenanceRequestPriority
    createdAt?: Date | string
    updatedAt?: Date | string
    File?: FileUncheckedCreateNestedManyWithoutMaintenanceRequestInput
  }

  export type MaintenanceRequestCreateOrConnectWithoutLeaseInput = {
    where: MaintenanceRequestWhereUniqueInput
    create: XOR<MaintenanceRequestCreateWithoutLeaseInput, MaintenanceRequestUncheckedCreateWithoutLeaseInput>
  }

  export type MaintenanceRequestCreateManyLeaseInputEnvelope = {
    data: MaintenanceRequestCreateManyLeaseInput | MaintenanceRequestCreateManyLeaseInput[]
    skipDuplicates?: boolean
  }

  export type TenantLeaseCreateWithoutLeaseInput = {
    id?: string
    tenant: TenantCreateNestedOneWithoutTenantLeaseInput
  }

  export type TenantLeaseUncheckedCreateWithoutLeaseInput = {
    id?: string
    tenantId: string
  }

  export type TenantLeaseCreateOrConnectWithoutLeaseInput = {
    where: TenantLeaseWhereUniqueInput
    create: XOR<TenantLeaseCreateWithoutLeaseInput, TenantLeaseUncheckedCreateWithoutLeaseInput>
  }

  export type TenantLeaseCreateManyLeaseInputEnvelope = {
    data: TenantLeaseCreateManyLeaseInput | TenantLeaseCreateManyLeaseInput[]
    skipDuplicates?: boolean
  }

  export type TransactionsCreateWithoutLeaseInput = {
    id?: string
    description: string
    amountPaid: number
    referenceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice?: InvoiceCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionsUncheckedCreateWithoutLeaseInput = {
    id?: string
    description: string
    amountPaid: number
    referenceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceId?: string | null
  }

  export type TransactionsCreateOrConnectWithoutLeaseInput = {
    where: TransactionsWhereUniqueInput
    create: XOR<TransactionsCreateWithoutLeaseInput, TransactionsUncheckedCreateWithoutLeaseInput>
  }

  export type TransactionsCreateManyLeaseInputEnvelope = {
    data: TransactionsCreateManyLeaseInput | TransactionsCreateManyLeaseInput[]
    skipDuplicates?: boolean
  }

  export type RecurringBillableCreateWithoutLeaseInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    amount: number
    category: $Enums.InvoiceCategory
    cycle?: $Enums.InvoiceCycle
    nextInvoiceAt: Date | string
    isActive?: boolean
    tenant: TenantCreateNestedOneWithoutRecurringBillableInput
    invoice?: InvoiceCreateNestedManyWithoutRecurringBillableInput
    property?: PropertyCreateNestedOneWithoutRecurringBillableInput
  }

  export type RecurringBillableUncheckedCreateWithoutLeaseInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    amount: number
    category: $Enums.InvoiceCategory
    cycle?: $Enums.InvoiceCycle
    nextInvoiceAt: Date | string
    isActive?: boolean
    tenantId: string
    propertyId?: string | null
    invoice?: InvoiceUncheckedCreateNestedManyWithoutRecurringBillableInput
  }

  export type RecurringBillableCreateOrConnectWithoutLeaseInput = {
    where: RecurringBillableWhereUniqueInput
    create: XOR<RecurringBillableCreateWithoutLeaseInput, RecurringBillableUncheckedCreateWithoutLeaseInput>
  }

  export type RecurringBillableCreateManyLeaseInputEnvelope = {
    data: RecurringBillableCreateManyLeaseInput | RecurringBillableCreateManyLeaseInput[]
    skipDuplicates?: boolean
  }

  export type FileUpsertWithWhereUniqueWithoutLeaseInput = {
    where: FileWhereUniqueInput
    update: XOR<FileUpdateWithoutLeaseInput, FileUncheckedUpdateWithoutLeaseInput>
    create: XOR<FileCreateWithoutLeaseInput, FileUncheckedCreateWithoutLeaseInput>
  }

  export type FileUpdateWithWhereUniqueWithoutLeaseInput = {
    where: FileWhereUniqueInput
    data: XOR<FileUpdateWithoutLeaseInput, FileUncheckedUpdateWithoutLeaseInput>
  }

  export type FileUpdateManyWithWhereWithoutLeaseInput = {
    where: FileScalarWhereInput
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyWithoutLeaseInput>
  }

  export type InvoiceUpsertWithWhereUniqueWithoutLeaseInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutLeaseInput, InvoiceUncheckedUpdateWithoutLeaseInput>
    create: XOR<InvoiceCreateWithoutLeaseInput, InvoiceUncheckedCreateWithoutLeaseInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutLeaseInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutLeaseInput, InvoiceUncheckedUpdateWithoutLeaseInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutLeaseInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutLeaseInput>
  }

  export type UnitUpsertWithoutLeaseInput = {
    update: XOR<UnitUpdateWithoutLeaseInput, UnitUncheckedUpdateWithoutLeaseInput>
    create: XOR<UnitCreateWithoutLeaseInput, UnitUncheckedCreateWithoutLeaseInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutLeaseInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutLeaseInput, UnitUncheckedUpdateWithoutLeaseInput>
  }

  export type UnitUpdateWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bathrooms?: FloatFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    marketRent?: FloatFieldUpdateOperationsInput | number
    sqmt?: FloatFieldUpdateOperationsInput | number
    property?: PropertyUpdateOneRequiredWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bathrooms?: FloatFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    marketRent?: FloatFieldUpdateOperationsInput | number
    sqmt?: FloatFieldUpdateOperationsInput | number
  }

  export type MaintenanceRequestUpsertWithWhereUniqueWithoutLeaseInput = {
    where: MaintenanceRequestWhereUniqueInput
    update: XOR<MaintenanceRequestUpdateWithoutLeaseInput, MaintenanceRequestUncheckedUpdateWithoutLeaseInput>
    create: XOR<MaintenanceRequestCreateWithoutLeaseInput, MaintenanceRequestUncheckedCreateWithoutLeaseInput>
  }

  export type MaintenanceRequestUpdateWithWhereUniqueWithoutLeaseInput = {
    where: MaintenanceRequestWhereUniqueInput
    data: XOR<MaintenanceRequestUpdateWithoutLeaseInput, MaintenanceRequestUncheckedUpdateWithoutLeaseInput>
  }

  export type MaintenanceRequestUpdateManyWithWhereWithoutLeaseInput = {
    where: MaintenanceRequestScalarWhereInput
    data: XOR<MaintenanceRequestUpdateManyMutationInput, MaintenanceRequestUncheckedUpdateManyWithoutLeaseInput>
  }

  export type MaintenanceRequestScalarWhereInput = {
    AND?: MaintenanceRequestScalarWhereInput | MaintenanceRequestScalarWhereInput[]
    OR?: MaintenanceRequestScalarWhereInput[]
    NOT?: MaintenanceRequestScalarWhereInput | MaintenanceRequestScalarWhereInput[]
    id?: StringFilter<"MaintenanceRequest"> | string
    leaseId?: StringFilter<"MaintenanceRequest"> | string
    description?: StringNullableFilter<"MaintenanceRequest"> | string | null
    status?: EnumMaintenanceRequestStatusNullableFilter<"MaintenanceRequest"> | $Enums.MaintenanceRequestStatus | null
    priority?: EnumMaintenanceRequestPriorityFilter<"MaintenanceRequest"> | $Enums.MaintenanceRequestPriority
    createdAt?: DateTimeFilter<"MaintenanceRequest"> | Date | string
    updatedAt?: DateTimeFilter<"MaintenanceRequest"> | Date | string
  }

  export type TenantLeaseUpsertWithWhereUniqueWithoutLeaseInput = {
    where: TenantLeaseWhereUniqueInput
    update: XOR<TenantLeaseUpdateWithoutLeaseInput, TenantLeaseUncheckedUpdateWithoutLeaseInput>
    create: XOR<TenantLeaseCreateWithoutLeaseInput, TenantLeaseUncheckedCreateWithoutLeaseInput>
  }

  export type TenantLeaseUpdateWithWhereUniqueWithoutLeaseInput = {
    where: TenantLeaseWhereUniqueInput
    data: XOR<TenantLeaseUpdateWithoutLeaseInput, TenantLeaseUncheckedUpdateWithoutLeaseInput>
  }

  export type TenantLeaseUpdateManyWithWhereWithoutLeaseInput = {
    where: TenantLeaseScalarWhereInput
    data: XOR<TenantLeaseUpdateManyMutationInput, TenantLeaseUncheckedUpdateManyWithoutLeaseInput>
  }

  export type TransactionsUpsertWithWhereUniqueWithoutLeaseInput = {
    where: TransactionsWhereUniqueInput
    update: XOR<TransactionsUpdateWithoutLeaseInput, TransactionsUncheckedUpdateWithoutLeaseInput>
    create: XOR<TransactionsCreateWithoutLeaseInput, TransactionsUncheckedCreateWithoutLeaseInput>
  }

  export type TransactionsUpdateWithWhereUniqueWithoutLeaseInput = {
    where: TransactionsWhereUniqueInput
    data: XOR<TransactionsUpdateWithoutLeaseInput, TransactionsUncheckedUpdateWithoutLeaseInput>
  }

  export type TransactionsUpdateManyWithWhereWithoutLeaseInput = {
    where: TransactionsScalarWhereInput
    data: XOR<TransactionsUpdateManyMutationInput, TransactionsUncheckedUpdateManyWithoutLeaseInput>
  }

  export type TransactionsScalarWhereInput = {
    AND?: TransactionsScalarWhereInput | TransactionsScalarWhereInput[]
    OR?: TransactionsScalarWhereInput[]
    NOT?: TransactionsScalarWhereInput | TransactionsScalarWhereInput[]
    id?: StringFilter<"Transactions"> | string
    leaseId?: StringNullableFilter<"Transactions"> | string | null
    description?: StringFilter<"Transactions"> | string
    amountPaid?: FloatFilter<"Transactions"> | number
    referenceId?: StringNullableFilter<"Transactions"> | string | null
    createdAt?: DateTimeFilter<"Transactions"> | Date | string
    updatedAt?: DateTimeFilter<"Transactions"> | Date | string
    invoiceId?: StringNullableFilter<"Transactions"> | string | null
  }

  export type RecurringBillableUpsertWithWhereUniqueWithoutLeaseInput = {
    where: RecurringBillableWhereUniqueInput
    update: XOR<RecurringBillableUpdateWithoutLeaseInput, RecurringBillableUncheckedUpdateWithoutLeaseInput>
    create: XOR<RecurringBillableCreateWithoutLeaseInput, RecurringBillableUncheckedCreateWithoutLeaseInput>
  }

  export type RecurringBillableUpdateWithWhereUniqueWithoutLeaseInput = {
    where: RecurringBillableWhereUniqueInput
    data: XOR<RecurringBillableUpdateWithoutLeaseInput, RecurringBillableUncheckedUpdateWithoutLeaseInput>
  }

  export type RecurringBillableUpdateManyWithWhereWithoutLeaseInput = {
    where: RecurringBillableScalarWhereInput
    data: XOR<RecurringBillableUpdateManyMutationInput, RecurringBillableUncheckedUpdateManyWithoutLeaseInput>
  }

  export type FileCreateWithoutInvoiceInput = {
    id?: string
    name: string
    url: string
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    size?: number | null
    type?: string | null
    lease?: LeaseCreateNestedOneWithoutFileInput
    maintenanceRequest?: MaintenanceRequestCreateNestedOneWithoutFileInput
    property?: PropertyCreateNestedOneWithoutFilesInput
    tenant?: TenantCreateNestedOneWithoutFilesInput
  }

  export type FileUncheckedCreateWithoutInvoiceInput = {
    id?: string
    name: string
    url: string
    ownerId: string
    tenantId?: string | null
    propertyId?: string | null
    leaseId?: string | null
    maintenanceRequestId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    size?: number | null
    type?: string | null
  }

  export type FileCreateOrConnectWithoutInvoiceInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutInvoiceInput, FileUncheckedCreateWithoutInvoiceInput>
  }

  export type FileCreateManyInvoiceInputEnvelope = {
    data: FileCreateManyInvoiceInput | FileCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type LeaseCreateWithoutInvoiceInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    rent: number
    deposit: number
    status: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    rentDueCurrency: string
    automaticInvoice?: boolean
    invoiceCycle?: $Enums.InvoiceCycle
    leaseType: $Enums.LeaseTermType
    File?: FileCreateNestedManyWithoutLeaseInput
    unit?: UnitCreateNestedOneWithoutLeaseInput
    maintenanceRequest?: MaintenanceRequestCreateNestedManyWithoutLeaseInput
    tenantLease?: TenantLeaseCreateNestedManyWithoutLeaseInput
    transactions?: TransactionsCreateNestedManyWithoutLeaseInput
    recurringBillable?: RecurringBillableCreateNestedManyWithoutLeaseInput
  }

  export type LeaseUncheckedCreateWithoutInvoiceInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    rent: number
    deposit: number
    status: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    rentDueCurrency: string
    unitId?: string | null
    automaticInvoice?: boolean
    invoiceCycle?: $Enums.InvoiceCycle
    leaseType: $Enums.LeaseTermType
    File?: FileUncheckedCreateNestedManyWithoutLeaseInput
    maintenanceRequest?: MaintenanceRequestUncheckedCreateNestedManyWithoutLeaseInput
    tenantLease?: TenantLeaseUncheckedCreateNestedManyWithoutLeaseInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutLeaseInput
    recurringBillable?: RecurringBillableUncheckedCreateNestedManyWithoutLeaseInput
  }

  export type LeaseCreateOrConnectWithoutInvoiceInput = {
    where: LeaseWhereUniqueInput
    create: XOR<LeaseCreateWithoutInvoiceInput, LeaseUncheckedCreateWithoutInvoiceInput>
  }

  export type TenantCreateWithoutInvoiceInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    firstName: string
    lastName: string
    phone: string
    dateOfBirth?: Date | string | null
    tenantEmergencyContact?: NullableJsonNullValueInput | InputJsonValue
    tenantIncome?: NullableJsonNullValueInput | InputJsonValue
    additionalEmails?: TenantCreateadditionalEmailsInput | string[]
    additionalPhones?: TenantCreateadditionalPhonesInput | string[]
    emergencyContacts?: NullableJsonNullValueInput | InputJsonValue
    vehicles?: NullableJsonNullValueInput | InputJsonValue
    avatarUrl?: string | null
    fullName?: string | null
    paystackCustomerId?: string | null
    files?: FileCreateNestedManyWithoutTenantInput
    landlord: UserCreateNestedOneWithoutTenantInput
    tenantLease?: TenantLeaseCreateNestedManyWithoutTenantInput
    recurringBillable?: RecurringBillableCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutInvoiceInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    firstName: string
    lastName: string
    phone: string
    landlordId: string
    dateOfBirth?: Date | string | null
    tenantEmergencyContact?: NullableJsonNullValueInput | InputJsonValue
    tenantIncome?: NullableJsonNullValueInput | InputJsonValue
    additionalEmails?: TenantCreateadditionalEmailsInput | string[]
    additionalPhones?: TenantCreateadditionalPhonesInput | string[]
    emergencyContacts?: NullableJsonNullValueInput | InputJsonValue
    vehicles?: NullableJsonNullValueInput | InputJsonValue
    avatarUrl?: string | null
    fullName?: string | null
    paystackCustomerId?: string | null
    files?: FileUncheckedCreateNestedManyWithoutTenantInput
    tenantLease?: TenantLeaseUncheckedCreateNestedManyWithoutTenantInput
    recurringBillable?: RecurringBillableUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutInvoiceInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutInvoiceInput, TenantUncheckedCreateWithoutInvoiceInput>
  }

  export type TransactionsCreateWithoutInvoiceInput = {
    id?: string
    description: string
    amountPaid: number
    referenceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lease?: LeaseCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionsUncheckedCreateWithoutInvoiceInput = {
    id?: string
    leaseId?: string | null
    description: string
    amountPaid: number
    referenceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionsCreateOrConnectWithoutInvoiceInput = {
    where: TransactionsWhereUniqueInput
    create: XOR<TransactionsCreateWithoutInvoiceInput, TransactionsUncheckedCreateWithoutInvoiceInput>
  }

  export type TransactionsCreateManyInvoiceInputEnvelope = {
    data: TransactionsCreateManyInvoiceInput | TransactionsCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type RecurringBillableCreateWithoutInvoiceInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    amount: number
    category: $Enums.InvoiceCategory
    cycle?: $Enums.InvoiceCycle
    nextInvoiceAt: Date | string
    isActive?: boolean
    lease?: LeaseCreateNestedOneWithoutRecurringBillableInput
    tenant: TenantCreateNestedOneWithoutRecurringBillableInput
    property?: PropertyCreateNestedOneWithoutRecurringBillableInput
  }

  export type RecurringBillableUncheckedCreateWithoutInvoiceInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    amount: number
    category: $Enums.InvoiceCategory
    cycle?: $Enums.InvoiceCycle
    nextInvoiceAt: Date | string
    isActive?: boolean
    leaseId?: string | null
    tenantId: string
    propertyId?: string | null
  }

  export type RecurringBillableCreateOrConnectWithoutInvoiceInput = {
    where: RecurringBillableWhereUniqueInput
    create: XOR<RecurringBillableCreateWithoutInvoiceInput, RecurringBillableUncheckedCreateWithoutInvoiceInput>
  }

  export type UserCreateWithoutInvoiceInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    idNumber?: string | null
    paystackSplitGroupId?: string | null
    paystackSubAccountId?: string | null
    paystackSubscriptionId?: string | null
    state?: string | null
    zip?: string | null
    onboardingCompleted?: boolean
    businessName?: string | null
    countryCode?: string | null
    numberOfProperties?: number | null
    numberOfUnits?: number | null
    phone?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    property?: PropertyCreateNestedManyWithoutLandlordInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    tenant?: TenantCreateNestedManyWithoutLandlordInput
  }

  export type UserUncheckedCreateWithoutInvoiceInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    idNumber?: string | null
    paystackSplitGroupId?: string | null
    paystackSubAccountId?: string | null
    paystackSubscriptionId?: string | null
    state?: string | null
    zip?: string | null
    onboardingCompleted?: boolean
    businessName?: string | null
    countryCode?: string | null
    numberOfProperties?: number | null
    numberOfUnits?: number | null
    phone?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    property?: PropertyUncheckedCreateNestedManyWithoutLandlordInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    tenant?: TenantUncheckedCreateNestedManyWithoutLandlordInput
  }

  export type UserCreateOrConnectWithoutInvoiceInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvoiceInput, UserUncheckedCreateWithoutInvoiceInput>
  }

  export type FileUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: FileWhereUniqueInput
    update: XOR<FileUpdateWithoutInvoiceInput, FileUncheckedUpdateWithoutInvoiceInput>
    create: XOR<FileCreateWithoutInvoiceInput, FileUncheckedCreateWithoutInvoiceInput>
  }

  export type FileUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: FileWhereUniqueInput
    data: XOR<FileUpdateWithoutInvoiceInput, FileUncheckedUpdateWithoutInvoiceInput>
  }

  export type FileUpdateManyWithWhereWithoutInvoiceInput = {
    where: FileScalarWhereInput
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type LeaseUpsertWithoutInvoiceInput = {
    update: XOR<LeaseUpdateWithoutInvoiceInput, LeaseUncheckedUpdateWithoutInvoiceInput>
    create: XOR<LeaseCreateWithoutInvoiceInput, LeaseUncheckedCreateWithoutInvoiceInput>
    where?: LeaseWhereInput
  }

  export type LeaseUpdateToOneWithWhereWithoutInvoiceInput = {
    where?: LeaseWhereInput
    data: XOR<LeaseUpdateWithoutInvoiceInput, LeaseUncheckedUpdateWithoutInvoiceInput>
  }

  export type LeaseUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rentDueCurrency?: StringFieldUpdateOperationsInput | string
    automaticInvoice?: BoolFieldUpdateOperationsInput | boolean
    invoiceCycle?: EnumInvoiceCycleFieldUpdateOperationsInput | $Enums.InvoiceCycle
    leaseType?: EnumLeaseTermTypeFieldUpdateOperationsInput | $Enums.LeaseTermType
    File?: FileUpdateManyWithoutLeaseNestedInput
    unit?: UnitUpdateOneWithoutLeaseNestedInput
    maintenanceRequest?: MaintenanceRequestUpdateManyWithoutLeaseNestedInput
    tenantLease?: TenantLeaseUpdateManyWithoutLeaseNestedInput
    transactions?: TransactionsUpdateManyWithoutLeaseNestedInput
    recurringBillable?: RecurringBillableUpdateManyWithoutLeaseNestedInput
  }

  export type LeaseUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rentDueCurrency?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    automaticInvoice?: BoolFieldUpdateOperationsInput | boolean
    invoiceCycle?: EnumInvoiceCycleFieldUpdateOperationsInput | $Enums.InvoiceCycle
    leaseType?: EnumLeaseTermTypeFieldUpdateOperationsInput | $Enums.LeaseTermType
    File?: FileUncheckedUpdateManyWithoutLeaseNestedInput
    maintenanceRequest?: MaintenanceRequestUncheckedUpdateManyWithoutLeaseNestedInput
    tenantLease?: TenantLeaseUncheckedUpdateManyWithoutLeaseNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutLeaseNestedInput
    recurringBillable?: RecurringBillableUncheckedUpdateManyWithoutLeaseNestedInput
  }

  export type TenantUpsertWithoutInvoiceInput = {
    update: XOR<TenantUpdateWithoutInvoiceInput, TenantUncheckedUpdateWithoutInvoiceInput>
    create: XOR<TenantCreateWithoutInvoiceInput, TenantUncheckedCreateWithoutInvoiceInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutInvoiceInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutInvoiceInput, TenantUncheckedUpdateWithoutInvoiceInput>
  }

  export type TenantUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantEmergencyContact?: NullableJsonNullValueInput | InputJsonValue
    tenantIncome?: NullableJsonNullValueInput | InputJsonValue
    additionalEmails?: TenantUpdateadditionalEmailsInput | string[]
    additionalPhones?: TenantUpdateadditionalPhonesInput | string[]
    emergencyContacts?: NullableJsonNullValueInput | InputJsonValue
    vehicles?: NullableJsonNullValueInput | InputJsonValue
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    paystackCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    files?: FileUpdateManyWithoutTenantNestedInput
    landlord?: UserUpdateOneRequiredWithoutTenantNestedInput
    tenantLease?: TenantLeaseUpdateManyWithoutTenantNestedInput
    recurringBillable?: RecurringBillableUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    landlordId?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantEmergencyContact?: NullableJsonNullValueInput | InputJsonValue
    tenantIncome?: NullableJsonNullValueInput | InputJsonValue
    additionalEmails?: TenantUpdateadditionalEmailsInput | string[]
    additionalPhones?: TenantUpdateadditionalPhonesInput | string[]
    emergencyContacts?: NullableJsonNullValueInput | InputJsonValue
    vehicles?: NullableJsonNullValueInput | InputJsonValue
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    paystackCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    files?: FileUncheckedUpdateManyWithoutTenantNestedInput
    tenantLease?: TenantLeaseUncheckedUpdateManyWithoutTenantNestedInput
    recurringBillable?: RecurringBillableUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TransactionsUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: TransactionsWhereUniqueInput
    update: XOR<TransactionsUpdateWithoutInvoiceInput, TransactionsUncheckedUpdateWithoutInvoiceInput>
    create: XOR<TransactionsCreateWithoutInvoiceInput, TransactionsUncheckedCreateWithoutInvoiceInput>
  }

  export type TransactionsUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: TransactionsWhereUniqueInput
    data: XOR<TransactionsUpdateWithoutInvoiceInput, TransactionsUncheckedUpdateWithoutInvoiceInput>
  }

  export type TransactionsUpdateManyWithWhereWithoutInvoiceInput = {
    where: TransactionsScalarWhereInput
    data: XOR<TransactionsUpdateManyMutationInput, TransactionsUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type RecurringBillableUpsertWithoutInvoiceInput = {
    update: XOR<RecurringBillableUpdateWithoutInvoiceInput, RecurringBillableUncheckedUpdateWithoutInvoiceInput>
    create: XOR<RecurringBillableCreateWithoutInvoiceInput, RecurringBillableUncheckedCreateWithoutInvoiceInput>
    where?: RecurringBillableWhereInput
  }

  export type RecurringBillableUpdateToOneWithWhereWithoutInvoiceInput = {
    where?: RecurringBillableWhereInput
    data: XOR<RecurringBillableUpdateWithoutInvoiceInput, RecurringBillableUncheckedUpdateWithoutInvoiceInput>
  }

  export type RecurringBillableUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    category?: EnumInvoiceCategoryFieldUpdateOperationsInput | $Enums.InvoiceCategory
    cycle?: EnumInvoiceCycleFieldUpdateOperationsInput | $Enums.InvoiceCycle
    nextInvoiceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lease?: LeaseUpdateOneWithoutRecurringBillableNestedInput
    tenant?: TenantUpdateOneRequiredWithoutRecurringBillableNestedInput
    property?: PropertyUpdateOneWithoutRecurringBillableNestedInput
  }

  export type RecurringBillableUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    category?: EnumInvoiceCategoryFieldUpdateOperationsInput | $Enums.InvoiceCategory
    cycle?: EnumInvoiceCycleFieldUpdateOperationsInput | $Enums.InvoiceCycle
    nextInvoiceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    leaseId?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpsertWithoutInvoiceInput = {
    update: XOR<UserUpdateWithoutInvoiceInput, UserUncheckedUpdateWithoutInvoiceInput>
    create: XOR<UserCreateWithoutInvoiceInput, UserUncheckedCreateWithoutInvoiceInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvoiceInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvoiceInput, UserUncheckedUpdateWithoutInvoiceInput>
  }

  export type UserUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSplitGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfProperties?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfUnits?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    property?: PropertyUpdateManyWithoutLandlordNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    tenant?: TenantUpdateManyWithoutLandlordNestedInput
  }

  export type UserUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSplitGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    paystackSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfProperties?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfUnits?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    property?: PropertyUncheckedUpdateManyWithoutLandlordNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    tenant?: TenantUncheckedUpdateManyWithoutLandlordNestedInput
  }

  export type LeaseCreateWithoutRecurringBillableInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    rent: number
    deposit: number
    status: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    rentDueCurrency: string
    automaticInvoice?: boolean
    invoiceCycle?: $Enums.InvoiceCycle
    leaseType: $Enums.LeaseTermType
    File?: FileCreateNestedManyWithoutLeaseInput
    invoice?: InvoiceCreateNestedManyWithoutLeaseInput
    unit?: UnitCreateNestedOneWithoutLeaseInput
    maintenanceRequest?: MaintenanceRequestCreateNestedManyWithoutLeaseInput
    tenantLease?: TenantLeaseCreateNestedManyWithoutLeaseInput
    transactions?: TransactionsCreateNestedManyWithoutLeaseInput
  }

  export type LeaseUncheckedCreateWithoutRecurringBillableInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    rent: number
    deposit: number
    status: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    rentDueCurrency: string
    unitId?: string | null
    automaticInvoice?: boolean
    invoiceCycle?: $Enums.InvoiceCycle
    leaseType: $Enums.LeaseTermType
    File?: FileUncheckedCreateNestedManyWithoutLeaseInput
    invoice?: InvoiceUncheckedCreateNestedManyWithoutLeaseInput
    maintenanceRequest?: MaintenanceRequestUncheckedCreateNestedManyWithoutLeaseInput
    tenantLease?: TenantLeaseUncheckedCreateNestedManyWithoutLeaseInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutLeaseInput
  }

  export type LeaseCreateOrConnectWithoutRecurringBillableInput = {
    where: LeaseWhereUniqueInput
    create: XOR<LeaseCreateWithoutRecurringBillableInput, LeaseUncheckedCreateWithoutRecurringBillableInput>
  }

  export type TenantCreateWithoutRecurringBillableInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    firstName: string
    lastName: string
    phone: string
    dateOfBirth?: Date | string | null
    tenantEmergencyContact?: NullableJsonNullValueInput | InputJsonValue
    tenantIncome?: NullableJsonNullValueInput | InputJsonValue
    additionalEmails?: TenantCreateadditionalEmailsInput | string[]
    additionalPhones?: TenantCreateadditionalPhonesInput | string[]
    emergencyContacts?: NullableJsonNullValueInput | InputJsonValue
    vehicles?: NullableJsonNullValueInput | InputJsonValue
    avatarUrl?: string | null
    fullName?: string | null
    paystackCustomerId?: string | null
    files?: FileCreateNestedManyWithoutTenantInput
    Invoice?: InvoiceCreateNestedManyWithoutTenantInput
    landlord: UserCreateNestedOneWithoutTenantInput
    tenantLease?: TenantLeaseCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutRecurringBillableInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    firstName: string
    lastName: string
    phone: string
    landlordId: string
    dateOfBirth?: Date | string | null
    tenantEmergencyContact?: NullableJsonNullValueInput | InputJsonValue
    tenantIncome?: NullableJsonNullValueInput | InputJsonValue
    additionalEmails?: TenantCreateadditionalEmailsInput | string[]
    additionalPhones?: TenantCreateadditionalPhonesInput | string[]
    emergencyContacts?: NullableJsonNullValueInput | InputJsonValue
    vehicles?: NullableJsonNullValueInput | InputJsonValue
    avatarUrl?: string | null
    fullName?: string | null
    paystackCustomerId?: string | null
    files?: FileUncheckedCreateNestedManyWithoutTenantInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    tenantLease?: TenantLeaseUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutRecurringBillableInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutRecurringBillableInput, TenantUncheckedCreateWithoutRecurringBillableInput>
  }

  export type InvoiceCreateWithoutRecurringBillableInput = {
    id?: string
    description: string
    dueAmount: number
    category: $Enums.InvoiceCategory
    status: $Enums.InvoiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paystackId: string
    dueDate?: Date | string | null
    lineItems?: NullableJsonNullValueInput | InputJsonValue
    File?: FileCreateNestedManyWithoutInvoiceInput
    lease?: LeaseCreateNestedOneWithoutInvoiceInput
    tenant: TenantCreateNestedOneWithoutInvoiceInput
    transactions?: TransactionsCreateNestedManyWithoutInvoiceInput
    landlord: UserCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutRecurringBillableInput = {
    id?: string
    leaseId?: string | null
    description: string
    dueAmount: number
    category: $Enums.InvoiceCategory
    status: $Enums.InvoiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paystackId: string
    dueDate?: Date | string | null
    lineItems?: NullableJsonNullValueInput | InputJsonValue
    landlordId: string
    tenantId: string
    File?: FileUncheckedCreateNestedManyWithoutInvoiceInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutRecurringBillableInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutRecurringBillableInput, InvoiceUncheckedCreateWithoutRecurringBillableInput>
  }

  export type InvoiceCreateManyRecurringBillableInputEnvelope = {
    data: InvoiceCreateManyRecurringBillableInput | InvoiceCreateManyRecurringBillableInput[]
    skipDuplicates?: boolean
  }

  export type PropertyCreateWithoutRecurringBillableInput = {
    id?: string
    name: string
    addressLine1: string
    addressLine2?: string | null
    city: string
    state: string
    zip: string
    createdAt?: Date | string
    updatedAt?: Date | string
    imageUrl?: string | null
    propertyStatus?: $Enums.PropertyStatus
    propertyType?: $Enums.PropertyType
    amenities?: PropertyCreateamenitiesInput | string[]
    countryCode?: string
    features?: PropertyCreatefeaturesInput | string[]
    files?: FileCreateNestedManyWithoutPropertyInput
    landlord: UserCreateNestedOneWithoutPropertyInput
    unit?: UnitCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutRecurringBillableInput = {
    id?: string
    name: string
    addressLine1: string
    addressLine2?: string | null
    city: string
    state: string
    zip: string
    createdAt?: Date | string
    updatedAt?: Date | string
    imageUrl?: string | null
    propertyStatus?: $Enums.PropertyStatus
    propertyType?: $Enums.PropertyType
    amenities?: PropertyCreateamenitiesInput | string[]
    countryCode?: string
    features?: PropertyCreatefeaturesInput | string[]
    landlordId: string
    files?: FileUncheckedCreateNestedManyWithoutPropertyInput
    unit?: UnitUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutRecurringBillableInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutRecurringBillableInput, PropertyUncheckedCreateWithoutRecurringBillableInput>
  }

  export type LeaseUpsertWithoutRecurringBillableInput = {
    update: XOR<LeaseUpdateWithoutRecurringBillableInput, LeaseUncheckedUpdateWithoutRecurringBillableInput>
    create: XOR<LeaseCreateWithoutRecurringBillableInput, LeaseUncheckedCreateWithoutRecurringBillableInput>
    where?: LeaseWhereInput
  }

  export type LeaseUpdateToOneWithWhereWithoutRecurringBillableInput = {
    where?: LeaseWhereInput
    data: XOR<LeaseUpdateWithoutRecurringBillableInput, LeaseUncheckedUpdateWithoutRecurringBillableInput>
  }

  export type LeaseUpdateWithoutRecurringBillableInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rentDueCurrency?: StringFieldUpdateOperationsInput | string
    automaticInvoice?: BoolFieldUpdateOperationsInput | boolean
    invoiceCycle?: EnumInvoiceCycleFieldUpdateOperationsInput | $Enums.InvoiceCycle
    leaseType?: EnumLeaseTermTypeFieldUpdateOperationsInput | $Enums.LeaseTermType
    File?: FileUpdateManyWithoutLeaseNestedInput
    invoice?: InvoiceUpdateManyWithoutLeaseNestedInput
    unit?: UnitUpdateOneWithoutLeaseNestedInput
    maintenanceRequest?: MaintenanceRequestUpdateManyWithoutLeaseNestedInput
    tenantLease?: TenantLeaseUpdateManyWithoutLeaseNestedInput
    transactions?: TransactionsUpdateManyWithoutLeaseNestedInput
  }

  export type LeaseUncheckedUpdateWithoutRecurringBillableInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rentDueCurrency?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    automaticInvoice?: BoolFieldUpdateOperationsInput | boolean
    invoiceCycle?: EnumInvoiceCycleFieldUpdateOperationsInput | $Enums.InvoiceCycle
    leaseType?: EnumLeaseTermTypeFieldUpdateOperationsInput | $Enums.LeaseTermType
    File?: FileUncheckedUpdateManyWithoutLeaseNestedInput
    invoice?: InvoiceUncheckedUpdateManyWithoutLeaseNestedInput
    maintenanceRequest?: MaintenanceRequestUncheckedUpdateManyWithoutLeaseNestedInput
    tenantLease?: TenantLeaseUncheckedUpdateManyWithoutLeaseNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutLeaseNestedInput
  }

  export type TenantUpsertWithoutRecurringBillableInput = {
    update: XOR<TenantUpdateWithoutRecurringBillableInput, TenantUncheckedUpdateWithoutRecurringBillableInput>
    create: XOR<TenantCreateWithoutRecurringBillableInput, TenantUncheckedCreateWithoutRecurringBillableInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutRecurringBillableInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutRecurringBillableInput, TenantUncheckedUpdateWithoutRecurringBillableInput>
  }

  export type TenantUpdateWithoutRecurringBillableInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantEmergencyContact?: NullableJsonNullValueInput | InputJsonValue
    tenantIncome?: NullableJsonNullValueInput | InputJsonValue
    additionalEmails?: TenantUpdateadditionalEmailsInput | string[]
    additionalPhones?: TenantUpdateadditionalPhonesInput | string[]
    emergencyContacts?: NullableJsonNullValueInput | InputJsonValue
    vehicles?: NullableJsonNullValueInput | InputJsonValue
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    paystackCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    files?: FileUpdateManyWithoutTenantNestedInput
    Invoice?: InvoiceUpdateManyWithoutTenantNestedInput
    landlord?: UserUpdateOneRequiredWithoutTenantNestedInput
    tenantLease?: TenantLeaseUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutRecurringBillableInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    landlordId?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantEmergencyContact?: NullableJsonNullValueInput | InputJsonValue
    tenantIncome?: NullableJsonNullValueInput | InputJsonValue
    additionalEmails?: TenantUpdateadditionalEmailsInput | string[]
    additionalPhones?: TenantUpdateadditionalPhonesInput | string[]
    emergencyContacts?: NullableJsonNullValueInput | InputJsonValue
    vehicles?: NullableJsonNullValueInput | InputJsonValue
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    paystackCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    files?: FileUncheckedUpdateManyWithoutTenantNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    tenantLease?: TenantLeaseUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type InvoiceUpsertWithWhereUniqueWithoutRecurringBillableInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutRecurringBillableInput, InvoiceUncheckedUpdateWithoutRecurringBillableInput>
    create: XOR<InvoiceCreateWithoutRecurringBillableInput, InvoiceUncheckedCreateWithoutRecurringBillableInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutRecurringBillableInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutRecurringBillableInput, InvoiceUncheckedUpdateWithoutRecurringBillableInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutRecurringBillableInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutRecurringBillableInput>
  }

  export type PropertyUpsertWithoutRecurringBillableInput = {
    update: XOR<PropertyUpdateWithoutRecurringBillableInput, PropertyUncheckedUpdateWithoutRecurringBillableInput>
    create: XOR<PropertyCreateWithoutRecurringBillableInput, PropertyUncheckedCreateWithoutRecurringBillableInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutRecurringBillableInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutRecurringBillableInput, PropertyUncheckedUpdateWithoutRecurringBillableInput>
  }

  export type PropertyUpdateWithoutRecurringBillableInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    propertyStatus?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    amenities?: PropertyUpdateamenitiesInput | string[]
    countryCode?: StringFieldUpdateOperationsInput | string
    features?: PropertyUpdatefeaturesInput | string[]
    files?: FileUpdateManyWithoutPropertyNestedInput
    landlord?: UserUpdateOneRequiredWithoutPropertyNestedInput
    unit?: UnitUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutRecurringBillableInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    propertyStatus?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    amenities?: PropertyUpdateamenitiesInput | string[]
    countryCode?: StringFieldUpdateOperationsInput | string
    features?: PropertyUpdatefeaturesInput | string[]
    landlordId?: StringFieldUpdateOperationsInput | string
    files?: FileUncheckedUpdateManyWithoutPropertyNestedInput
    unit?: UnitUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type InvoiceCreateWithoutTransactionsInput = {
    id?: string
    description: string
    dueAmount: number
    category: $Enums.InvoiceCategory
    status: $Enums.InvoiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paystackId: string
    dueDate?: Date | string | null
    lineItems?: NullableJsonNullValueInput | InputJsonValue
    File?: FileCreateNestedManyWithoutInvoiceInput
    lease?: LeaseCreateNestedOneWithoutInvoiceInput
    tenant: TenantCreateNestedOneWithoutInvoiceInput
    recurringBillable?: RecurringBillableCreateNestedOneWithoutInvoiceInput
    landlord: UserCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutTransactionsInput = {
    id?: string
    leaseId?: string | null
    description: string
    dueAmount: number
    category: $Enums.InvoiceCategory
    status: $Enums.InvoiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paystackId: string
    dueDate?: Date | string | null
    lineItems?: NullableJsonNullValueInput | InputJsonValue
    landlordId: string
    tenantId: string
    recurringBillableId?: string | null
    File?: FileUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutTransactionsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutTransactionsInput, InvoiceUncheckedCreateWithoutTransactionsInput>
  }

  export type LeaseCreateWithoutTransactionsInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    rent: number
    deposit: number
    status: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    rentDueCurrency: string
    automaticInvoice?: boolean
    invoiceCycle?: $Enums.InvoiceCycle
    leaseType: $Enums.LeaseTermType
    File?: FileCreateNestedManyWithoutLeaseInput
    invoice?: InvoiceCreateNestedManyWithoutLeaseInput
    unit?: UnitCreateNestedOneWithoutLeaseInput
    maintenanceRequest?: MaintenanceRequestCreateNestedManyWithoutLeaseInput
    tenantLease?: TenantLeaseCreateNestedManyWithoutLeaseInput
    recurringBillable?: RecurringBillableCreateNestedManyWithoutLeaseInput
  }

  export type LeaseUncheckedCreateWithoutTransactionsInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    rent: number
    deposit: number
    status: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    rentDueCurrency: string
    unitId?: string | null
    automaticInvoice?: boolean
    invoiceCycle?: $Enums.InvoiceCycle
    leaseType: $Enums.LeaseTermType
    File?: FileUncheckedCreateNestedManyWithoutLeaseInput
    invoice?: InvoiceUncheckedCreateNestedManyWithoutLeaseInput
    maintenanceRequest?: MaintenanceRequestUncheckedCreateNestedManyWithoutLeaseInput
    tenantLease?: TenantLeaseUncheckedCreateNestedManyWithoutLeaseInput
    recurringBillable?: RecurringBillableUncheckedCreateNestedManyWithoutLeaseInput
  }

  export type LeaseCreateOrConnectWithoutTransactionsInput = {
    where: LeaseWhereUniqueInput
    create: XOR<LeaseCreateWithoutTransactionsInput, LeaseUncheckedCreateWithoutTransactionsInput>
  }

  export type InvoiceUpsertWithoutTransactionsInput = {
    update: XOR<InvoiceUpdateWithoutTransactionsInput, InvoiceUncheckedUpdateWithoutTransactionsInput>
    create: XOR<InvoiceCreateWithoutTransactionsInput, InvoiceUncheckedCreateWithoutTransactionsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutTransactionsInput, InvoiceUncheckedUpdateWithoutTransactionsInput>
  }

  export type InvoiceUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dueAmount?: FloatFieldUpdateOperationsInput | number
    category?: EnumInvoiceCategoryFieldUpdateOperationsInput | $Enums.InvoiceCategory
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paystackId?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lineItems?: NullableJsonNullValueInput | InputJsonValue
    File?: FileUpdateManyWithoutInvoiceNestedInput
    lease?: LeaseUpdateOneWithoutInvoiceNestedInput
    tenant?: TenantUpdateOneRequiredWithoutInvoiceNestedInput
    recurringBillable?: RecurringBillableUpdateOneWithoutInvoiceNestedInput
    landlord?: UserUpdateOneRequiredWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaseId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    dueAmount?: FloatFieldUpdateOperationsInput | number
    category?: EnumInvoiceCategoryFieldUpdateOperationsInput | $Enums.InvoiceCategory
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paystackId?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lineItems?: NullableJsonNullValueInput | InputJsonValue
    landlordId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    recurringBillableId?: NullableStringFieldUpdateOperationsInput | string | null
    File?: FileUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type LeaseUpsertWithoutTransactionsInput = {
    update: XOR<LeaseUpdateWithoutTransactionsInput, LeaseUncheckedUpdateWithoutTransactionsInput>
    create: XOR<LeaseCreateWithoutTransactionsInput, LeaseUncheckedCreateWithoutTransactionsInput>
    where?: LeaseWhereInput
  }

  export type LeaseUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: LeaseWhereInput
    data: XOR<LeaseUpdateWithoutTransactionsInput, LeaseUncheckedUpdateWithoutTransactionsInput>
  }

  export type LeaseUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rentDueCurrency?: StringFieldUpdateOperationsInput | string
    automaticInvoice?: BoolFieldUpdateOperationsInput | boolean
    invoiceCycle?: EnumInvoiceCycleFieldUpdateOperationsInput | $Enums.InvoiceCycle
    leaseType?: EnumLeaseTermTypeFieldUpdateOperationsInput | $Enums.LeaseTermType
    File?: FileUpdateManyWithoutLeaseNestedInput
    invoice?: InvoiceUpdateManyWithoutLeaseNestedInput
    unit?: UnitUpdateOneWithoutLeaseNestedInput
    maintenanceRequest?: MaintenanceRequestUpdateManyWithoutLeaseNestedInput
    tenantLease?: TenantLeaseUpdateManyWithoutLeaseNestedInput
    recurringBillable?: RecurringBillableUpdateManyWithoutLeaseNestedInput
  }

  export type LeaseUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rentDueCurrency?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    automaticInvoice?: BoolFieldUpdateOperationsInput | boolean
    invoiceCycle?: EnumInvoiceCycleFieldUpdateOperationsInput | $Enums.InvoiceCycle
    leaseType?: EnumLeaseTermTypeFieldUpdateOperationsInput | $Enums.LeaseTermType
    File?: FileUncheckedUpdateManyWithoutLeaseNestedInput
    invoice?: InvoiceUncheckedUpdateManyWithoutLeaseNestedInput
    maintenanceRequest?: MaintenanceRequestUncheckedUpdateManyWithoutLeaseNestedInput
    tenantLease?: TenantLeaseUncheckedUpdateManyWithoutLeaseNestedInput
    recurringBillable?: RecurringBillableUncheckedUpdateManyWithoutLeaseNestedInput
  }

  export type LeaseCreateWithoutTenantLeaseInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    rent: number
    deposit: number
    status: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    rentDueCurrency: string
    automaticInvoice?: boolean
    invoiceCycle?: $Enums.InvoiceCycle
    leaseType: $Enums.LeaseTermType
    File?: FileCreateNestedManyWithoutLeaseInput
    invoice?: InvoiceCreateNestedManyWithoutLeaseInput
    unit?: UnitCreateNestedOneWithoutLeaseInput
    maintenanceRequest?: MaintenanceRequestCreateNestedManyWithoutLeaseInput
    transactions?: TransactionsCreateNestedManyWithoutLeaseInput
    recurringBillable?: RecurringBillableCreateNestedManyWithoutLeaseInput
  }

  export type LeaseUncheckedCreateWithoutTenantLeaseInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    rent: number
    deposit: number
    status: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    rentDueCurrency: string
    unitId?: string | null
    automaticInvoice?: boolean
    invoiceCycle?: $Enums.InvoiceCycle
    leaseType: $Enums.LeaseTermType
    File?: FileUncheckedCreateNestedManyWithoutLeaseInput
    invoice?: InvoiceUncheckedCreateNestedManyWithoutLeaseInput
    maintenanceRequest?: MaintenanceRequestUncheckedCreateNestedManyWithoutLeaseInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutLeaseInput
    recurringBillable?: RecurringBillableUncheckedCreateNestedManyWithoutLeaseInput
  }

  export type LeaseCreateOrConnectWithoutTenantLeaseInput = {
    where: LeaseWhereUniqueInput
    create: XOR<LeaseCreateWithoutTenantLeaseInput, LeaseUncheckedCreateWithoutTenantLeaseInput>
  }

  export type TenantCreateWithoutTenantLeaseInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    firstName: string
    lastName: string
    phone: string
    dateOfBirth?: Date | string | null
    tenantEmergencyContact?: NullableJsonNullValueInput | InputJsonValue
    tenantIncome?: NullableJsonNullValueInput | InputJsonValue
    additionalEmails?: TenantCreateadditionalEmailsInput | string[]
    additionalPhones?: TenantCreateadditionalPhonesInput | string[]
    emergencyContacts?: NullableJsonNullValueInput | InputJsonValue
    vehicles?: NullableJsonNullValueInput | InputJsonValue
    avatarUrl?: string | null
    fullName?: string | null
    paystackCustomerId?: string | null
    files?: FileCreateNestedManyWithoutTenantInput
    Invoice?: InvoiceCreateNestedManyWithoutTenantInput
    landlord: UserCreateNestedOneWithoutTenantInput
    recurringBillable?: RecurringBillableCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutTenantLeaseInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    firstName: string
    lastName: string
    phone: string
    landlordId: string
    dateOfBirth?: Date | string | null
    tenantEmergencyContact?: NullableJsonNullValueInput | InputJsonValue
    tenantIncome?: NullableJsonNullValueInput | InputJsonValue
    additionalEmails?: TenantCreateadditionalEmailsInput | string[]
    additionalPhones?: TenantCreateadditionalPhonesInput | string[]
    emergencyContacts?: NullableJsonNullValueInput | InputJsonValue
    vehicles?: NullableJsonNullValueInput | InputJsonValue
    avatarUrl?: string | null
    fullName?: string | null
    paystackCustomerId?: string | null
    files?: FileUncheckedCreateNestedManyWithoutTenantInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    recurringBillable?: RecurringBillableUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutTenantLeaseInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutTenantLeaseInput, TenantUncheckedCreateWithoutTenantLeaseInput>
  }

  export type LeaseUpsertWithoutTenantLeaseInput = {
    update: XOR<LeaseUpdateWithoutTenantLeaseInput, LeaseUncheckedUpdateWithoutTenantLeaseInput>
    create: XOR<LeaseCreateWithoutTenantLeaseInput, LeaseUncheckedCreateWithoutTenantLeaseInput>
    where?: LeaseWhereInput
  }

  export type LeaseUpdateToOneWithWhereWithoutTenantLeaseInput = {
    where?: LeaseWhereInput
    data: XOR<LeaseUpdateWithoutTenantLeaseInput, LeaseUncheckedUpdateWithoutTenantLeaseInput>
  }

  export type LeaseUpdateWithoutTenantLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rentDueCurrency?: StringFieldUpdateOperationsInput | string
    automaticInvoice?: BoolFieldUpdateOperationsInput | boolean
    invoiceCycle?: EnumInvoiceCycleFieldUpdateOperationsInput | $Enums.InvoiceCycle
    leaseType?: EnumLeaseTermTypeFieldUpdateOperationsInput | $Enums.LeaseTermType
    File?: FileUpdateManyWithoutLeaseNestedInput
    invoice?: InvoiceUpdateManyWithoutLeaseNestedInput
    unit?: UnitUpdateOneWithoutLeaseNestedInput
    maintenanceRequest?: MaintenanceRequestUpdateManyWithoutLeaseNestedInput
    transactions?: TransactionsUpdateManyWithoutLeaseNestedInput
    recurringBillable?: RecurringBillableUpdateManyWithoutLeaseNestedInput
  }

  export type LeaseUncheckedUpdateWithoutTenantLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rentDueCurrency?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    automaticInvoice?: BoolFieldUpdateOperationsInput | boolean
    invoiceCycle?: EnumInvoiceCycleFieldUpdateOperationsInput | $Enums.InvoiceCycle
    leaseType?: EnumLeaseTermTypeFieldUpdateOperationsInput | $Enums.LeaseTermType
    File?: FileUncheckedUpdateManyWithoutLeaseNestedInput
    invoice?: InvoiceUncheckedUpdateManyWithoutLeaseNestedInput
    maintenanceRequest?: MaintenanceRequestUncheckedUpdateManyWithoutLeaseNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutLeaseNestedInput
    recurringBillable?: RecurringBillableUncheckedUpdateManyWithoutLeaseNestedInput
  }

  export type TenantUpsertWithoutTenantLeaseInput = {
    update: XOR<TenantUpdateWithoutTenantLeaseInput, TenantUncheckedUpdateWithoutTenantLeaseInput>
    create: XOR<TenantCreateWithoutTenantLeaseInput, TenantUncheckedCreateWithoutTenantLeaseInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutTenantLeaseInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutTenantLeaseInput, TenantUncheckedUpdateWithoutTenantLeaseInput>
  }

  export type TenantUpdateWithoutTenantLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantEmergencyContact?: NullableJsonNullValueInput | InputJsonValue
    tenantIncome?: NullableJsonNullValueInput | InputJsonValue
    additionalEmails?: TenantUpdateadditionalEmailsInput | string[]
    additionalPhones?: TenantUpdateadditionalPhonesInput | string[]
    emergencyContacts?: NullableJsonNullValueInput | InputJsonValue
    vehicles?: NullableJsonNullValueInput | InputJsonValue
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    paystackCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    files?: FileUpdateManyWithoutTenantNestedInput
    Invoice?: InvoiceUpdateManyWithoutTenantNestedInput
    landlord?: UserUpdateOneRequiredWithoutTenantNestedInput
    recurringBillable?: RecurringBillableUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutTenantLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    landlordId?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantEmergencyContact?: NullableJsonNullValueInput | InputJsonValue
    tenantIncome?: NullableJsonNullValueInput | InputJsonValue
    additionalEmails?: TenantUpdateadditionalEmailsInput | string[]
    additionalPhones?: TenantUpdateadditionalPhonesInput | string[]
    emergencyContacts?: NullableJsonNullValueInput | InputJsonValue
    vehicles?: NullableJsonNullValueInput | InputJsonValue
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    paystackCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    files?: FileUncheckedUpdateManyWithoutTenantNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    recurringBillable?: RecurringBillableUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type FileCreateWithoutMaintenanceRequestInput = {
    id?: string
    name: string
    url: string
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    size?: number | null
    type?: string | null
    invoice?: InvoiceCreateNestedOneWithoutFileInput
    lease?: LeaseCreateNestedOneWithoutFileInput
    property?: PropertyCreateNestedOneWithoutFilesInput
    tenant?: TenantCreateNestedOneWithoutFilesInput
  }

  export type FileUncheckedCreateWithoutMaintenanceRequestInput = {
    id?: string
    name: string
    url: string
    ownerId: string
    tenantId?: string | null
    propertyId?: string | null
    leaseId?: string | null
    invoiceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    size?: number | null
    type?: string | null
  }

  export type FileCreateOrConnectWithoutMaintenanceRequestInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutMaintenanceRequestInput, FileUncheckedCreateWithoutMaintenanceRequestInput>
  }

  export type FileCreateManyMaintenanceRequestInputEnvelope = {
    data: FileCreateManyMaintenanceRequestInput | FileCreateManyMaintenanceRequestInput[]
    skipDuplicates?: boolean
  }

  export type LeaseCreateWithoutMaintenanceRequestInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    rent: number
    deposit: number
    status: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    rentDueCurrency: string
    automaticInvoice?: boolean
    invoiceCycle?: $Enums.InvoiceCycle
    leaseType: $Enums.LeaseTermType
    File?: FileCreateNestedManyWithoutLeaseInput
    invoice?: InvoiceCreateNestedManyWithoutLeaseInput
    unit?: UnitCreateNestedOneWithoutLeaseInput
    tenantLease?: TenantLeaseCreateNestedManyWithoutLeaseInput
    transactions?: TransactionsCreateNestedManyWithoutLeaseInput
    recurringBillable?: RecurringBillableCreateNestedManyWithoutLeaseInput
  }

  export type LeaseUncheckedCreateWithoutMaintenanceRequestInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    rent: number
    deposit: number
    status: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    rentDueCurrency: string
    unitId?: string | null
    automaticInvoice?: boolean
    invoiceCycle?: $Enums.InvoiceCycle
    leaseType: $Enums.LeaseTermType
    File?: FileUncheckedCreateNestedManyWithoutLeaseInput
    invoice?: InvoiceUncheckedCreateNestedManyWithoutLeaseInput
    tenantLease?: TenantLeaseUncheckedCreateNestedManyWithoutLeaseInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutLeaseInput
    recurringBillable?: RecurringBillableUncheckedCreateNestedManyWithoutLeaseInput
  }

  export type LeaseCreateOrConnectWithoutMaintenanceRequestInput = {
    where: LeaseWhereUniqueInput
    create: XOR<LeaseCreateWithoutMaintenanceRequestInput, LeaseUncheckedCreateWithoutMaintenanceRequestInput>
  }

  export type FileUpsertWithWhereUniqueWithoutMaintenanceRequestInput = {
    where: FileWhereUniqueInput
    update: XOR<FileUpdateWithoutMaintenanceRequestInput, FileUncheckedUpdateWithoutMaintenanceRequestInput>
    create: XOR<FileCreateWithoutMaintenanceRequestInput, FileUncheckedCreateWithoutMaintenanceRequestInput>
  }

  export type FileUpdateWithWhereUniqueWithoutMaintenanceRequestInput = {
    where: FileWhereUniqueInput
    data: XOR<FileUpdateWithoutMaintenanceRequestInput, FileUncheckedUpdateWithoutMaintenanceRequestInput>
  }

  export type FileUpdateManyWithWhereWithoutMaintenanceRequestInput = {
    where: FileScalarWhereInput
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyWithoutMaintenanceRequestInput>
  }

  export type LeaseUpsertWithoutMaintenanceRequestInput = {
    update: XOR<LeaseUpdateWithoutMaintenanceRequestInput, LeaseUncheckedUpdateWithoutMaintenanceRequestInput>
    create: XOR<LeaseCreateWithoutMaintenanceRequestInput, LeaseUncheckedCreateWithoutMaintenanceRequestInput>
    where?: LeaseWhereInput
  }

  export type LeaseUpdateToOneWithWhereWithoutMaintenanceRequestInput = {
    where?: LeaseWhereInput
    data: XOR<LeaseUpdateWithoutMaintenanceRequestInput, LeaseUncheckedUpdateWithoutMaintenanceRequestInput>
  }

  export type LeaseUpdateWithoutMaintenanceRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rentDueCurrency?: StringFieldUpdateOperationsInput | string
    automaticInvoice?: BoolFieldUpdateOperationsInput | boolean
    invoiceCycle?: EnumInvoiceCycleFieldUpdateOperationsInput | $Enums.InvoiceCycle
    leaseType?: EnumLeaseTermTypeFieldUpdateOperationsInput | $Enums.LeaseTermType
    File?: FileUpdateManyWithoutLeaseNestedInput
    invoice?: InvoiceUpdateManyWithoutLeaseNestedInput
    unit?: UnitUpdateOneWithoutLeaseNestedInput
    tenantLease?: TenantLeaseUpdateManyWithoutLeaseNestedInput
    transactions?: TransactionsUpdateManyWithoutLeaseNestedInput
    recurringBillable?: RecurringBillableUpdateManyWithoutLeaseNestedInput
  }

  export type LeaseUncheckedUpdateWithoutMaintenanceRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rentDueCurrency?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    automaticInvoice?: BoolFieldUpdateOperationsInput | boolean
    invoiceCycle?: EnumInvoiceCycleFieldUpdateOperationsInput | $Enums.InvoiceCycle
    leaseType?: EnumLeaseTermTypeFieldUpdateOperationsInput | $Enums.LeaseTermType
    File?: FileUncheckedUpdateManyWithoutLeaseNestedInput
    invoice?: InvoiceUncheckedUpdateManyWithoutLeaseNestedInput
    tenantLease?: TenantLeaseUncheckedUpdateManyWithoutLeaseNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutLeaseNestedInput
    recurringBillable?: RecurringBillableUncheckedUpdateManyWithoutLeaseNestedInput
  }

  export type InvoiceCreateWithoutFileInput = {
    id?: string
    description: string
    dueAmount: number
    category: $Enums.InvoiceCategory
    status: $Enums.InvoiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paystackId: string
    dueDate?: Date | string | null
    lineItems?: NullableJsonNullValueInput | InputJsonValue
    lease?: LeaseCreateNestedOneWithoutInvoiceInput
    tenant: TenantCreateNestedOneWithoutInvoiceInput
    transactions?: TransactionsCreateNestedManyWithoutInvoiceInput
    recurringBillable?: RecurringBillableCreateNestedOneWithoutInvoiceInput
    landlord: UserCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutFileInput = {
    id?: string
    leaseId?: string | null
    description: string
    dueAmount: number
    category: $Enums.InvoiceCategory
    status: $Enums.InvoiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paystackId: string
    dueDate?: Date | string | null
    lineItems?: NullableJsonNullValueInput | InputJsonValue
    landlordId: string
    tenantId: string
    recurringBillableId?: string | null
    transactions?: TransactionsUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutFileInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutFileInput, InvoiceUncheckedCreateWithoutFileInput>
  }

  export type LeaseCreateWithoutFileInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    rent: number
    deposit: number
    status: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    rentDueCurrency: string
    automaticInvoice?: boolean
    invoiceCycle?: $Enums.InvoiceCycle
    leaseType: $Enums.LeaseTermType
    invoice?: InvoiceCreateNestedManyWithoutLeaseInput
    unit?: UnitCreateNestedOneWithoutLeaseInput
    maintenanceRequest?: MaintenanceRequestCreateNestedManyWithoutLeaseInput
    tenantLease?: TenantLeaseCreateNestedManyWithoutLeaseInput
    transactions?: TransactionsCreateNestedManyWithoutLeaseInput
    recurringBillable?: RecurringBillableCreateNestedManyWithoutLeaseInput
  }

  export type LeaseUncheckedCreateWithoutFileInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    rent: number
    deposit: number
    status: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    rentDueCurrency: string
    unitId?: string | null
    automaticInvoice?: boolean
    invoiceCycle?: $Enums.InvoiceCycle
    leaseType: $Enums.LeaseTermType
    invoice?: InvoiceUncheckedCreateNestedManyWithoutLeaseInput
    maintenanceRequest?: MaintenanceRequestUncheckedCreateNestedManyWithoutLeaseInput
    tenantLease?: TenantLeaseUncheckedCreateNestedManyWithoutLeaseInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutLeaseInput
    recurringBillable?: RecurringBillableUncheckedCreateNestedManyWithoutLeaseInput
  }

  export type LeaseCreateOrConnectWithoutFileInput = {
    where: LeaseWhereUniqueInput
    create: XOR<LeaseCreateWithoutFileInput, LeaseUncheckedCreateWithoutFileInput>
  }

  export type MaintenanceRequestCreateWithoutFileInput = {
    id?: string
    description?: string | null
    status?: $Enums.MaintenanceRequestStatus | null
    priority: $Enums.MaintenanceRequestPriority
    createdAt?: Date | string
    updatedAt?: Date | string
    lease: LeaseCreateNestedOneWithoutMaintenanceRequestInput
  }

  export type MaintenanceRequestUncheckedCreateWithoutFileInput = {
    id?: string
    leaseId: string
    description?: string | null
    status?: $Enums.MaintenanceRequestStatus | null
    priority: $Enums.MaintenanceRequestPriority
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaintenanceRequestCreateOrConnectWithoutFileInput = {
    where: MaintenanceRequestWhereUniqueInput
    create: XOR<MaintenanceRequestCreateWithoutFileInput, MaintenanceRequestUncheckedCreateWithoutFileInput>
  }

  export type PropertyCreateWithoutFilesInput = {
    id?: string
    name: string
    addressLine1: string
    addressLine2?: string | null
    city: string
    state: string
    zip: string
    createdAt?: Date | string
    updatedAt?: Date | string
    imageUrl?: string | null
    propertyStatus?: $Enums.PropertyStatus
    propertyType?: $Enums.PropertyType
    amenities?: PropertyCreateamenitiesInput | string[]
    countryCode?: string
    features?: PropertyCreatefeaturesInput | string[]
    landlord: UserCreateNestedOneWithoutPropertyInput
    unit?: UnitCreateNestedManyWithoutPropertyInput
    recurringBillable?: RecurringBillableCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutFilesInput = {
    id?: string
    name: string
    addressLine1: string
    addressLine2?: string | null
    city: string
    state: string
    zip: string
    createdAt?: Date | string
    updatedAt?: Date | string
    imageUrl?: string | null
    propertyStatus?: $Enums.PropertyStatus
    propertyType?: $Enums.PropertyType
    amenities?: PropertyCreateamenitiesInput | string[]
    countryCode?: string
    features?: PropertyCreatefeaturesInput | string[]
    landlordId: string
    unit?: UnitUncheckedCreateNestedManyWithoutPropertyInput
    recurringBillable?: RecurringBillableUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutFilesInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutFilesInput, PropertyUncheckedCreateWithoutFilesInput>
  }

  export type TenantCreateWithoutFilesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    firstName: string
    lastName: string
    phone: string
    dateOfBirth?: Date | string | null
    tenantEmergencyContact?: NullableJsonNullValueInput | InputJsonValue
    tenantIncome?: NullableJsonNullValueInput | InputJsonValue
    additionalEmails?: TenantCreateadditionalEmailsInput | string[]
    additionalPhones?: TenantCreateadditionalPhonesInput | string[]
    emergencyContacts?: NullableJsonNullValueInput | InputJsonValue
    vehicles?: NullableJsonNullValueInput | InputJsonValue
    avatarUrl?: string | null
    fullName?: string | null
    paystackCustomerId?: string | null
    Invoice?: InvoiceCreateNestedManyWithoutTenantInput
    landlord: UserCreateNestedOneWithoutTenantInput
    tenantLease?: TenantLeaseCreateNestedManyWithoutTenantInput
    recurringBillable?: RecurringBillableCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutFilesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    firstName: string
    lastName: string
    phone: string
    landlordId: string
    dateOfBirth?: Date | string | null
    tenantEmergencyContact?: NullableJsonNullValueInput | InputJsonValue
    tenantIncome?: NullableJsonNullValueInput | InputJsonValue
    additionalEmails?: TenantCreateadditionalEmailsInput | string[]
    additionalPhones?: TenantCreateadditionalPhonesInput | string[]
    emergencyContacts?: NullableJsonNullValueInput | InputJsonValue
    vehicles?: NullableJsonNullValueInput | InputJsonValue
    avatarUrl?: string | null
    fullName?: string | null
    paystackCustomerId?: string | null
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    tenantLease?: TenantLeaseUncheckedCreateNestedManyWithoutTenantInput
    recurringBillable?: RecurringBillableUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutFilesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutFilesInput, TenantUncheckedCreateWithoutFilesInput>
  }

  export type InvoiceUpsertWithoutFileInput = {
    update: XOR<InvoiceUpdateWithoutFileInput, InvoiceUncheckedUpdateWithoutFileInput>
    create: XOR<InvoiceCreateWithoutFileInput, InvoiceUncheckedCreateWithoutFileInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutFileInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutFileInput, InvoiceUncheckedUpdateWithoutFileInput>
  }

  export type InvoiceUpdateWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dueAmount?: FloatFieldUpdateOperationsInput | number
    category?: EnumInvoiceCategoryFieldUpdateOperationsInput | $Enums.InvoiceCategory
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paystackId?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lineItems?: NullableJsonNullValueInput | InputJsonValue
    lease?: LeaseUpdateOneWithoutInvoiceNestedInput
    tenant?: TenantUpdateOneRequiredWithoutInvoiceNestedInput
    transactions?: TransactionsUpdateManyWithoutInvoiceNestedInput
    recurringBillable?: RecurringBillableUpdateOneWithoutInvoiceNestedInput
    landlord?: UserUpdateOneRequiredWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaseId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    dueAmount?: FloatFieldUpdateOperationsInput | number
    category?: EnumInvoiceCategoryFieldUpdateOperationsInput | $Enums.InvoiceCategory
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paystackId?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lineItems?: NullableJsonNullValueInput | InputJsonValue
    landlordId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    recurringBillableId?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: TransactionsUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type LeaseUpsertWithoutFileInput = {
    update: XOR<LeaseUpdateWithoutFileInput, LeaseUncheckedUpdateWithoutFileInput>
    create: XOR<LeaseCreateWithoutFileInput, LeaseUncheckedCreateWithoutFileInput>
    where?: LeaseWhereInput
  }

  export type LeaseUpdateToOneWithWhereWithoutFileInput = {
    where?: LeaseWhereInput
    data: XOR<LeaseUpdateWithoutFileInput, LeaseUncheckedUpdateWithoutFileInput>
  }

  export type LeaseUpdateWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rentDueCurrency?: StringFieldUpdateOperationsInput | string
    automaticInvoice?: BoolFieldUpdateOperationsInput | boolean
    invoiceCycle?: EnumInvoiceCycleFieldUpdateOperationsInput | $Enums.InvoiceCycle
    leaseType?: EnumLeaseTermTypeFieldUpdateOperationsInput | $Enums.LeaseTermType
    invoice?: InvoiceUpdateManyWithoutLeaseNestedInput
    unit?: UnitUpdateOneWithoutLeaseNestedInput
    maintenanceRequest?: MaintenanceRequestUpdateManyWithoutLeaseNestedInput
    tenantLease?: TenantLeaseUpdateManyWithoutLeaseNestedInput
    transactions?: TransactionsUpdateManyWithoutLeaseNestedInput
    recurringBillable?: RecurringBillableUpdateManyWithoutLeaseNestedInput
  }

  export type LeaseUncheckedUpdateWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rentDueCurrency?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    automaticInvoice?: BoolFieldUpdateOperationsInput | boolean
    invoiceCycle?: EnumInvoiceCycleFieldUpdateOperationsInput | $Enums.InvoiceCycle
    leaseType?: EnumLeaseTermTypeFieldUpdateOperationsInput | $Enums.LeaseTermType
    invoice?: InvoiceUncheckedUpdateManyWithoutLeaseNestedInput
    maintenanceRequest?: MaintenanceRequestUncheckedUpdateManyWithoutLeaseNestedInput
    tenantLease?: TenantLeaseUncheckedUpdateManyWithoutLeaseNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutLeaseNestedInput
    recurringBillable?: RecurringBillableUncheckedUpdateManyWithoutLeaseNestedInput
  }

  export type MaintenanceRequestUpsertWithoutFileInput = {
    update: XOR<MaintenanceRequestUpdateWithoutFileInput, MaintenanceRequestUncheckedUpdateWithoutFileInput>
    create: XOR<MaintenanceRequestCreateWithoutFileInput, MaintenanceRequestUncheckedCreateWithoutFileInput>
    where?: MaintenanceRequestWhereInput
  }

  export type MaintenanceRequestUpdateToOneWithWhereWithoutFileInput = {
    where?: MaintenanceRequestWhereInput
    data: XOR<MaintenanceRequestUpdateWithoutFileInput, MaintenanceRequestUncheckedUpdateWithoutFileInput>
  }

  export type MaintenanceRequestUpdateWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumMaintenanceRequestStatusFieldUpdateOperationsInput | $Enums.MaintenanceRequestStatus | null
    priority?: EnumMaintenanceRequestPriorityFieldUpdateOperationsInput | $Enums.MaintenanceRequestPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lease?: LeaseUpdateOneRequiredWithoutMaintenanceRequestNestedInput
  }

  export type MaintenanceRequestUncheckedUpdateWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaseId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumMaintenanceRequestStatusFieldUpdateOperationsInput | $Enums.MaintenanceRequestStatus | null
    priority?: EnumMaintenanceRequestPriorityFieldUpdateOperationsInput | $Enums.MaintenanceRequestPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyUpsertWithoutFilesInput = {
    update: XOR<PropertyUpdateWithoutFilesInput, PropertyUncheckedUpdateWithoutFilesInput>
    create: XOR<PropertyCreateWithoutFilesInput, PropertyUncheckedCreateWithoutFilesInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutFilesInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutFilesInput, PropertyUncheckedUpdateWithoutFilesInput>
  }

  export type PropertyUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    propertyStatus?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    amenities?: PropertyUpdateamenitiesInput | string[]
    countryCode?: StringFieldUpdateOperationsInput | string
    features?: PropertyUpdatefeaturesInput | string[]
    landlord?: UserUpdateOneRequiredWithoutPropertyNestedInput
    unit?: UnitUpdateManyWithoutPropertyNestedInput
    recurringBillable?: RecurringBillableUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    propertyStatus?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    amenities?: PropertyUpdateamenitiesInput | string[]
    countryCode?: StringFieldUpdateOperationsInput | string
    features?: PropertyUpdatefeaturesInput | string[]
    landlordId?: StringFieldUpdateOperationsInput | string
    unit?: UnitUncheckedUpdateManyWithoutPropertyNestedInput
    recurringBillable?: RecurringBillableUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type TenantUpsertWithoutFilesInput = {
    update: XOR<TenantUpdateWithoutFilesInput, TenantUncheckedUpdateWithoutFilesInput>
    create: XOR<TenantCreateWithoutFilesInput, TenantUncheckedCreateWithoutFilesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutFilesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutFilesInput, TenantUncheckedUpdateWithoutFilesInput>
  }

  export type TenantUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantEmergencyContact?: NullableJsonNullValueInput | InputJsonValue
    tenantIncome?: NullableJsonNullValueInput | InputJsonValue
    additionalEmails?: TenantUpdateadditionalEmailsInput | string[]
    additionalPhones?: TenantUpdateadditionalPhonesInput | string[]
    emergencyContacts?: NullableJsonNullValueInput | InputJsonValue
    vehicles?: NullableJsonNullValueInput | InputJsonValue
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    paystackCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    Invoice?: InvoiceUpdateManyWithoutTenantNestedInput
    landlord?: UserUpdateOneRequiredWithoutTenantNestedInput
    tenantLease?: TenantLeaseUpdateManyWithoutTenantNestedInput
    recurringBillable?: RecurringBillableUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    landlordId?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantEmergencyContact?: NullableJsonNullValueInput | InputJsonValue
    tenantIncome?: NullableJsonNullValueInput | InputJsonValue
    additionalEmails?: TenantUpdateadditionalEmailsInput | string[]
    additionalPhones?: TenantUpdateadditionalPhonesInput | string[]
    emergencyContacts?: NullableJsonNullValueInput | InputJsonValue
    vehicles?: NullableJsonNullValueInput | InputJsonValue
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    paystackCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    Invoice?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    tenantLease?: TenantLeaseUncheckedUpdateManyWithoutTenantNestedInput
    recurringBillable?: RecurringBillableUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type AccountCreateManyUserInput = {
    id: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type PropertyCreateManyLandlordInput = {
    id?: string
    name: string
    addressLine1: string
    addressLine2?: string | null
    city: string
    state: string
    zip: string
    createdAt?: Date | string
    updatedAt?: Date | string
    imageUrl?: string | null
    propertyStatus?: $Enums.PropertyStatus
    propertyType?: $Enums.PropertyType
    amenities?: PropertyCreateamenitiesInput | string[]
    countryCode?: string
    features?: PropertyCreatefeaturesInput | string[]
  }

  export type SessionCreateManyUserInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type TenantCreateManyLandlordInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    firstName: string
    lastName: string
    phone: string
    dateOfBirth?: Date | string | null
    tenantEmergencyContact?: NullableJsonNullValueInput | InputJsonValue
    tenantIncome?: NullableJsonNullValueInput | InputJsonValue
    additionalEmails?: TenantCreateadditionalEmailsInput | string[]
    additionalPhones?: TenantCreateadditionalPhonesInput | string[]
    emergencyContacts?: NullableJsonNullValueInput | InputJsonValue
    vehicles?: NullableJsonNullValueInput | InputJsonValue
    avatarUrl?: string | null
    fullName?: string | null
    paystackCustomerId?: string | null
  }

  export type InvoiceCreateManyLandlordInput = {
    id?: string
    leaseId?: string | null
    description: string
    dueAmount: number
    category: $Enums.InvoiceCategory
    status: $Enums.InvoiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paystackId: string
    dueDate?: Date | string | null
    lineItems?: NullableJsonNullValueInput | InputJsonValue
    tenantId: string
    recurringBillableId?: string | null
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyUpdateWithoutLandlordInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    propertyStatus?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    amenities?: PropertyUpdateamenitiesInput | string[]
    countryCode?: StringFieldUpdateOperationsInput | string
    features?: PropertyUpdatefeaturesInput | string[]
    files?: FileUpdateManyWithoutPropertyNestedInput
    unit?: UnitUpdateManyWithoutPropertyNestedInput
    recurringBillable?: RecurringBillableUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutLandlordInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    propertyStatus?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    amenities?: PropertyUpdateamenitiesInput | string[]
    countryCode?: StringFieldUpdateOperationsInput | string
    features?: PropertyUpdatefeaturesInput | string[]
    files?: FileUncheckedUpdateManyWithoutPropertyNestedInput
    unit?: UnitUncheckedUpdateManyWithoutPropertyNestedInput
    recurringBillable?: RecurringBillableUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateManyWithoutLandlordInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    propertyStatus?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    amenities?: PropertyUpdateamenitiesInput | string[]
    countryCode?: StringFieldUpdateOperationsInput | string
    features?: PropertyUpdatefeaturesInput | string[]
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TenantUpdateWithoutLandlordInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantEmergencyContact?: NullableJsonNullValueInput | InputJsonValue
    tenantIncome?: NullableJsonNullValueInput | InputJsonValue
    additionalEmails?: TenantUpdateadditionalEmailsInput | string[]
    additionalPhones?: TenantUpdateadditionalPhonesInput | string[]
    emergencyContacts?: NullableJsonNullValueInput | InputJsonValue
    vehicles?: NullableJsonNullValueInput | InputJsonValue
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    paystackCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    files?: FileUpdateManyWithoutTenantNestedInput
    Invoice?: InvoiceUpdateManyWithoutTenantNestedInput
    tenantLease?: TenantLeaseUpdateManyWithoutTenantNestedInput
    recurringBillable?: RecurringBillableUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutLandlordInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantEmergencyContact?: NullableJsonNullValueInput | InputJsonValue
    tenantIncome?: NullableJsonNullValueInput | InputJsonValue
    additionalEmails?: TenantUpdateadditionalEmailsInput | string[]
    additionalPhones?: TenantUpdateadditionalPhonesInput | string[]
    emergencyContacts?: NullableJsonNullValueInput | InputJsonValue
    vehicles?: NullableJsonNullValueInput | InputJsonValue
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    paystackCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    files?: FileUncheckedUpdateManyWithoutTenantNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    tenantLease?: TenantLeaseUncheckedUpdateManyWithoutTenantNestedInput
    recurringBillable?: RecurringBillableUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateManyWithoutLandlordInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantEmergencyContact?: NullableJsonNullValueInput | InputJsonValue
    tenantIncome?: NullableJsonNullValueInput | InputJsonValue
    additionalEmails?: TenantUpdateadditionalEmailsInput | string[]
    additionalPhones?: TenantUpdateadditionalPhonesInput | string[]
    emergencyContacts?: NullableJsonNullValueInput | InputJsonValue
    vehicles?: NullableJsonNullValueInput | InputJsonValue
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    paystackCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceUpdateWithoutLandlordInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dueAmount?: FloatFieldUpdateOperationsInput | number
    category?: EnumInvoiceCategoryFieldUpdateOperationsInput | $Enums.InvoiceCategory
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paystackId?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lineItems?: NullableJsonNullValueInput | InputJsonValue
    File?: FileUpdateManyWithoutInvoiceNestedInput
    lease?: LeaseUpdateOneWithoutInvoiceNestedInput
    tenant?: TenantUpdateOneRequiredWithoutInvoiceNestedInput
    transactions?: TransactionsUpdateManyWithoutInvoiceNestedInput
    recurringBillable?: RecurringBillableUpdateOneWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutLandlordInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaseId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    dueAmount?: FloatFieldUpdateOperationsInput | number
    category?: EnumInvoiceCategoryFieldUpdateOperationsInput | $Enums.InvoiceCategory
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paystackId?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lineItems?: NullableJsonNullValueInput | InputJsonValue
    tenantId?: StringFieldUpdateOperationsInput | string
    recurringBillableId?: NullableStringFieldUpdateOperationsInput | string | null
    File?: FileUncheckedUpdateManyWithoutInvoiceNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutLandlordInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaseId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    dueAmount?: FloatFieldUpdateOperationsInput | number
    category?: EnumInvoiceCategoryFieldUpdateOperationsInput | $Enums.InvoiceCategory
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paystackId?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lineItems?: NullableJsonNullValueInput | InputJsonValue
    tenantId?: StringFieldUpdateOperationsInput | string
    recurringBillableId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FileCreateManyTenantInput = {
    id?: string
    name: string
    url: string
    ownerId: string
    propertyId?: string | null
    leaseId?: string | null
    invoiceId?: string | null
    maintenanceRequestId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    size?: number | null
    type?: string | null
  }

  export type InvoiceCreateManyTenantInput = {
    id?: string
    leaseId?: string | null
    description: string
    dueAmount: number
    category: $Enums.InvoiceCategory
    status: $Enums.InvoiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paystackId: string
    dueDate?: Date | string | null
    lineItems?: NullableJsonNullValueInput | InputJsonValue
    landlordId: string
    recurringBillableId?: string | null
  }

  export type TenantLeaseCreateManyTenantInput = {
    id?: string
    leaseId: string
  }

  export type RecurringBillableCreateManyTenantInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    amount: number
    category: $Enums.InvoiceCategory
    cycle?: $Enums.InvoiceCycle
    nextInvoiceAt: Date | string
    isActive?: boolean
    leaseId?: string | null
    propertyId?: string | null
  }

  export type FileUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: InvoiceUpdateOneWithoutFileNestedInput
    lease?: LeaseUpdateOneWithoutFileNestedInput
    maintenanceRequest?: MaintenanceRequestUpdateOneWithoutFileNestedInput
    property?: PropertyUpdateOneWithoutFilesNestedInput
  }

  export type FileUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    leaseId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FileUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    leaseId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dueAmount?: FloatFieldUpdateOperationsInput | number
    category?: EnumInvoiceCategoryFieldUpdateOperationsInput | $Enums.InvoiceCategory
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paystackId?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lineItems?: NullableJsonNullValueInput | InputJsonValue
    File?: FileUpdateManyWithoutInvoiceNestedInput
    lease?: LeaseUpdateOneWithoutInvoiceNestedInput
    transactions?: TransactionsUpdateManyWithoutInvoiceNestedInput
    recurringBillable?: RecurringBillableUpdateOneWithoutInvoiceNestedInput
    landlord?: UserUpdateOneRequiredWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaseId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    dueAmount?: FloatFieldUpdateOperationsInput | number
    category?: EnumInvoiceCategoryFieldUpdateOperationsInput | $Enums.InvoiceCategory
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paystackId?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lineItems?: NullableJsonNullValueInput | InputJsonValue
    landlordId?: StringFieldUpdateOperationsInput | string
    recurringBillableId?: NullableStringFieldUpdateOperationsInput | string | null
    File?: FileUncheckedUpdateManyWithoutInvoiceNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaseId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    dueAmount?: FloatFieldUpdateOperationsInput | number
    category?: EnumInvoiceCategoryFieldUpdateOperationsInput | $Enums.InvoiceCategory
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paystackId?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lineItems?: NullableJsonNullValueInput | InputJsonValue
    landlordId?: StringFieldUpdateOperationsInput | string
    recurringBillableId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TenantLeaseUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    lease?: LeaseUpdateOneRequiredWithoutTenantLeaseNestedInput
  }

  export type TenantLeaseUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaseId?: StringFieldUpdateOperationsInput | string
  }

  export type TenantLeaseUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaseId?: StringFieldUpdateOperationsInput | string
  }

  export type RecurringBillableUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    category?: EnumInvoiceCategoryFieldUpdateOperationsInput | $Enums.InvoiceCategory
    cycle?: EnumInvoiceCycleFieldUpdateOperationsInput | $Enums.InvoiceCycle
    nextInvoiceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lease?: LeaseUpdateOneWithoutRecurringBillableNestedInput
    invoice?: InvoiceUpdateManyWithoutRecurringBillableNestedInput
    property?: PropertyUpdateOneWithoutRecurringBillableNestedInput
  }

  export type RecurringBillableUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    category?: EnumInvoiceCategoryFieldUpdateOperationsInput | $Enums.InvoiceCategory
    cycle?: EnumInvoiceCycleFieldUpdateOperationsInput | $Enums.InvoiceCycle
    nextInvoiceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    leaseId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: InvoiceUncheckedUpdateManyWithoutRecurringBillableNestedInput
  }

  export type RecurringBillableUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    category?: EnumInvoiceCategoryFieldUpdateOperationsInput | $Enums.InvoiceCategory
    cycle?: EnumInvoiceCycleFieldUpdateOperationsInput | $Enums.InvoiceCycle
    nextInvoiceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    leaseId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FileCreateManyPropertyInput = {
    id?: string
    name: string
    url: string
    ownerId: string
    tenantId?: string | null
    leaseId?: string | null
    invoiceId?: string | null
    maintenanceRequestId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    size?: number | null
    type?: string | null
  }

  export type UnitCreateManyPropertyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bathrooms?: number
    bedrooms?: number
    deposit?: number
    marketRent?: number
    sqmt?: number
  }

  export type RecurringBillableCreateManyPropertyInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    amount: number
    category: $Enums.InvoiceCategory
    cycle?: $Enums.InvoiceCycle
    nextInvoiceAt: Date | string
    isActive?: boolean
    leaseId?: string | null
    tenantId: string
  }

  export type FileUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: InvoiceUpdateOneWithoutFileNestedInput
    lease?: LeaseUpdateOneWithoutFileNestedInput
    maintenanceRequest?: MaintenanceRequestUpdateOneWithoutFileNestedInput
    tenant?: TenantUpdateOneWithoutFilesNestedInput
  }

  export type FileUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    leaseId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FileUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    leaseId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UnitUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bathrooms?: FloatFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    marketRent?: FloatFieldUpdateOperationsInput | number
    sqmt?: FloatFieldUpdateOperationsInput | number
    lease?: LeaseUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bathrooms?: FloatFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    marketRent?: FloatFieldUpdateOperationsInput | number
    sqmt?: FloatFieldUpdateOperationsInput | number
    lease?: LeaseUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bathrooms?: FloatFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    marketRent?: FloatFieldUpdateOperationsInput | number
    sqmt?: FloatFieldUpdateOperationsInput | number
  }

  export type RecurringBillableUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    category?: EnumInvoiceCategoryFieldUpdateOperationsInput | $Enums.InvoiceCategory
    cycle?: EnumInvoiceCycleFieldUpdateOperationsInput | $Enums.InvoiceCycle
    nextInvoiceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lease?: LeaseUpdateOneWithoutRecurringBillableNestedInput
    tenant?: TenantUpdateOneRequiredWithoutRecurringBillableNestedInput
    invoice?: InvoiceUpdateManyWithoutRecurringBillableNestedInput
  }

  export type RecurringBillableUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    category?: EnumInvoiceCategoryFieldUpdateOperationsInput | $Enums.InvoiceCategory
    cycle?: EnumInvoiceCycleFieldUpdateOperationsInput | $Enums.InvoiceCycle
    nextInvoiceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    leaseId?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    invoice?: InvoiceUncheckedUpdateManyWithoutRecurringBillableNestedInput
  }

  export type RecurringBillableUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    category?: EnumInvoiceCategoryFieldUpdateOperationsInput | $Enums.InvoiceCategory
    cycle?: EnumInvoiceCycleFieldUpdateOperationsInput | $Enums.InvoiceCycle
    nextInvoiceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    leaseId?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type LeaseCreateManyUnitInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    rent: number
    deposit: number
    status: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    rentDueCurrency: string
    automaticInvoice?: boolean
    invoiceCycle?: $Enums.InvoiceCycle
    leaseType: $Enums.LeaseTermType
  }

  export type LeaseUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rentDueCurrency?: StringFieldUpdateOperationsInput | string
    automaticInvoice?: BoolFieldUpdateOperationsInput | boolean
    invoiceCycle?: EnumInvoiceCycleFieldUpdateOperationsInput | $Enums.InvoiceCycle
    leaseType?: EnumLeaseTermTypeFieldUpdateOperationsInput | $Enums.LeaseTermType
    File?: FileUpdateManyWithoutLeaseNestedInput
    invoice?: InvoiceUpdateManyWithoutLeaseNestedInput
    maintenanceRequest?: MaintenanceRequestUpdateManyWithoutLeaseNestedInput
    tenantLease?: TenantLeaseUpdateManyWithoutLeaseNestedInput
    transactions?: TransactionsUpdateManyWithoutLeaseNestedInput
    recurringBillable?: RecurringBillableUpdateManyWithoutLeaseNestedInput
  }

  export type LeaseUncheckedUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rentDueCurrency?: StringFieldUpdateOperationsInput | string
    automaticInvoice?: BoolFieldUpdateOperationsInput | boolean
    invoiceCycle?: EnumInvoiceCycleFieldUpdateOperationsInput | $Enums.InvoiceCycle
    leaseType?: EnumLeaseTermTypeFieldUpdateOperationsInput | $Enums.LeaseTermType
    File?: FileUncheckedUpdateManyWithoutLeaseNestedInput
    invoice?: InvoiceUncheckedUpdateManyWithoutLeaseNestedInput
    maintenanceRequest?: MaintenanceRequestUncheckedUpdateManyWithoutLeaseNestedInput
    tenantLease?: TenantLeaseUncheckedUpdateManyWithoutLeaseNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutLeaseNestedInput
    recurringBillable?: RecurringBillableUncheckedUpdateManyWithoutLeaseNestedInput
  }

  export type LeaseUncheckedUpdateManyWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rentDueCurrency?: StringFieldUpdateOperationsInput | string
    automaticInvoice?: BoolFieldUpdateOperationsInput | boolean
    invoiceCycle?: EnumInvoiceCycleFieldUpdateOperationsInput | $Enums.InvoiceCycle
    leaseType?: EnumLeaseTermTypeFieldUpdateOperationsInput | $Enums.LeaseTermType
  }

  export type FileCreateManyLeaseInput = {
    id?: string
    name: string
    url: string
    ownerId: string
    tenantId?: string | null
    propertyId?: string | null
    invoiceId?: string | null
    maintenanceRequestId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    size?: number | null
    type?: string | null
  }

  export type InvoiceCreateManyLeaseInput = {
    id?: string
    description: string
    dueAmount: number
    category: $Enums.InvoiceCategory
    status: $Enums.InvoiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paystackId: string
    dueDate?: Date | string | null
    lineItems?: NullableJsonNullValueInput | InputJsonValue
    landlordId: string
    tenantId: string
    recurringBillableId?: string | null
  }

  export type MaintenanceRequestCreateManyLeaseInput = {
    id?: string
    description?: string | null
    status?: $Enums.MaintenanceRequestStatus | null
    priority: $Enums.MaintenanceRequestPriority
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantLeaseCreateManyLeaseInput = {
    id?: string
    tenantId: string
  }

  export type TransactionsCreateManyLeaseInput = {
    id?: string
    description: string
    amountPaid: number
    referenceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceId?: string | null
  }

  export type RecurringBillableCreateManyLeaseInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    amount: number
    category: $Enums.InvoiceCategory
    cycle?: $Enums.InvoiceCycle
    nextInvoiceAt: Date | string
    isActive?: boolean
    tenantId: string
    propertyId?: string | null
  }

  export type FileUpdateWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: InvoiceUpdateOneWithoutFileNestedInput
    maintenanceRequest?: MaintenanceRequestUpdateOneWithoutFileNestedInput
    property?: PropertyUpdateOneWithoutFilesNestedInput
    tenant?: TenantUpdateOneWithoutFilesNestedInput
  }

  export type FileUncheckedUpdateWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FileUncheckedUpdateManyWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceUpdateWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dueAmount?: FloatFieldUpdateOperationsInput | number
    category?: EnumInvoiceCategoryFieldUpdateOperationsInput | $Enums.InvoiceCategory
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paystackId?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lineItems?: NullableJsonNullValueInput | InputJsonValue
    File?: FileUpdateManyWithoutInvoiceNestedInput
    tenant?: TenantUpdateOneRequiredWithoutInvoiceNestedInput
    transactions?: TransactionsUpdateManyWithoutInvoiceNestedInput
    recurringBillable?: RecurringBillableUpdateOneWithoutInvoiceNestedInput
    landlord?: UserUpdateOneRequiredWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dueAmount?: FloatFieldUpdateOperationsInput | number
    category?: EnumInvoiceCategoryFieldUpdateOperationsInput | $Enums.InvoiceCategory
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paystackId?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lineItems?: NullableJsonNullValueInput | InputJsonValue
    landlordId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    recurringBillableId?: NullableStringFieldUpdateOperationsInput | string | null
    File?: FileUncheckedUpdateManyWithoutInvoiceNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dueAmount?: FloatFieldUpdateOperationsInput | number
    category?: EnumInvoiceCategoryFieldUpdateOperationsInput | $Enums.InvoiceCategory
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paystackId?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lineItems?: NullableJsonNullValueInput | InputJsonValue
    landlordId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    recurringBillableId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MaintenanceRequestUpdateWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumMaintenanceRequestStatusFieldUpdateOperationsInput | $Enums.MaintenanceRequestStatus | null
    priority?: EnumMaintenanceRequestPriorityFieldUpdateOperationsInput | $Enums.MaintenanceRequestPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    File?: FileUpdateManyWithoutMaintenanceRequestNestedInput
  }

  export type MaintenanceRequestUncheckedUpdateWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumMaintenanceRequestStatusFieldUpdateOperationsInput | $Enums.MaintenanceRequestStatus | null
    priority?: EnumMaintenanceRequestPriorityFieldUpdateOperationsInput | $Enums.MaintenanceRequestPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    File?: FileUncheckedUpdateManyWithoutMaintenanceRequestNestedInput
  }

  export type MaintenanceRequestUncheckedUpdateManyWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumMaintenanceRequestStatusFieldUpdateOperationsInput | $Enums.MaintenanceRequestStatus | null
    priority?: EnumMaintenanceRequestPriorityFieldUpdateOperationsInput | $Enums.MaintenanceRequestPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantLeaseUpdateWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant?: TenantUpdateOneRequiredWithoutTenantLeaseNestedInput
  }

  export type TenantLeaseUncheckedUpdateWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type TenantLeaseUncheckedUpdateManyWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type TransactionsUpdateWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionsUncheckedUpdateWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionsUncheckedUpdateManyWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecurringBillableUpdateWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    category?: EnumInvoiceCategoryFieldUpdateOperationsInput | $Enums.InvoiceCategory
    cycle?: EnumInvoiceCycleFieldUpdateOperationsInput | $Enums.InvoiceCycle
    nextInvoiceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenant?: TenantUpdateOneRequiredWithoutRecurringBillableNestedInput
    invoice?: InvoiceUpdateManyWithoutRecurringBillableNestedInput
    property?: PropertyUpdateOneWithoutRecurringBillableNestedInput
  }

  export type RecurringBillableUncheckedUpdateWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    category?: EnumInvoiceCategoryFieldUpdateOperationsInput | $Enums.InvoiceCategory
    cycle?: EnumInvoiceCycleFieldUpdateOperationsInput | $Enums.InvoiceCycle
    nextInvoiceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: InvoiceUncheckedUpdateManyWithoutRecurringBillableNestedInput
  }

  export type RecurringBillableUncheckedUpdateManyWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    category?: EnumInvoiceCategoryFieldUpdateOperationsInput | $Enums.InvoiceCategory
    cycle?: EnumInvoiceCycleFieldUpdateOperationsInput | $Enums.InvoiceCycle
    nextInvoiceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FileCreateManyInvoiceInput = {
    id?: string
    name: string
    url: string
    ownerId: string
    tenantId?: string | null
    propertyId?: string | null
    leaseId?: string | null
    maintenanceRequestId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    size?: number | null
    type?: string | null
  }

  export type TransactionsCreateManyInvoiceInput = {
    id?: string
    leaseId?: string | null
    description: string
    amountPaid: number
    referenceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FileUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    lease?: LeaseUpdateOneWithoutFileNestedInput
    maintenanceRequest?: MaintenanceRequestUpdateOneWithoutFileNestedInput
    property?: PropertyUpdateOneWithoutFilesNestedInput
    tenant?: TenantUpdateOneWithoutFilesNestedInput
  }

  export type FileUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    leaseId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FileUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    leaseId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionsUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lease?: LeaseUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionsUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaseId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionsUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaseId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateManyRecurringBillableInput = {
    id?: string
    leaseId?: string | null
    description: string
    dueAmount: number
    category: $Enums.InvoiceCategory
    status: $Enums.InvoiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paystackId: string
    dueDate?: Date | string | null
    lineItems?: NullableJsonNullValueInput | InputJsonValue
    landlordId: string
    tenantId: string
  }

  export type InvoiceUpdateWithoutRecurringBillableInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dueAmount?: FloatFieldUpdateOperationsInput | number
    category?: EnumInvoiceCategoryFieldUpdateOperationsInput | $Enums.InvoiceCategory
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paystackId?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lineItems?: NullableJsonNullValueInput | InputJsonValue
    File?: FileUpdateManyWithoutInvoiceNestedInput
    lease?: LeaseUpdateOneWithoutInvoiceNestedInput
    tenant?: TenantUpdateOneRequiredWithoutInvoiceNestedInput
    transactions?: TransactionsUpdateManyWithoutInvoiceNestedInput
    landlord?: UserUpdateOneRequiredWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutRecurringBillableInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaseId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    dueAmount?: FloatFieldUpdateOperationsInput | number
    category?: EnumInvoiceCategoryFieldUpdateOperationsInput | $Enums.InvoiceCategory
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paystackId?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lineItems?: NullableJsonNullValueInput | InputJsonValue
    landlordId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    File?: FileUncheckedUpdateManyWithoutInvoiceNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutRecurringBillableInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaseId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    dueAmount?: FloatFieldUpdateOperationsInput | number
    category?: EnumInvoiceCategoryFieldUpdateOperationsInput | $Enums.InvoiceCategory
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paystackId?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lineItems?: NullableJsonNullValueInput | InputJsonValue
    landlordId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type FileCreateManyMaintenanceRequestInput = {
    id?: string
    name: string
    url: string
    ownerId: string
    tenantId?: string | null
    propertyId?: string | null
    leaseId?: string | null
    invoiceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    size?: number | null
    type?: string | null
  }

  export type FileUpdateWithoutMaintenanceRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: InvoiceUpdateOneWithoutFileNestedInput
    lease?: LeaseUpdateOneWithoutFileNestedInput
    property?: PropertyUpdateOneWithoutFilesNestedInput
    tenant?: TenantUpdateOneWithoutFilesNestedInput
  }

  export type FileUncheckedUpdateWithoutMaintenanceRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    leaseId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FileUncheckedUpdateManyWithoutMaintenanceRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    leaseId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}