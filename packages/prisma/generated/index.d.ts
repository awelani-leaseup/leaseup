
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Tenant
 * 
 */
export type Tenant = $Result.DefaultSelection<Prisma.$TenantPayload>
/**
 * Model TenantEmergencyContact
 * 
 */
export type TenantEmergencyContact = $Result.DefaultSelection<Prisma.$TenantEmergencyContactPayload>
/**
 * Model TenantIncome
 * 
 */
export type TenantIncome = $Result.DefaultSelection<Prisma.$TenantIncomePayload>
/**
 * Model Landlord
 * 
 */
export type Landlord = $Result.DefaultSelection<Prisma.$LandlordPayload>
/**
 * Model Property
 * 
 */
export type Property = $Result.DefaultSelection<Prisma.$PropertyPayload>
/**
 * Model Unit
 * 
 */
export type Unit = $Result.DefaultSelection<Prisma.$UnitPayload>
/**
 * Model Lease
 * 
 */
export type Lease = $Result.DefaultSelection<Prisma.$LeasePayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model Transactions
 * 
 */
export type Transactions = $Result.DefaultSelection<Prisma.$TransactionsPayload>
/**
 * Model TenantLease
 * 
 */
export type TenantLease = $Result.DefaultSelection<Prisma.$TenantLeasePayload>
/**
 * Model MaintenanceRequest
 * 
 */
export type MaintenanceRequest = $Result.DefaultSelection<Prisma.$MaintenanceRequestPayload>
/**
 * Model TenantDocument
 * 
 */
export type TenantDocument = $Result.DefaultSelection<Prisma.$TenantDocumentPayload>
/**
 * Model LeaseDocument
 * 
 */
export type LeaseDocument = $Result.DefaultSelection<Prisma.$LeaseDocumentPayload>
/**
 * Model PropertyDocument
 * 
 */
export type PropertyDocument = $Result.DefaultSelection<Prisma.$PropertyDocumentPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const LeaseTermType: {
  MONTHLY: 'MONTHLY',
  FIXED_TERM: 'FIXED_TERM'
};

export type LeaseTermType = (typeof LeaseTermType)[keyof typeof LeaseTermType]


export const PropertyType: {
  SINGLE_UNIT: 'SINGLE_UNIT',
  MULTI_UNIT: 'MULTI_UNIT'
};

export type PropertyType = (typeof PropertyType)[keyof typeof PropertyType]


export const PropertyStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE'
};

export type PropertyStatus = (typeof PropertyStatus)[keyof typeof PropertyStatus]


export const InvoiceStatus: {
  PENDING: 'PENDING',
  PAID: 'PAID',
  CANCELLED: 'CANCELLED',
  OVERDUE: 'OVERDUE'
};

export type InvoiceStatus = (typeof InvoiceStatus)[keyof typeof InvoiceStatus]


export const LeaseStatus: {
  PENDING: 'PENDING',
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  EXPIRED: 'EXPIRED'
};

export type LeaseStatus = (typeof LeaseStatus)[keyof typeof LeaseStatus]


export const DocumentType: {
  LEASE_AGREEMENT: 'LEASE_AGREEMENT',
  RECEIPT: 'RECEIPT',
  OTHER: 'OTHER'
};

export type DocumentType = (typeof DocumentType)[keyof typeof DocumentType]


export const TenantDocumentType: {
  ID: 'ID',
  DRIVING_LICENSE: 'DRIVING_LICENSE',
  PROOF_OF_BANK_ACCOUNT: 'PROOF_OF_BANK_ACCOUNT',
  PROOF_OF_INCOME: 'PROOF_OF_INCOME',
  PROOF_OF_VEHICLE_REGISTRATION: 'PROOF_OF_VEHICLE_REGISTRATION',
  LEASE_AGREEMENT: 'LEASE_AGREEMENT',
  OTHER: 'OTHER'
};

export type TenantDocumentType = (typeof TenantDocumentType)[keyof typeof TenantDocumentType]


export const TenantIncomeType: {
  SALARY: 'SALARY',
  SELF_EMPLOYED: 'SELF_EMPLOYED',
  UNEMPLOYED: 'UNEMPLOYED',
  RETIRED: 'RETIRED',
  DISABILITY: 'DISABILITY',
  OTHER: 'OTHER'
};

export type TenantIncomeType = (typeof TenantIncomeType)[keyof typeof TenantIncomeType]


export const TenantRelationship: {
  SPOUSE: 'SPOUSE',
  PARENT: 'PARENT',
  GRANDPARENT: 'GRANDPARENT',
  GRANDCHILD: 'GRANDCHILD',
  SIBLING: 'SIBLING',
  CHILD: 'CHILD',
  AUNT_UNCLE: 'AUNT_UNCLE',
  COUSIN: 'COUSIN',
  NEPHEW_NIECE: 'NEPHEW_NIECE',
  OTHER: 'OTHER'
};

export type TenantRelationship = (typeof TenantRelationship)[keyof typeof TenantRelationship]


export const MaintenanceRequestStatus: {
  PENDING: 'PENDING',
  ASSIGNED: 'ASSIGNED',
  IN_PROGRESS: 'IN_PROGRESS',
  CANCELLED: 'CANCELLED',
  COMPLETE: 'COMPLETE'
};

export type MaintenanceRequestStatus = (typeof MaintenanceRequestStatus)[keyof typeof MaintenanceRequestStatus]


export const MaintenanceRequestPriority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH'
};

export type MaintenanceRequestPriority = (typeof MaintenanceRequestPriority)[keyof typeof MaintenanceRequestPriority]


export const InvoiceCategory: {
  DEPOSIT: 'DEPOSIT',
  RENT: 'RENT',
  MAINTENANCE: 'MAINTENANCE',
  UTILITY_BILL: 'UTILITY_BILL',
  LEVY: 'LEVY',
  RATES_AND_TAXES: 'RATES_AND_TAXES',
  SERVICE_CHARGE: 'SERVICE_CHARGE',
  WATER_ELECTRICITY: 'WATER_ELECTRICITY',
  OTHER: 'OTHER'
};

export type InvoiceCategory = (typeof InvoiceCategory)[keyof typeof InvoiceCategory]


export const AmenityParking: {
  COVERED: 'COVERED',
  DEDICATED_SPACE: 'DEDICATED_SPACE',
  GARAGE: 'GARAGE',
  DRIVEWAY: 'DRIVEWAY',
  STREET: 'STREET',
  PRIVATE_LOT: 'PRIVATE_LOT',
  OTHER: 'OTHER',
  NONE: 'NONE'
};

export type AmenityParking = (typeof AmenityParking)[keyof typeof AmenityParking]


export const AmenityLaundry: {
  IN_UNIT: 'IN_UNIT',
  IN_BUILDING: 'IN_BUILDING',
  IN_COMMON_AREA: 'IN_COMMON_AREA',
  OTHER: 'OTHER',
  NONE: 'NONE'
};

export type AmenityLaundry = (typeof AmenityLaundry)[keyof typeof AmenityLaundry]

}

export type LeaseTermType = $Enums.LeaseTermType

export const LeaseTermType: typeof $Enums.LeaseTermType

export type PropertyType = $Enums.PropertyType

export const PropertyType: typeof $Enums.PropertyType

export type PropertyStatus = $Enums.PropertyStatus

export const PropertyStatus: typeof $Enums.PropertyStatus

export type InvoiceStatus = $Enums.InvoiceStatus

export const InvoiceStatus: typeof $Enums.InvoiceStatus

export type LeaseStatus = $Enums.LeaseStatus

export const LeaseStatus: typeof $Enums.LeaseStatus

export type DocumentType = $Enums.DocumentType

export const DocumentType: typeof $Enums.DocumentType

export type TenantDocumentType = $Enums.TenantDocumentType

export const TenantDocumentType: typeof $Enums.TenantDocumentType

export type TenantIncomeType = $Enums.TenantIncomeType

export const TenantIncomeType: typeof $Enums.TenantIncomeType

export type TenantRelationship = $Enums.TenantRelationship

export const TenantRelationship: typeof $Enums.TenantRelationship

export type MaintenanceRequestStatus = $Enums.MaintenanceRequestStatus

export const MaintenanceRequestStatus: typeof $Enums.MaintenanceRequestStatus

export type MaintenanceRequestPriority = $Enums.MaintenanceRequestPriority

export const MaintenanceRequestPriority: typeof $Enums.MaintenanceRequestPriority

export type InvoiceCategory = $Enums.InvoiceCategory

export const InvoiceCategory: typeof $Enums.InvoiceCategory

export type AmenityParking = $Enums.AmenityParking

export const AmenityParking: typeof $Enums.AmenityParking

export type AmenityLaundry = $Enums.AmenityLaundry

export const AmenityLaundry: typeof $Enums.AmenityLaundry

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Tenants
 * const tenants = await prisma.tenant.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Tenants
   * const tenants = await prisma.tenant.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.tenant`: Exposes CRUD operations for the **Tenant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tenants
    * const tenants = await prisma.tenant.findMany()
    * ```
    */
  get tenant(): Prisma.TenantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tenantEmergencyContact`: Exposes CRUD operations for the **TenantEmergencyContact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TenantEmergencyContacts
    * const tenantEmergencyContacts = await prisma.tenantEmergencyContact.findMany()
    * ```
    */
  get tenantEmergencyContact(): Prisma.TenantEmergencyContactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tenantIncome`: Exposes CRUD operations for the **TenantIncome** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TenantIncomes
    * const tenantIncomes = await prisma.tenantIncome.findMany()
    * ```
    */
  get tenantIncome(): Prisma.TenantIncomeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.landlord`: Exposes CRUD operations for the **Landlord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Landlords
    * const landlords = await prisma.landlord.findMany()
    * ```
    */
  get landlord(): Prisma.LandlordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.property`: Exposes CRUD operations for the **Property** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Properties
    * const properties = await prisma.property.findMany()
    * ```
    */
  get property(): Prisma.PropertyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unit`: Exposes CRUD operations for the **Unit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Units
    * const units = await prisma.unit.findMany()
    * ```
    */
  get unit(): Prisma.UnitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lease`: Exposes CRUD operations for the **Lease** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leases
    * const leases = await prisma.lease.findMany()
    * ```
    */
  get lease(): Prisma.LeaseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transactions`: Exposes CRUD operations for the **Transactions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transactions.findMany()
    * ```
    */
  get transactions(): Prisma.TransactionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tenantLease`: Exposes CRUD operations for the **TenantLease** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TenantLeases
    * const tenantLeases = await prisma.tenantLease.findMany()
    * ```
    */
  get tenantLease(): Prisma.TenantLeaseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.maintenanceRequest`: Exposes CRUD operations for the **MaintenanceRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MaintenanceRequests
    * const maintenanceRequests = await prisma.maintenanceRequest.findMany()
    * ```
    */
  get maintenanceRequest(): Prisma.MaintenanceRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tenantDocument`: Exposes CRUD operations for the **TenantDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TenantDocuments
    * const tenantDocuments = await prisma.tenantDocument.findMany()
    * ```
    */
  get tenantDocument(): Prisma.TenantDocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leaseDocument`: Exposes CRUD operations for the **LeaseDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeaseDocuments
    * const leaseDocuments = await prisma.leaseDocument.findMany()
    * ```
    */
  get leaseDocument(): Prisma.LeaseDocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.propertyDocument`: Exposes CRUD operations for the **PropertyDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyDocuments
    * const propertyDocuments = await prisma.propertyDocument.findMany()
    * ```
    */
  get propertyDocument(): Prisma.PropertyDocumentDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.10.1
   * Query Engine version: 9b628578b3b7cae625e8c927178f15a170e74a9c
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Tenant: 'Tenant',
    TenantEmergencyContact: 'TenantEmergencyContact',
    TenantIncome: 'TenantIncome',
    Landlord: 'Landlord',
    Property: 'Property',
    Unit: 'Unit',
    Lease: 'Lease',
    Invoice: 'Invoice',
    Transactions: 'Transactions',
    TenantLease: 'TenantLease',
    MaintenanceRequest: 'MaintenanceRequest',
    TenantDocument: 'TenantDocument',
    LeaseDocument: 'LeaseDocument',
    PropertyDocument: 'PropertyDocument'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "tenant" | "tenantEmergencyContact" | "tenantIncome" | "landlord" | "property" | "unit" | "lease" | "invoice" | "transactions" | "tenantLease" | "maintenanceRequest" | "tenantDocument" | "leaseDocument" | "propertyDocument"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Tenant: {
        payload: Prisma.$TenantPayload<ExtArgs>
        fields: Prisma.TenantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findFirst: {
            args: Prisma.TenantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findMany: {
            args: Prisma.TenantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          create: {
            args: Prisma.TenantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          createMany: {
            args: Prisma.TenantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          delete: {
            args: Prisma.TenantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          update: {
            args: Prisma.TenantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          deleteMany: {
            args: Prisma.TenantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TenantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          upsert: {
            args: Prisma.TenantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          aggregate: {
            args: Prisma.TenantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenant>
          }
          groupBy: {
            args: Prisma.TenantGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantCountArgs<ExtArgs>
            result: $Utils.Optional<TenantCountAggregateOutputType> | number
          }
        }
      }
      TenantEmergencyContact: {
        payload: Prisma.$TenantEmergencyContactPayload<ExtArgs>
        fields: Prisma.TenantEmergencyContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantEmergencyContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantEmergencyContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantEmergencyContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantEmergencyContactPayload>
          }
          findFirst: {
            args: Prisma.TenantEmergencyContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantEmergencyContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantEmergencyContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantEmergencyContactPayload>
          }
          findMany: {
            args: Prisma.TenantEmergencyContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantEmergencyContactPayload>[]
          }
          create: {
            args: Prisma.TenantEmergencyContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantEmergencyContactPayload>
          }
          createMany: {
            args: Prisma.TenantEmergencyContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantEmergencyContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantEmergencyContactPayload>[]
          }
          delete: {
            args: Prisma.TenantEmergencyContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantEmergencyContactPayload>
          }
          update: {
            args: Prisma.TenantEmergencyContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantEmergencyContactPayload>
          }
          deleteMany: {
            args: Prisma.TenantEmergencyContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantEmergencyContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TenantEmergencyContactUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantEmergencyContactPayload>[]
          }
          upsert: {
            args: Prisma.TenantEmergencyContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantEmergencyContactPayload>
          }
          aggregate: {
            args: Prisma.TenantEmergencyContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenantEmergencyContact>
          }
          groupBy: {
            args: Prisma.TenantEmergencyContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantEmergencyContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantEmergencyContactCountArgs<ExtArgs>
            result: $Utils.Optional<TenantEmergencyContactCountAggregateOutputType> | number
          }
        }
      }
      TenantIncome: {
        payload: Prisma.$TenantIncomePayload<ExtArgs>
        fields: Prisma.TenantIncomeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantIncomeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantIncomePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantIncomeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantIncomePayload>
          }
          findFirst: {
            args: Prisma.TenantIncomeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantIncomePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantIncomeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantIncomePayload>
          }
          findMany: {
            args: Prisma.TenantIncomeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantIncomePayload>[]
          }
          create: {
            args: Prisma.TenantIncomeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantIncomePayload>
          }
          createMany: {
            args: Prisma.TenantIncomeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantIncomeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantIncomePayload>[]
          }
          delete: {
            args: Prisma.TenantIncomeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantIncomePayload>
          }
          update: {
            args: Prisma.TenantIncomeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantIncomePayload>
          }
          deleteMany: {
            args: Prisma.TenantIncomeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantIncomeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TenantIncomeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantIncomePayload>[]
          }
          upsert: {
            args: Prisma.TenantIncomeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantIncomePayload>
          }
          aggregate: {
            args: Prisma.TenantIncomeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenantIncome>
          }
          groupBy: {
            args: Prisma.TenantIncomeGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantIncomeGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantIncomeCountArgs<ExtArgs>
            result: $Utils.Optional<TenantIncomeCountAggregateOutputType> | number
          }
        }
      }
      Landlord: {
        payload: Prisma.$LandlordPayload<ExtArgs>
        fields: Prisma.LandlordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LandlordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandlordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LandlordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandlordPayload>
          }
          findFirst: {
            args: Prisma.LandlordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandlordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LandlordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandlordPayload>
          }
          findMany: {
            args: Prisma.LandlordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandlordPayload>[]
          }
          create: {
            args: Prisma.LandlordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandlordPayload>
          }
          createMany: {
            args: Prisma.LandlordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LandlordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandlordPayload>[]
          }
          delete: {
            args: Prisma.LandlordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandlordPayload>
          }
          update: {
            args: Prisma.LandlordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandlordPayload>
          }
          deleteMany: {
            args: Prisma.LandlordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LandlordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LandlordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandlordPayload>[]
          }
          upsert: {
            args: Prisma.LandlordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandlordPayload>
          }
          aggregate: {
            args: Prisma.LandlordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLandlord>
          }
          groupBy: {
            args: Prisma.LandlordGroupByArgs<ExtArgs>
            result: $Utils.Optional<LandlordGroupByOutputType>[]
          }
          count: {
            args: Prisma.LandlordCountArgs<ExtArgs>
            result: $Utils.Optional<LandlordCountAggregateOutputType> | number
          }
        }
      }
      Property: {
        payload: Prisma.$PropertyPayload<ExtArgs>
        fields: Prisma.PropertyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          findFirst: {
            args: Prisma.PropertyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          findMany: {
            args: Prisma.PropertyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>[]
          }
          create: {
            args: Prisma.PropertyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          createMany: {
            args: Prisma.PropertyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>[]
          }
          delete: {
            args: Prisma.PropertyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          update: {
            args: Prisma.PropertyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          deleteMany: {
            args: Prisma.PropertyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>[]
          }
          upsert: {
            args: Prisma.PropertyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          aggregate: {
            args: Prisma.PropertyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProperty>
          }
          groupBy: {
            args: Prisma.PropertyGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyCountAggregateOutputType> | number
          }
        }
      }
      Unit: {
        payload: Prisma.$UnitPayload<ExtArgs>
        fields: Prisma.UnitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          findFirst: {
            args: Prisma.UnitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          findMany: {
            args: Prisma.UnitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          create: {
            args: Prisma.UnitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          createMany: {
            args: Prisma.UnitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UnitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          delete: {
            args: Prisma.UnitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          update: {
            args: Prisma.UnitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          deleteMany: {
            args: Prisma.UnitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UnitUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          upsert: {
            args: Prisma.UnitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          aggregate: {
            args: Prisma.UnitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnit>
          }
          groupBy: {
            args: Prisma.UnitGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitCountArgs<ExtArgs>
            result: $Utils.Optional<UnitCountAggregateOutputType> | number
          }
        }
      }
      Lease: {
        payload: Prisma.$LeasePayload<ExtArgs>
        fields: Prisma.LeaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeasePayload>
          }
          findFirst: {
            args: Prisma.LeaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeasePayload>
          }
          findMany: {
            args: Prisma.LeaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeasePayload>[]
          }
          create: {
            args: Prisma.LeaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeasePayload>
          }
          createMany: {
            args: Prisma.LeaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeasePayload>[]
          }
          delete: {
            args: Prisma.LeaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeasePayload>
          }
          update: {
            args: Prisma.LeaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeasePayload>
          }
          deleteMany: {
            args: Prisma.LeaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeaseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeasePayload>[]
          }
          upsert: {
            args: Prisma.LeaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeasePayload>
          }
          aggregate: {
            args: Prisma.LeaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLease>
          }
          groupBy: {
            args: Prisma.LeaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaseCountArgs<ExtArgs>
            result: $Utils.Optional<LeaseCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      Transactions: {
        payload: Prisma.$TransactionsPayload<ExtArgs>
        fields: Prisma.TransactionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload>
          }
          findFirst: {
            args: Prisma.TransactionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload>
          }
          findMany: {
            args: Prisma.TransactionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload>[]
          }
          create: {
            args: Prisma.TransactionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload>
          }
          createMany: {
            args: Prisma.TransactionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload>[]
          }
          delete: {
            args: Prisma.TransactionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload>
          }
          update: {
            args: Prisma.TransactionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload>
          }
          deleteMany: {
            args: Prisma.TransactionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload>[]
          }
          upsert: {
            args: Prisma.TransactionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload>
          }
          aggregate: {
            args: Prisma.TransactionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransactions>
          }
          groupBy: {
            args: Prisma.TransactionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionsCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionsCountAggregateOutputType> | number
          }
        }
      }
      TenantLease: {
        payload: Prisma.$TenantLeasePayload<ExtArgs>
        fields: Prisma.TenantLeaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantLeaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantLeasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantLeaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantLeasePayload>
          }
          findFirst: {
            args: Prisma.TenantLeaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantLeasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantLeaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantLeasePayload>
          }
          findMany: {
            args: Prisma.TenantLeaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantLeasePayload>[]
          }
          create: {
            args: Prisma.TenantLeaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantLeasePayload>
          }
          createMany: {
            args: Prisma.TenantLeaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantLeaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantLeasePayload>[]
          }
          delete: {
            args: Prisma.TenantLeaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantLeasePayload>
          }
          update: {
            args: Prisma.TenantLeaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantLeasePayload>
          }
          deleteMany: {
            args: Prisma.TenantLeaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantLeaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TenantLeaseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantLeasePayload>[]
          }
          upsert: {
            args: Prisma.TenantLeaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantLeasePayload>
          }
          aggregate: {
            args: Prisma.TenantLeaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenantLease>
          }
          groupBy: {
            args: Prisma.TenantLeaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantLeaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantLeaseCountArgs<ExtArgs>
            result: $Utils.Optional<TenantLeaseCountAggregateOutputType> | number
          }
        }
      }
      MaintenanceRequest: {
        payload: Prisma.$MaintenanceRequestPayload<ExtArgs>
        fields: Prisma.MaintenanceRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaintenanceRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaintenanceRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload>
          }
          findFirst: {
            args: Prisma.MaintenanceRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaintenanceRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload>
          }
          findMany: {
            args: Prisma.MaintenanceRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload>[]
          }
          create: {
            args: Prisma.MaintenanceRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload>
          }
          createMany: {
            args: Prisma.MaintenanceRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaintenanceRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload>[]
          }
          delete: {
            args: Prisma.MaintenanceRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload>
          }
          update: {
            args: Prisma.MaintenanceRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload>
          }
          deleteMany: {
            args: Prisma.MaintenanceRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaintenanceRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MaintenanceRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload>[]
          }
          upsert: {
            args: Prisma.MaintenanceRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload>
          }
          aggregate: {
            args: Prisma.MaintenanceRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaintenanceRequest>
          }
          groupBy: {
            args: Prisma.MaintenanceRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaintenanceRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaintenanceRequestCountArgs<ExtArgs>
            result: $Utils.Optional<MaintenanceRequestCountAggregateOutputType> | number
          }
        }
      }
      TenantDocument: {
        payload: Prisma.$TenantDocumentPayload<ExtArgs>
        fields: Prisma.TenantDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantDocumentPayload>
          }
          findFirst: {
            args: Prisma.TenantDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantDocumentPayload>
          }
          findMany: {
            args: Prisma.TenantDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantDocumentPayload>[]
          }
          create: {
            args: Prisma.TenantDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantDocumentPayload>
          }
          createMany: {
            args: Prisma.TenantDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantDocumentPayload>[]
          }
          delete: {
            args: Prisma.TenantDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantDocumentPayload>
          }
          update: {
            args: Prisma.TenantDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantDocumentPayload>
          }
          deleteMany: {
            args: Prisma.TenantDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TenantDocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantDocumentPayload>[]
          }
          upsert: {
            args: Prisma.TenantDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantDocumentPayload>
          }
          aggregate: {
            args: Prisma.TenantDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenantDocument>
          }
          groupBy: {
            args: Prisma.TenantDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<TenantDocumentCountAggregateOutputType> | number
          }
        }
      }
      LeaseDocument: {
        payload: Prisma.$LeaseDocumentPayload<ExtArgs>
        fields: Prisma.LeaseDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaseDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaseDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaseDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaseDocumentPayload>
          }
          findFirst: {
            args: Prisma.LeaseDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaseDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaseDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaseDocumentPayload>
          }
          findMany: {
            args: Prisma.LeaseDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaseDocumentPayload>[]
          }
          create: {
            args: Prisma.LeaseDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaseDocumentPayload>
          }
          createMany: {
            args: Prisma.LeaseDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeaseDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaseDocumentPayload>[]
          }
          delete: {
            args: Prisma.LeaseDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaseDocumentPayload>
          }
          update: {
            args: Prisma.LeaseDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaseDocumentPayload>
          }
          deleteMany: {
            args: Prisma.LeaseDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeaseDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeaseDocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaseDocumentPayload>[]
          }
          upsert: {
            args: Prisma.LeaseDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaseDocumentPayload>
          }
          aggregate: {
            args: Prisma.LeaseDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeaseDocument>
          }
          groupBy: {
            args: Prisma.LeaseDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeaseDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaseDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<LeaseDocumentCountAggregateOutputType> | number
          }
        }
      }
      PropertyDocument: {
        payload: Prisma.$PropertyDocumentPayload<ExtArgs>
        fields: Prisma.PropertyDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyDocumentPayload>
          }
          findFirst: {
            args: Prisma.PropertyDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyDocumentPayload>
          }
          findMany: {
            args: Prisma.PropertyDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyDocumentPayload>[]
          }
          create: {
            args: Prisma.PropertyDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyDocumentPayload>
          }
          createMany: {
            args: Prisma.PropertyDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyDocumentPayload>[]
          }
          delete: {
            args: Prisma.PropertyDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyDocumentPayload>
          }
          update: {
            args: Prisma.PropertyDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyDocumentPayload>
          }
          deleteMany: {
            args: Prisma.PropertyDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertyDocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyDocumentPayload>[]
          }
          upsert: {
            args: Prisma.PropertyDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyDocumentPayload>
          }
          aggregate: {
            args: Prisma.PropertyDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertyDocument>
          }
          groupBy: {
            args: Prisma.PropertyDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyDocumentCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    tenant?: TenantOmit
    tenantEmergencyContact?: TenantEmergencyContactOmit
    tenantIncome?: TenantIncomeOmit
    landlord?: LandlordOmit
    property?: PropertyOmit
    unit?: UnitOmit
    lease?: LeaseOmit
    invoice?: InvoiceOmit
    transactions?: TransactionsOmit
    tenantLease?: TenantLeaseOmit
    maintenanceRequest?: MaintenanceRequestOmit
    tenantDocument?: TenantDocumentOmit
    leaseDocument?: LeaseDocumentOmit
    propertyDocument?: PropertyDocumentOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type TenantCountOutputType
   */

  export type TenantCountOutputType = {
    Lease: number
    tenantLease: number
    tenantDocument: number
    tenantEmergencyContact: number
    tenantIncome: number
  }

  export type TenantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Lease?: boolean | TenantCountOutputTypeCountLeaseArgs
    tenantLease?: boolean | TenantCountOutputTypeCountTenantLeaseArgs
    tenantDocument?: boolean | TenantCountOutputTypeCountTenantDocumentArgs
    tenantEmergencyContact?: boolean | TenantCountOutputTypeCountTenantEmergencyContactArgs
    tenantIncome?: boolean | TenantCountOutputTypeCountTenantIncomeArgs
  }

  // Custom InputTypes
  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantCountOutputType
     */
    select?: TenantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountLeaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaseWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountTenantLeaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantLeaseWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountTenantDocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantDocumentWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountTenantEmergencyContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantEmergencyContactWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountTenantIncomeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantIncomeWhereInput
  }


  /**
   * Count Type LandlordCountOutputType
   */

  export type LandlordCountOutputType = {
    property: number
  }

  export type LandlordCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | LandlordCountOutputTypeCountPropertyArgs
  }

  // Custom InputTypes
  /**
   * LandlordCountOutputType without action
   */
  export type LandlordCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandlordCountOutputType
     */
    select?: LandlordCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LandlordCountOutputType without action
   */
  export type LandlordCountOutputTypeCountPropertyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyWhereInput
  }


  /**
   * Count Type PropertyCountOutputType
   */

  export type PropertyCountOutputType = {
    unit: number
    propertyDocument: number
    Lease: number
  }

  export type PropertyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | PropertyCountOutputTypeCountUnitArgs
    propertyDocument?: boolean | PropertyCountOutputTypeCountPropertyDocumentArgs
    Lease?: boolean | PropertyCountOutputTypeCountLeaseArgs
  }

  // Custom InputTypes
  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCountOutputType
     */
    select?: PropertyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountUnitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountPropertyDocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyDocumentWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountLeaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaseWhereInput
  }


  /**
   * Count Type UnitCountOutputType
   */

  export type UnitCountOutputType = {
    lease: number
  }

  export type UnitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lease?: boolean | UnitCountOutputTypeCountLeaseArgs
  }

  // Custom InputTypes
  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitCountOutputType
     */
    select?: UnitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountLeaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaseWhereInput
  }


  /**
   * Count Type LeaseCountOutputType
   */

  export type LeaseCountOutputType = {
    tenantLease: number
    invoice: number
    transactions: number
    maintenanceRequest: number
    leaseDocument: number
  }

  export type LeaseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenantLease?: boolean | LeaseCountOutputTypeCountTenantLeaseArgs
    invoice?: boolean | LeaseCountOutputTypeCountInvoiceArgs
    transactions?: boolean | LeaseCountOutputTypeCountTransactionsArgs
    maintenanceRequest?: boolean | LeaseCountOutputTypeCountMaintenanceRequestArgs
    leaseDocument?: boolean | LeaseCountOutputTypeCountLeaseDocumentArgs
  }

  // Custom InputTypes
  /**
   * LeaseCountOutputType without action
   */
  export type LeaseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaseCountOutputType
     */
    select?: LeaseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LeaseCountOutputType without action
   */
  export type LeaseCountOutputTypeCountTenantLeaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantLeaseWhereInput
  }

  /**
   * LeaseCountOutputType without action
   */
  export type LeaseCountOutputTypeCountInvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * LeaseCountOutputType without action
   */
  export type LeaseCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionsWhereInput
  }

  /**
   * LeaseCountOutputType without action
   */
  export type LeaseCountOutputTypeCountMaintenanceRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceRequestWhereInput
  }

  /**
   * LeaseCountOutputType without action
   */
  export type LeaseCountOutputTypeCountLeaseDocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaseDocumentWhereInput
  }


  /**
   * Count Type InvoiceCountOutputType
   */

  export type InvoiceCountOutputType = {
    transactions: number
  }

  export type InvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | InvoiceCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     */
    select?: InvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Tenant
   */

  export type AggregateTenant = {
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  export type TenantMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    altEmail: string | null
    phone: string | null
    altPhone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    altEmail: string | null
    phone: string | null
    altPhone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    email: number
    altEmail: number
    phone: number
    altPhone: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TenantMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    altEmail?: true
    phone?: true
    altPhone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    altEmail?: true
    phone?: true
    altPhone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    altEmail?: true
    phone?: true
    altPhone?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TenantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenant to aggregate.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tenants
    **/
    _count?: true | TenantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantMaxAggregateInputType
  }

  export type GetTenantAggregateType<T extends TenantAggregateArgs> = {
        [P in keyof T & keyof AggregateTenant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenant[P]>
      : GetScalarType<T[P], AggregateTenant[P]>
  }




  export type TenantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantWhereInput
    orderBy?: TenantOrderByWithAggregationInput | TenantOrderByWithAggregationInput[]
    by: TenantScalarFieldEnum[] | TenantScalarFieldEnum
    having?: TenantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantCountAggregateInputType | true
    _min?: TenantMinAggregateInputType
    _max?: TenantMaxAggregateInputType
  }

  export type TenantGroupByOutputType = {
    id: string
    firstName: string
    lastName: string
    email: string
    altEmail: string | null
    phone: string
    altPhone: string | null
    createdAt: Date
    updatedAt: Date
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  type GetTenantGroupByPayload<T extends TenantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantGroupByOutputType[P]>
            : GetScalarType<T[P], TenantGroupByOutputType[P]>
        }
      >
    >


  export type TenantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    altEmail?: boolean
    phone?: boolean
    altPhone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Lease?: boolean | Tenant$LeaseArgs<ExtArgs>
    tenantLease?: boolean | Tenant$tenantLeaseArgs<ExtArgs>
    tenantDocument?: boolean | Tenant$tenantDocumentArgs<ExtArgs>
    tenantEmergencyContact?: boolean | Tenant$tenantEmergencyContactArgs<ExtArgs>
    tenantIncome?: boolean | Tenant$tenantIncomeArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    altEmail?: boolean
    phone?: boolean
    altPhone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    altEmail?: boolean
    phone?: boolean
    altPhone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    altEmail?: boolean
    phone?: boolean
    altPhone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TenantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "firstName" | "lastName" | "email" | "altEmail" | "phone" | "altPhone" | "createdAt" | "updatedAt", ExtArgs["result"]["tenant"]>
  export type TenantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Lease?: boolean | Tenant$LeaseArgs<ExtArgs>
    tenantLease?: boolean | Tenant$tenantLeaseArgs<ExtArgs>
    tenantDocument?: boolean | Tenant$tenantDocumentArgs<ExtArgs>
    tenantEmergencyContact?: boolean | Tenant$tenantEmergencyContactArgs<ExtArgs>
    tenantIncome?: boolean | Tenant$tenantIncomeArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TenantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TenantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TenantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tenant"
    objects: {
      Lease: Prisma.$LeasePayload<ExtArgs>[]
      tenantLease: Prisma.$TenantLeasePayload<ExtArgs>[]
      tenantDocument: Prisma.$TenantDocumentPayload<ExtArgs>[]
      tenantEmergencyContact: Prisma.$TenantEmergencyContactPayload<ExtArgs>[]
      tenantIncome: Prisma.$TenantIncomePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      firstName: string
      lastName: string
      email: string
      altEmail: string | null
      phone: string
      altPhone: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tenant"]>
    composites: {}
  }

  type TenantGetPayload<S extends boolean | null | undefined | TenantDefaultArgs> = $Result.GetResult<Prisma.$TenantPayload, S>

  type TenantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TenantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantCountAggregateInputType | true
    }

  export interface TenantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tenant'], meta: { name: 'Tenant' } }
    /**
     * Find zero or one Tenant that matches the filter.
     * @param {TenantFindUniqueArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantFindUniqueArgs>(args: SelectSubset<T, TenantFindUniqueArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tenant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TenantFindUniqueOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tenant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantFindFirstArgs>(args?: SelectSubset<T, TenantFindFirstArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tenant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tenants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tenants
     * const tenants = await prisma.tenant.findMany()
     * 
     * // Get first 10 Tenants
     * const tenants = await prisma.tenant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantWithIdOnly = await prisma.tenant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantFindManyArgs>(args?: SelectSubset<T, TenantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tenant.
     * @param {TenantCreateArgs} args - Arguments to create a Tenant.
     * @example
     * // Create one Tenant
     * const Tenant = await prisma.tenant.create({
     *   data: {
     *     // ... data to create a Tenant
     *   }
     * })
     * 
     */
    create<T extends TenantCreateArgs>(args: SelectSubset<T, TenantCreateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tenants.
     * @param {TenantCreateManyArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantCreateManyArgs>(args?: SelectSubset<T, TenantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tenants and returns the data saved in the database.
     * @param {TenantCreateManyAndReturnArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tenant.
     * @param {TenantDeleteArgs} args - Arguments to delete one Tenant.
     * @example
     * // Delete one Tenant
     * const Tenant = await prisma.tenant.delete({
     *   where: {
     *     // ... filter to delete one Tenant
     *   }
     * })
     * 
     */
    delete<T extends TenantDeleteArgs>(args: SelectSubset<T, TenantDeleteArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tenant.
     * @param {TenantUpdateArgs} args - Arguments to update one Tenant.
     * @example
     * // Update one Tenant
     * const tenant = await prisma.tenant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantUpdateArgs>(args: SelectSubset<T, TenantUpdateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tenants.
     * @param {TenantDeleteManyArgs} args - Arguments to filter Tenants to delete.
     * @example
     * // Delete a few Tenants
     * const { count } = await prisma.tenant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantDeleteManyArgs>(args?: SelectSubset<T, TenantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantUpdateManyArgs>(args: SelectSubset<T, TenantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants and returns the data updated in the database.
     * @param {TenantUpdateManyAndReturnArgs} args - Arguments to update many Tenants.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TenantUpdateManyAndReturnArgs>(args: SelectSubset<T, TenantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tenant.
     * @param {TenantUpsertArgs} args - Arguments to update or create a Tenant.
     * @example
     * // Update or create a Tenant
     * const tenant = await prisma.tenant.upsert({
     *   create: {
     *     // ... data to create a Tenant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tenant we want to update
     *   }
     * })
     */
    upsert<T extends TenantUpsertArgs>(args: SelectSubset<T, TenantUpsertArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantCountArgs} args - Arguments to filter Tenants to count.
     * @example
     * // Count the number of Tenants
     * const count = await prisma.tenant.count({
     *   where: {
     *     // ... the filter for the Tenants we want to count
     *   }
     * })
    **/
    count<T extends TenantCountArgs>(
      args?: Subset<T, TenantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantAggregateArgs>(args: Subset<T, TenantAggregateArgs>): Prisma.PrismaPromise<GetTenantAggregateType<T>>

    /**
     * Group by Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantGroupByArgs['orderBy'] }
        : { orderBy?: TenantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tenant model
   */
  readonly fields: TenantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tenant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Lease<T extends Tenant$LeaseArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$LeaseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tenantLease<T extends Tenant$tenantLeaseArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$tenantLeaseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantLeasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tenantDocument<T extends Tenant$tenantDocumentArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$tenantDocumentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tenantEmergencyContact<T extends Tenant$tenantEmergencyContactArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$tenantEmergencyContactArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantEmergencyContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tenantIncome<T extends Tenant$tenantIncomeArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$tenantIncomeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantIncomePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tenant model
   */
  interface TenantFieldRefs {
    readonly id: FieldRef<"Tenant", 'String'>
    readonly firstName: FieldRef<"Tenant", 'String'>
    readonly lastName: FieldRef<"Tenant", 'String'>
    readonly email: FieldRef<"Tenant", 'String'>
    readonly altEmail: FieldRef<"Tenant", 'String'>
    readonly phone: FieldRef<"Tenant", 'String'>
    readonly altPhone: FieldRef<"Tenant", 'String'>
    readonly createdAt: FieldRef<"Tenant", 'DateTime'>
    readonly updatedAt: FieldRef<"Tenant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tenant findUnique
   */
  export type TenantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findUniqueOrThrow
   */
  export type TenantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findFirst
   */
  export type TenantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findFirstOrThrow
   */
  export type TenantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findMany
   */
  export type TenantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenants to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant create
   */
  export type TenantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to create a Tenant.
     */
    data: XOR<TenantCreateInput, TenantUncheckedCreateInput>
  }

  /**
   * Tenant createMany
   */
  export type TenantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant createManyAndReturn
   */
  export type TenantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant update
   */
  export type TenantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to update a Tenant.
     */
    data: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
    /**
     * Choose, which Tenant to update.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant updateMany
   */
  export type TenantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to update.
     */
    limit?: number
  }

  /**
   * Tenant updateManyAndReturn
   */
  export type TenantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to update.
     */
    limit?: number
  }

  /**
   * Tenant upsert
   */
  export type TenantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The filter to search for the Tenant to update in case it exists.
     */
    where: TenantWhereUniqueInput
    /**
     * In case the Tenant found by the `where` argument doesn't exist, create a new Tenant with this data.
     */
    create: XOR<TenantCreateInput, TenantUncheckedCreateInput>
    /**
     * In case the Tenant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
  }

  /**
   * Tenant delete
   */
  export type TenantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter which Tenant to delete.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant deleteMany
   */
  export type TenantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenants to delete
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to delete.
     */
    limit?: number
  }

  /**
   * Tenant.Lease
   */
  export type Tenant$LeaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseInclude<ExtArgs> | null
    where?: LeaseWhereInput
    orderBy?: LeaseOrderByWithRelationInput | LeaseOrderByWithRelationInput[]
    cursor?: LeaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaseScalarFieldEnum | LeaseScalarFieldEnum[]
  }

  /**
   * Tenant.tenantLease
   */
  export type Tenant$tenantLeaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantLease
     */
    select?: TenantLeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantLease
     */
    omit?: TenantLeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantLeaseInclude<ExtArgs> | null
    where?: TenantLeaseWhereInput
    orderBy?: TenantLeaseOrderByWithRelationInput | TenantLeaseOrderByWithRelationInput[]
    cursor?: TenantLeaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TenantLeaseScalarFieldEnum | TenantLeaseScalarFieldEnum[]
  }

  /**
   * Tenant.tenantDocument
   */
  export type Tenant$tenantDocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantDocument
     */
    select?: TenantDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantDocument
     */
    omit?: TenantDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantDocumentInclude<ExtArgs> | null
    where?: TenantDocumentWhereInput
    orderBy?: TenantDocumentOrderByWithRelationInput | TenantDocumentOrderByWithRelationInput[]
    cursor?: TenantDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TenantDocumentScalarFieldEnum | TenantDocumentScalarFieldEnum[]
  }

  /**
   * Tenant.tenantEmergencyContact
   */
  export type Tenant$tenantEmergencyContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantEmergencyContact
     */
    select?: TenantEmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantEmergencyContact
     */
    omit?: TenantEmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantEmergencyContactInclude<ExtArgs> | null
    where?: TenantEmergencyContactWhereInput
    orderBy?: TenantEmergencyContactOrderByWithRelationInput | TenantEmergencyContactOrderByWithRelationInput[]
    cursor?: TenantEmergencyContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TenantEmergencyContactScalarFieldEnum | TenantEmergencyContactScalarFieldEnum[]
  }

  /**
   * Tenant.tenantIncome
   */
  export type Tenant$tenantIncomeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantIncome
     */
    select?: TenantIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantIncome
     */
    omit?: TenantIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantIncomeInclude<ExtArgs> | null
    where?: TenantIncomeWhereInput
    orderBy?: TenantIncomeOrderByWithRelationInput | TenantIncomeOrderByWithRelationInput[]
    cursor?: TenantIncomeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TenantIncomeScalarFieldEnum | TenantIncomeScalarFieldEnum[]
  }

  /**
   * Tenant without action
   */
  export type TenantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
  }


  /**
   * Model TenantEmergencyContact
   */

  export type AggregateTenantEmergencyContact = {
    _count: TenantEmergencyContactCountAggregateOutputType | null
    _min: TenantEmergencyContactMinAggregateOutputType | null
    _max: TenantEmergencyContactMaxAggregateOutputType | null
  }

  export type TenantEmergencyContactMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    phone: string | null
    email: string | null
    relationship: $Enums.TenantRelationship | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    state: string | null
    zip: string | null
    countryCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantEmergencyContactMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    phone: string | null
    email: string | null
    relationship: $Enums.TenantRelationship | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    state: string | null
    zip: string | null
    countryCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantEmergencyContactCountAggregateOutputType = {
    id: number
    tenantId: number
    name: number
    phone: number
    email: number
    relationship: number
    addressLine1: number
    addressLine2: number
    city: number
    state: number
    zip: number
    countryCode: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TenantEmergencyContactMinAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    phone?: true
    email?: true
    relationship?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    state?: true
    zip?: true
    countryCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantEmergencyContactMaxAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    phone?: true
    email?: true
    relationship?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    state?: true
    zip?: true
    countryCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantEmergencyContactCountAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    phone?: true
    email?: true
    relationship?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    state?: true
    zip?: true
    countryCode?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TenantEmergencyContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantEmergencyContact to aggregate.
     */
    where?: TenantEmergencyContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantEmergencyContacts to fetch.
     */
    orderBy?: TenantEmergencyContactOrderByWithRelationInput | TenantEmergencyContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantEmergencyContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantEmergencyContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantEmergencyContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TenantEmergencyContacts
    **/
    _count?: true | TenantEmergencyContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantEmergencyContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantEmergencyContactMaxAggregateInputType
  }

  export type GetTenantEmergencyContactAggregateType<T extends TenantEmergencyContactAggregateArgs> = {
        [P in keyof T & keyof AggregateTenantEmergencyContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenantEmergencyContact[P]>
      : GetScalarType<T[P], AggregateTenantEmergencyContact[P]>
  }




  export type TenantEmergencyContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantEmergencyContactWhereInput
    orderBy?: TenantEmergencyContactOrderByWithAggregationInput | TenantEmergencyContactOrderByWithAggregationInput[]
    by: TenantEmergencyContactScalarFieldEnum[] | TenantEmergencyContactScalarFieldEnum
    having?: TenantEmergencyContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantEmergencyContactCountAggregateInputType | true
    _min?: TenantEmergencyContactMinAggregateInputType
    _max?: TenantEmergencyContactMaxAggregateInputType
  }

  export type TenantEmergencyContactGroupByOutputType = {
    id: string
    tenantId: string
    name: string
    phone: string
    email: string
    relationship: $Enums.TenantRelationship
    addressLine1: string
    addressLine2: string | null
    city: string
    state: string
    zip: string
    countryCode: string
    createdAt: Date
    updatedAt: Date
    _count: TenantEmergencyContactCountAggregateOutputType | null
    _min: TenantEmergencyContactMinAggregateOutputType | null
    _max: TenantEmergencyContactMaxAggregateOutputType | null
  }

  type GetTenantEmergencyContactGroupByPayload<T extends TenantEmergencyContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantEmergencyContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantEmergencyContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantEmergencyContactGroupByOutputType[P]>
            : GetScalarType<T[P], TenantEmergencyContactGroupByOutputType[P]>
        }
      >
    >


  export type TenantEmergencyContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    relationship?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    zip?: boolean
    countryCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantEmergencyContact"]>

  export type TenantEmergencyContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    relationship?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    zip?: boolean
    countryCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantEmergencyContact"]>

  export type TenantEmergencyContactSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    relationship?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    zip?: boolean
    countryCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantEmergencyContact"]>

  export type TenantEmergencyContactSelectScalar = {
    id?: boolean
    tenantId?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    relationship?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    zip?: boolean
    countryCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TenantEmergencyContactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "name" | "phone" | "email" | "relationship" | "addressLine1" | "addressLine2" | "city" | "state" | "zip" | "countryCode" | "createdAt" | "updatedAt", ExtArgs["result"]["tenantEmergencyContact"]>
  export type TenantEmergencyContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type TenantEmergencyContactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type TenantEmergencyContactIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $TenantEmergencyContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TenantEmergencyContact"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      name: string
      phone: string
      email: string
      relationship: $Enums.TenantRelationship
      addressLine1: string
      addressLine2: string | null
      city: string
      state: string
      zip: string
      countryCode: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tenantEmergencyContact"]>
    composites: {}
  }

  type TenantEmergencyContactGetPayload<S extends boolean | null | undefined | TenantEmergencyContactDefaultArgs> = $Result.GetResult<Prisma.$TenantEmergencyContactPayload, S>

  type TenantEmergencyContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TenantEmergencyContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantEmergencyContactCountAggregateInputType | true
    }

  export interface TenantEmergencyContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TenantEmergencyContact'], meta: { name: 'TenantEmergencyContact' } }
    /**
     * Find zero or one TenantEmergencyContact that matches the filter.
     * @param {TenantEmergencyContactFindUniqueArgs} args - Arguments to find a TenantEmergencyContact
     * @example
     * // Get one TenantEmergencyContact
     * const tenantEmergencyContact = await prisma.tenantEmergencyContact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantEmergencyContactFindUniqueArgs>(args: SelectSubset<T, TenantEmergencyContactFindUniqueArgs<ExtArgs>>): Prisma__TenantEmergencyContactClient<$Result.GetResult<Prisma.$TenantEmergencyContactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TenantEmergencyContact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TenantEmergencyContactFindUniqueOrThrowArgs} args - Arguments to find a TenantEmergencyContact
     * @example
     * // Get one TenantEmergencyContact
     * const tenantEmergencyContact = await prisma.tenantEmergencyContact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantEmergencyContactFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantEmergencyContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantEmergencyContactClient<$Result.GetResult<Prisma.$TenantEmergencyContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantEmergencyContact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantEmergencyContactFindFirstArgs} args - Arguments to find a TenantEmergencyContact
     * @example
     * // Get one TenantEmergencyContact
     * const tenantEmergencyContact = await prisma.tenantEmergencyContact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantEmergencyContactFindFirstArgs>(args?: SelectSubset<T, TenantEmergencyContactFindFirstArgs<ExtArgs>>): Prisma__TenantEmergencyContactClient<$Result.GetResult<Prisma.$TenantEmergencyContactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantEmergencyContact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantEmergencyContactFindFirstOrThrowArgs} args - Arguments to find a TenantEmergencyContact
     * @example
     * // Get one TenantEmergencyContact
     * const tenantEmergencyContact = await prisma.tenantEmergencyContact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantEmergencyContactFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantEmergencyContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantEmergencyContactClient<$Result.GetResult<Prisma.$TenantEmergencyContactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TenantEmergencyContacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantEmergencyContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TenantEmergencyContacts
     * const tenantEmergencyContacts = await prisma.tenantEmergencyContact.findMany()
     * 
     * // Get first 10 TenantEmergencyContacts
     * const tenantEmergencyContacts = await prisma.tenantEmergencyContact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantEmergencyContactWithIdOnly = await prisma.tenantEmergencyContact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantEmergencyContactFindManyArgs>(args?: SelectSubset<T, TenantEmergencyContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantEmergencyContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TenantEmergencyContact.
     * @param {TenantEmergencyContactCreateArgs} args - Arguments to create a TenantEmergencyContact.
     * @example
     * // Create one TenantEmergencyContact
     * const TenantEmergencyContact = await prisma.tenantEmergencyContact.create({
     *   data: {
     *     // ... data to create a TenantEmergencyContact
     *   }
     * })
     * 
     */
    create<T extends TenantEmergencyContactCreateArgs>(args: SelectSubset<T, TenantEmergencyContactCreateArgs<ExtArgs>>): Prisma__TenantEmergencyContactClient<$Result.GetResult<Prisma.$TenantEmergencyContactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TenantEmergencyContacts.
     * @param {TenantEmergencyContactCreateManyArgs} args - Arguments to create many TenantEmergencyContacts.
     * @example
     * // Create many TenantEmergencyContacts
     * const tenantEmergencyContact = await prisma.tenantEmergencyContact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantEmergencyContactCreateManyArgs>(args?: SelectSubset<T, TenantEmergencyContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TenantEmergencyContacts and returns the data saved in the database.
     * @param {TenantEmergencyContactCreateManyAndReturnArgs} args - Arguments to create many TenantEmergencyContacts.
     * @example
     * // Create many TenantEmergencyContacts
     * const tenantEmergencyContact = await prisma.tenantEmergencyContact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TenantEmergencyContacts and only return the `id`
     * const tenantEmergencyContactWithIdOnly = await prisma.tenantEmergencyContact.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantEmergencyContactCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantEmergencyContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantEmergencyContactPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TenantEmergencyContact.
     * @param {TenantEmergencyContactDeleteArgs} args - Arguments to delete one TenantEmergencyContact.
     * @example
     * // Delete one TenantEmergencyContact
     * const TenantEmergencyContact = await prisma.tenantEmergencyContact.delete({
     *   where: {
     *     // ... filter to delete one TenantEmergencyContact
     *   }
     * })
     * 
     */
    delete<T extends TenantEmergencyContactDeleteArgs>(args: SelectSubset<T, TenantEmergencyContactDeleteArgs<ExtArgs>>): Prisma__TenantEmergencyContactClient<$Result.GetResult<Prisma.$TenantEmergencyContactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TenantEmergencyContact.
     * @param {TenantEmergencyContactUpdateArgs} args - Arguments to update one TenantEmergencyContact.
     * @example
     * // Update one TenantEmergencyContact
     * const tenantEmergencyContact = await prisma.tenantEmergencyContact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantEmergencyContactUpdateArgs>(args: SelectSubset<T, TenantEmergencyContactUpdateArgs<ExtArgs>>): Prisma__TenantEmergencyContactClient<$Result.GetResult<Prisma.$TenantEmergencyContactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TenantEmergencyContacts.
     * @param {TenantEmergencyContactDeleteManyArgs} args - Arguments to filter TenantEmergencyContacts to delete.
     * @example
     * // Delete a few TenantEmergencyContacts
     * const { count } = await prisma.tenantEmergencyContact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantEmergencyContactDeleteManyArgs>(args?: SelectSubset<T, TenantEmergencyContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantEmergencyContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantEmergencyContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TenantEmergencyContacts
     * const tenantEmergencyContact = await prisma.tenantEmergencyContact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantEmergencyContactUpdateManyArgs>(args: SelectSubset<T, TenantEmergencyContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantEmergencyContacts and returns the data updated in the database.
     * @param {TenantEmergencyContactUpdateManyAndReturnArgs} args - Arguments to update many TenantEmergencyContacts.
     * @example
     * // Update many TenantEmergencyContacts
     * const tenantEmergencyContact = await prisma.tenantEmergencyContact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TenantEmergencyContacts and only return the `id`
     * const tenantEmergencyContactWithIdOnly = await prisma.tenantEmergencyContact.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TenantEmergencyContactUpdateManyAndReturnArgs>(args: SelectSubset<T, TenantEmergencyContactUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantEmergencyContactPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TenantEmergencyContact.
     * @param {TenantEmergencyContactUpsertArgs} args - Arguments to update or create a TenantEmergencyContact.
     * @example
     * // Update or create a TenantEmergencyContact
     * const tenantEmergencyContact = await prisma.tenantEmergencyContact.upsert({
     *   create: {
     *     // ... data to create a TenantEmergencyContact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TenantEmergencyContact we want to update
     *   }
     * })
     */
    upsert<T extends TenantEmergencyContactUpsertArgs>(args: SelectSubset<T, TenantEmergencyContactUpsertArgs<ExtArgs>>): Prisma__TenantEmergencyContactClient<$Result.GetResult<Prisma.$TenantEmergencyContactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TenantEmergencyContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantEmergencyContactCountArgs} args - Arguments to filter TenantEmergencyContacts to count.
     * @example
     * // Count the number of TenantEmergencyContacts
     * const count = await prisma.tenantEmergencyContact.count({
     *   where: {
     *     // ... the filter for the TenantEmergencyContacts we want to count
     *   }
     * })
    **/
    count<T extends TenantEmergencyContactCountArgs>(
      args?: Subset<T, TenantEmergencyContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantEmergencyContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TenantEmergencyContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantEmergencyContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantEmergencyContactAggregateArgs>(args: Subset<T, TenantEmergencyContactAggregateArgs>): Prisma.PrismaPromise<GetTenantEmergencyContactAggregateType<T>>

    /**
     * Group by TenantEmergencyContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantEmergencyContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantEmergencyContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantEmergencyContactGroupByArgs['orderBy'] }
        : { orderBy?: TenantEmergencyContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantEmergencyContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantEmergencyContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TenantEmergencyContact model
   */
  readonly fields: TenantEmergencyContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TenantEmergencyContact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantEmergencyContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TenantEmergencyContact model
   */
  interface TenantEmergencyContactFieldRefs {
    readonly id: FieldRef<"TenantEmergencyContact", 'String'>
    readonly tenantId: FieldRef<"TenantEmergencyContact", 'String'>
    readonly name: FieldRef<"TenantEmergencyContact", 'String'>
    readonly phone: FieldRef<"TenantEmergencyContact", 'String'>
    readonly email: FieldRef<"TenantEmergencyContact", 'String'>
    readonly relationship: FieldRef<"TenantEmergencyContact", 'TenantRelationship'>
    readonly addressLine1: FieldRef<"TenantEmergencyContact", 'String'>
    readonly addressLine2: FieldRef<"TenantEmergencyContact", 'String'>
    readonly city: FieldRef<"TenantEmergencyContact", 'String'>
    readonly state: FieldRef<"TenantEmergencyContact", 'String'>
    readonly zip: FieldRef<"TenantEmergencyContact", 'String'>
    readonly countryCode: FieldRef<"TenantEmergencyContact", 'String'>
    readonly createdAt: FieldRef<"TenantEmergencyContact", 'DateTime'>
    readonly updatedAt: FieldRef<"TenantEmergencyContact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TenantEmergencyContact findUnique
   */
  export type TenantEmergencyContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantEmergencyContact
     */
    select?: TenantEmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantEmergencyContact
     */
    omit?: TenantEmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantEmergencyContactInclude<ExtArgs> | null
    /**
     * Filter, which TenantEmergencyContact to fetch.
     */
    where: TenantEmergencyContactWhereUniqueInput
  }

  /**
   * TenantEmergencyContact findUniqueOrThrow
   */
  export type TenantEmergencyContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantEmergencyContact
     */
    select?: TenantEmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantEmergencyContact
     */
    omit?: TenantEmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantEmergencyContactInclude<ExtArgs> | null
    /**
     * Filter, which TenantEmergencyContact to fetch.
     */
    where: TenantEmergencyContactWhereUniqueInput
  }

  /**
   * TenantEmergencyContact findFirst
   */
  export type TenantEmergencyContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantEmergencyContact
     */
    select?: TenantEmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantEmergencyContact
     */
    omit?: TenantEmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantEmergencyContactInclude<ExtArgs> | null
    /**
     * Filter, which TenantEmergencyContact to fetch.
     */
    where?: TenantEmergencyContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantEmergencyContacts to fetch.
     */
    orderBy?: TenantEmergencyContactOrderByWithRelationInput | TenantEmergencyContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantEmergencyContacts.
     */
    cursor?: TenantEmergencyContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantEmergencyContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantEmergencyContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantEmergencyContacts.
     */
    distinct?: TenantEmergencyContactScalarFieldEnum | TenantEmergencyContactScalarFieldEnum[]
  }

  /**
   * TenantEmergencyContact findFirstOrThrow
   */
  export type TenantEmergencyContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantEmergencyContact
     */
    select?: TenantEmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantEmergencyContact
     */
    omit?: TenantEmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantEmergencyContactInclude<ExtArgs> | null
    /**
     * Filter, which TenantEmergencyContact to fetch.
     */
    where?: TenantEmergencyContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantEmergencyContacts to fetch.
     */
    orderBy?: TenantEmergencyContactOrderByWithRelationInput | TenantEmergencyContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantEmergencyContacts.
     */
    cursor?: TenantEmergencyContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantEmergencyContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantEmergencyContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantEmergencyContacts.
     */
    distinct?: TenantEmergencyContactScalarFieldEnum | TenantEmergencyContactScalarFieldEnum[]
  }

  /**
   * TenantEmergencyContact findMany
   */
  export type TenantEmergencyContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantEmergencyContact
     */
    select?: TenantEmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantEmergencyContact
     */
    omit?: TenantEmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantEmergencyContactInclude<ExtArgs> | null
    /**
     * Filter, which TenantEmergencyContacts to fetch.
     */
    where?: TenantEmergencyContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantEmergencyContacts to fetch.
     */
    orderBy?: TenantEmergencyContactOrderByWithRelationInput | TenantEmergencyContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TenantEmergencyContacts.
     */
    cursor?: TenantEmergencyContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantEmergencyContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantEmergencyContacts.
     */
    skip?: number
    distinct?: TenantEmergencyContactScalarFieldEnum | TenantEmergencyContactScalarFieldEnum[]
  }

  /**
   * TenantEmergencyContact create
   */
  export type TenantEmergencyContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantEmergencyContact
     */
    select?: TenantEmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantEmergencyContact
     */
    omit?: TenantEmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantEmergencyContactInclude<ExtArgs> | null
    /**
     * The data needed to create a TenantEmergencyContact.
     */
    data: XOR<TenantEmergencyContactCreateInput, TenantEmergencyContactUncheckedCreateInput>
  }

  /**
   * TenantEmergencyContact createMany
   */
  export type TenantEmergencyContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TenantEmergencyContacts.
     */
    data: TenantEmergencyContactCreateManyInput | TenantEmergencyContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TenantEmergencyContact createManyAndReturn
   */
  export type TenantEmergencyContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantEmergencyContact
     */
    select?: TenantEmergencyContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TenantEmergencyContact
     */
    omit?: TenantEmergencyContactOmit<ExtArgs> | null
    /**
     * The data used to create many TenantEmergencyContacts.
     */
    data: TenantEmergencyContactCreateManyInput | TenantEmergencyContactCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantEmergencyContactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenantEmergencyContact update
   */
  export type TenantEmergencyContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantEmergencyContact
     */
    select?: TenantEmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantEmergencyContact
     */
    omit?: TenantEmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantEmergencyContactInclude<ExtArgs> | null
    /**
     * The data needed to update a TenantEmergencyContact.
     */
    data: XOR<TenantEmergencyContactUpdateInput, TenantEmergencyContactUncheckedUpdateInput>
    /**
     * Choose, which TenantEmergencyContact to update.
     */
    where: TenantEmergencyContactWhereUniqueInput
  }

  /**
   * TenantEmergencyContact updateMany
   */
  export type TenantEmergencyContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TenantEmergencyContacts.
     */
    data: XOR<TenantEmergencyContactUpdateManyMutationInput, TenantEmergencyContactUncheckedUpdateManyInput>
    /**
     * Filter which TenantEmergencyContacts to update
     */
    where?: TenantEmergencyContactWhereInput
    /**
     * Limit how many TenantEmergencyContacts to update.
     */
    limit?: number
  }

  /**
   * TenantEmergencyContact updateManyAndReturn
   */
  export type TenantEmergencyContactUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantEmergencyContact
     */
    select?: TenantEmergencyContactSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TenantEmergencyContact
     */
    omit?: TenantEmergencyContactOmit<ExtArgs> | null
    /**
     * The data used to update TenantEmergencyContacts.
     */
    data: XOR<TenantEmergencyContactUpdateManyMutationInput, TenantEmergencyContactUncheckedUpdateManyInput>
    /**
     * Filter which TenantEmergencyContacts to update
     */
    where?: TenantEmergencyContactWhereInput
    /**
     * Limit how many TenantEmergencyContacts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantEmergencyContactIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenantEmergencyContact upsert
   */
  export type TenantEmergencyContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantEmergencyContact
     */
    select?: TenantEmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantEmergencyContact
     */
    omit?: TenantEmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantEmergencyContactInclude<ExtArgs> | null
    /**
     * The filter to search for the TenantEmergencyContact to update in case it exists.
     */
    where: TenantEmergencyContactWhereUniqueInput
    /**
     * In case the TenantEmergencyContact found by the `where` argument doesn't exist, create a new TenantEmergencyContact with this data.
     */
    create: XOR<TenantEmergencyContactCreateInput, TenantEmergencyContactUncheckedCreateInput>
    /**
     * In case the TenantEmergencyContact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantEmergencyContactUpdateInput, TenantEmergencyContactUncheckedUpdateInput>
  }

  /**
   * TenantEmergencyContact delete
   */
  export type TenantEmergencyContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantEmergencyContact
     */
    select?: TenantEmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantEmergencyContact
     */
    omit?: TenantEmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantEmergencyContactInclude<ExtArgs> | null
    /**
     * Filter which TenantEmergencyContact to delete.
     */
    where: TenantEmergencyContactWhereUniqueInput
  }

  /**
   * TenantEmergencyContact deleteMany
   */
  export type TenantEmergencyContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantEmergencyContacts to delete
     */
    where?: TenantEmergencyContactWhereInput
    /**
     * Limit how many TenantEmergencyContacts to delete.
     */
    limit?: number
  }

  /**
   * TenantEmergencyContact without action
   */
  export type TenantEmergencyContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantEmergencyContact
     */
    select?: TenantEmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantEmergencyContact
     */
    omit?: TenantEmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantEmergencyContactInclude<ExtArgs> | null
  }


  /**
   * Model TenantIncome
   */

  export type AggregateTenantIncome = {
    _count: TenantIncomeCountAggregateOutputType | null
    _avg: TenantIncomeAvgAggregateOutputType | null
    _sum: TenantIncomeSumAggregateOutputType | null
    _min: TenantIncomeMinAggregateOutputType | null
    _max: TenantIncomeMaxAggregateOutputType | null
  }

  export type TenantIncomeAvgAggregateOutputType = {
    income: number | null
  }

  export type TenantIncomeSumAggregateOutputType = {
    income: number | null
  }

  export type TenantIncomeMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    income: number | null
    incomeType: $Enums.TenantIncomeType | null
    position: string | null
    employer: string | null
    employerAddressLine1: string | null
    employerAddressLine2: string | null
    employerCity: string | null
    employerState: string | null
    employerZip: string | null
    employerCountryCode: string | null
    startDate: Date | null
    endDate: Date | null
    currentIncome: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantIncomeMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    income: number | null
    incomeType: $Enums.TenantIncomeType | null
    position: string | null
    employer: string | null
    employerAddressLine1: string | null
    employerAddressLine2: string | null
    employerCity: string | null
    employerState: string | null
    employerZip: string | null
    employerCountryCode: string | null
    startDate: Date | null
    endDate: Date | null
    currentIncome: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantIncomeCountAggregateOutputType = {
    id: number
    tenantId: number
    income: number
    incomeType: number
    position: number
    employer: number
    employerAddressLine1: number
    employerAddressLine2: number
    employerCity: number
    employerState: number
    employerZip: number
    employerCountryCode: number
    startDate: number
    endDate: number
    currentIncome: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TenantIncomeAvgAggregateInputType = {
    income?: true
  }

  export type TenantIncomeSumAggregateInputType = {
    income?: true
  }

  export type TenantIncomeMinAggregateInputType = {
    id?: true
    tenantId?: true
    income?: true
    incomeType?: true
    position?: true
    employer?: true
    employerAddressLine1?: true
    employerAddressLine2?: true
    employerCity?: true
    employerState?: true
    employerZip?: true
    employerCountryCode?: true
    startDate?: true
    endDate?: true
    currentIncome?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantIncomeMaxAggregateInputType = {
    id?: true
    tenantId?: true
    income?: true
    incomeType?: true
    position?: true
    employer?: true
    employerAddressLine1?: true
    employerAddressLine2?: true
    employerCity?: true
    employerState?: true
    employerZip?: true
    employerCountryCode?: true
    startDate?: true
    endDate?: true
    currentIncome?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantIncomeCountAggregateInputType = {
    id?: true
    tenantId?: true
    income?: true
    incomeType?: true
    position?: true
    employer?: true
    employerAddressLine1?: true
    employerAddressLine2?: true
    employerCity?: true
    employerState?: true
    employerZip?: true
    employerCountryCode?: true
    startDate?: true
    endDate?: true
    currentIncome?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TenantIncomeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantIncome to aggregate.
     */
    where?: TenantIncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantIncomes to fetch.
     */
    orderBy?: TenantIncomeOrderByWithRelationInput | TenantIncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantIncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantIncomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantIncomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TenantIncomes
    **/
    _count?: true | TenantIncomeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TenantIncomeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TenantIncomeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantIncomeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantIncomeMaxAggregateInputType
  }

  export type GetTenantIncomeAggregateType<T extends TenantIncomeAggregateArgs> = {
        [P in keyof T & keyof AggregateTenantIncome]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenantIncome[P]>
      : GetScalarType<T[P], AggregateTenantIncome[P]>
  }




  export type TenantIncomeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantIncomeWhereInput
    orderBy?: TenantIncomeOrderByWithAggregationInput | TenantIncomeOrderByWithAggregationInput[]
    by: TenantIncomeScalarFieldEnum[] | TenantIncomeScalarFieldEnum
    having?: TenantIncomeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantIncomeCountAggregateInputType | true
    _avg?: TenantIncomeAvgAggregateInputType
    _sum?: TenantIncomeSumAggregateInputType
    _min?: TenantIncomeMinAggregateInputType
    _max?: TenantIncomeMaxAggregateInputType
  }

  export type TenantIncomeGroupByOutputType = {
    id: string
    tenantId: string
    income: number
    incomeType: $Enums.TenantIncomeType
    position: string | null
    employer: string | null
    employerAddressLine1: string | null
    employerAddressLine2: string | null
    employerCity: string | null
    employerState: string | null
    employerZip: string | null
    employerCountryCode: string | null
    startDate: Date
    endDate: Date
    currentIncome: boolean
    createdAt: Date
    updatedAt: Date
    _count: TenantIncomeCountAggregateOutputType | null
    _avg: TenantIncomeAvgAggregateOutputType | null
    _sum: TenantIncomeSumAggregateOutputType | null
    _min: TenantIncomeMinAggregateOutputType | null
    _max: TenantIncomeMaxAggregateOutputType | null
  }

  type GetTenantIncomeGroupByPayload<T extends TenantIncomeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantIncomeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantIncomeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantIncomeGroupByOutputType[P]>
            : GetScalarType<T[P], TenantIncomeGroupByOutputType[P]>
        }
      >
    >


  export type TenantIncomeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    income?: boolean
    incomeType?: boolean
    position?: boolean
    employer?: boolean
    employerAddressLine1?: boolean
    employerAddressLine2?: boolean
    employerCity?: boolean
    employerState?: boolean
    employerZip?: boolean
    employerCountryCode?: boolean
    startDate?: boolean
    endDate?: boolean
    currentIncome?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantIncome"]>

  export type TenantIncomeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    income?: boolean
    incomeType?: boolean
    position?: boolean
    employer?: boolean
    employerAddressLine1?: boolean
    employerAddressLine2?: boolean
    employerCity?: boolean
    employerState?: boolean
    employerZip?: boolean
    employerCountryCode?: boolean
    startDate?: boolean
    endDate?: boolean
    currentIncome?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantIncome"]>

  export type TenantIncomeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    income?: boolean
    incomeType?: boolean
    position?: boolean
    employer?: boolean
    employerAddressLine1?: boolean
    employerAddressLine2?: boolean
    employerCity?: boolean
    employerState?: boolean
    employerZip?: boolean
    employerCountryCode?: boolean
    startDate?: boolean
    endDate?: boolean
    currentIncome?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantIncome"]>

  export type TenantIncomeSelectScalar = {
    id?: boolean
    tenantId?: boolean
    income?: boolean
    incomeType?: boolean
    position?: boolean
    employer?: boolean
    employerAddressLine1?: boolean
    employerAddressLine2?: boolean
    employerCity?: boolean
    employerState?: boolean
    employerZip?: boolean
    employerCountryCode?: boolean
    startDate?: boolean
    endDate?: boolean
    currentIncome?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TenantIncomeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "income" | "incomeType" | "position" | "employer" | "employerAddressLine1" | "employerAddressLine2" | "employerCity" | "employerState" | "employerZip" | "employerCountryCode" | "startDate" | "endDate" | "currentIncome" | "createdAt" | "updatedAt", ExtArgs["result"]["tenantIncome"]>
  export type TenantIncomeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type TenantIncomeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type TenantIncomeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $TenantIncomePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TenantIncome"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      income: number
      incomeType: $Enums.TenantIncomeType
      position: string | null
      employer: string | null
      employerAddressLine1: string | null
      employerAddressLine2: string | null
      employerCity: string | null
      employerState: string | null
      employerZip: string | null
      employerCountryCode: string | null
      startDate: Date
      endDate: Date
      currentIncome: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tenantIncome"]>
    composites: {}
  }

  type TenantIncomeGetPayload<S extends boolean | null | undefined | TenantIncomeDefaultArgs> = $Result.GetResult<Prisma.$TenantIncomePayload, S>

  type TenantIncomeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TenantIncomeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantIncomeCountAggregateInputType | true
    }

  export interface TenantIncomeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TenantIncome'], meta: { name: 'TenantIncome' } }
    /**
     * Find zero or one TenantIncome that matches the filter.
     * @param {TenantIncomeFindUniqueArgs} args - Arguments to find a TenantIncome
     * @example
     * // Get one TenantIncome
     * const tenantIncome = await prisma.tenantIncome.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantIncomeFindUniqueArgs>(args: SelectSubset<T, TenantIncomeFindUniqueArgs<ExtArgs>>): Prisma__TenantIncomeClient<$Result.GetResult<Prisma.$TenantIncomePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TenantIncome that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TenantIncomeFindUniqueOrThrowArgs} args - Arguments to find a TenantIncome
     * @example
     * // Get one TenantIncome
     * const tenantIncome = await prisma.tenantIncome.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantIncomeFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantIncomeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantIncomeClient<$Result.GetResult<Prisma.$TenantIncomePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantIncome that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantIncomeFindFirstArgs} args - Arguments to find a TenantIncome
     * @example
     * // Get one TenantIncome
     * const tenantIncome = await prisma.tenantIncome.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantIncomeFindFirstArgs>(args?: SelectSubset<T, TenantIncomeFindFirstArgs<ExtArgs>>): Prisma__TenantIncomeClient<$Result.GetResult<Prisma.$TenantIncomePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantIncome that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantIncomeFindFirstOrThrowArgs} args - Arguments to find a TenantIncome
     * @example
     * // Get one TenantIncome
     * const tenantIncome = await prisma.tenantIncome.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantIncomeFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantIncomeFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantIncomeClient<$Result.GetResult<Prisma.$TenantIncomePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TenantIncomes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantIncomeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TenantIncomes
     * const tenantIncomes = await prisma.tenantIncome.findMany()
     * 
     * // Get first 10 TenantIncomes
     * const tenantIncomes = await prisma.tenantIncome.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantIncomeWithIdOnly = await prisma.tenantIncome.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantIncomeFindManyArgs>(args?: SelectSubset<T, TenantIncomeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantIncomePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TenantIncome.
     * @param {TenantIncomeCreateArgs} args - Arguments to create a TenantIncome.
     * @example
     * // Create one TenantIncome
     * const TenantIncome = await prisma.tenantIncome.create({
     *   data: {
     *     // ... data to create a TenantIncome
     *   }
     * })
     * 
     */
    create<T extends TenantIncomeCreateArgs>(args: SelectSubset<T, TenantIncomeCreateArgs<ExtArgs>>): Prisma__TenantIncomeClient<$Result.GetResult<Prisma.$TenantIncomePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TenantIncomes.
     * @param {TenantIncomeCreateManyArgs} args - Arguments to create many TenantIncomes.
     * @example
     * // Create many TenantIncomes
     * const tenantIncome = await prisma.tenantIncome.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantIncomeCreateManyArgs>(args?: SelectSubset<T, TenantIncomeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TenantIncomes and returns the data saved in the database.
     * @param {TenantIncomeCreateManyAndReturnArgs} args - Arguments to create many TenantIncomes.
     * @example
     * // Create many TenantIncomes
     * const tenantIncome = await prisma.tenantIncome.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TenantIncomes and only return the `id`
     * const tenantIncomeWithIdOnly = await prisma.tenantIncome.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantIncomeCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantIncomeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantIncomePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TenantIncome.
     * @param {TenantIncomeDeleteArgs} args - Arguments to delete one TenantIncome.
     * @example
     * // Delete one TenantIncome
     * const TenantIncome = await prisma.tenantIncome.delete({
     *   where: {
     *     // ... filter to delete one TenantIncome
     *   }
     * })
     * 
     */
    delete<T extends TenantIncomeDeleteArgs>(args: SelectSubset<T, TenantIncomeDeleteArgs<ExtArgs>>): Prisma__TenantIncomeClient<$Result.GetResult<Prisma.$TenantIncomePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TenantIncome.
     * @param {TenantIncomeUpdateArgs} args - Arguments to update one TenantIncome.
     * @example
     * // Update one TenantIncome
     * const tenantIncome = await prisma.tenantIncome.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantIncomeUpdateArgs>(args: SelectSubset<T, TenantIncomeUpdateArgs<ExtArgs>>): Prisma__TenantIncomeClient<$Result.GetResult<Prisma.$TenantIncomePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TenantIncomes.
     * @param {TenantIncomeDeleteManyArgs} args - Arguments to filter TenantIncomes to delete.
     * @example
     * // Delete a few TenantIncomes
     * const { count } = await prisma.tenantIncome.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantIncomeDeleteManyArgs>(args?: SelectSubset<T, TenantIncomeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantIncomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantIncomeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TenantIncomes
     * const tenantIncome = await prisma.tenantIncome.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantIncomeUpdateManyArgs>(args: SelectSubset<T, TenantIncomeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantIncomes and returns the data updated in the database.
     * @param {TenantIncomeUpdateManyAndReturnArgs} args - Arguments to update many TenantIncomes.
     * @example
     * // Update many TenantIncomes
     * const tenantIncome = await prisma.tenantIncome.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TenantIncomes and only return the `id`
     * const tenantIncomeWithIdOnly = await prisma.tenantIncome.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TenantIncomeUpdateManyAndReturnArgs>(args: SelectSubset<T, TenantIncomeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantIncomePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TenantIncome.
     * @param {TenantIncomeUpsertArgs} args - Arguments to update or create a TenantIncome.
     * @example
     * // Update or create a TenantIncome
     * const tenantIncome = await prisma.tenantIncome.upsert({
     *   create: {
     *     // ... data to create a TenantIncome
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TenantIncome we want to update
     *   }
     * })
     */
    upsert<T extends TenantIncomeUpsertArgs>(args: SelectSubset<T, TenantIncomeUpsertArgs<ExtArgs>>): Prisma__TenantIncomeClient<$Result.GetResult<Prisma.$TenantIncomePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TenantIncomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantIncomeCountArgs} args - Arguments to filter TenantIncomes to count.
     * @example
     * // Count the number of TenantIncomes
     * const count = await prisma.tenantIncome.count({
     *   where: {
     *     // ... the filter for the TenantIncomes we want to count
     *   }
     * })
    **/
    count<T extends TenantIncomeCountArgs>(
      args?: Subset<T, TenantIncomeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantIncomeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TenantIncome.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantIncomeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantIncomeAggregateArgs>(args: Subset<T, TenantIncomeAggregateArgs>): Prisma.PrismaPromise<GetTenantIncomeAggregateType<T>>

    /**
     * Group by TenantIncome.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantIncomeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantIncomeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantIncomeGroupByArgs['orderBy'] }
        : { orderBy?: TenantIncomeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantIncomeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantIncomeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TenantIncome model
   */
  readonly fields: TenantIncomeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TenantIncome.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantIncomeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TenantIncome model
   */
  interface TenantIncomeFieldRefs {
    readonly id: FieldRef<"TenantIncome", 'String'>
    readonly tenantId: FieldRef<"TenantIncome", 'String'>
    readonly income: FieldRef<"TenantIncome", 'Float'>
    readonly incomeType: FieldRef<"TenantIncome", 'TenantIncomeType'>
    readonly position: FieldRef<"TenantIncome", 'String'>
    readonly employer: FieldRef<"TenantIncome", 'String'>
    readonly employerAddressLine1: FieldRef<"TenantIncome", 'String'>
    readonly employerAddressLine2: FieldRef<"TenantIncome", 'String'>
    readonly employerCity: FieldRef<"TenantIncome", 'String'>
    readonly employerState: FieldRef<"TenantIncome", 'String'>
    readonly employerZip: FieldRef<"TenantIncome", 'String'>
    readonly employerCountryCode: FieldRef<"TenantIncome", 'String'>
    readonly startDate: FieldRef<"TenantIncome", 'DateTime'>
    readonly endDate: FieldRef<"TenantIncome", 'DateTime'>
    readonly currentIncome: FieldRef<"TenantIncome", 'Boolean'>
    readonly createdAt: FieldRef<"TenantIncome", 'DateTime'>
    readonly updatedAt: FieldRef<"TenantIncome", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TenantIncome findUnique
   */
  export type TenantIncomeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantIncome
     */
    select?: TenantIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantIncome
     */
    omit?: TenantIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantIncomeInclude<ExtArgs> | null
    /**
     * Filter, which TenantIncome to fetch.
     */
    where: TenantIncomeWhereUniqueInput
  }

  /**
   * TenantIncome findUniqueOrThrow
   */
  export type TenantIncomeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantIncome
     */
    select?: TenantIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantIncome
     */
    omit?: TenantIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantIncomeInclude<ExtArgs> | null
    /**
     * Filter, which TenantIncome to fetch.
     */
    where: TenantIncomeWhereUniqueInput
  }

  /**
   * TenantIncome findFirst
   */
  export type TenantIncomeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantIncome
     */
    select?: TenantIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantIncome
     */
    omit?: TenantIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantIncomeInclude<ExtArgs> | null
    /**
     * Filter, which TenantIncome to fetch.
     */
    where?: TenantIncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantIncomes to fetch.
     */
    orderBy?: TenantIncomeOrderByWithRelationInput | TenantIncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantIncomes.
     */
    cursor?: TenantIncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantIncomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantIncomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantIncomes.
     */
    distinct?: TenantIncomeScalarFieldEnum | TenantIncomeScalarFieldEnum[]
  }

  /**
   * TenantIncome findFirstOrThrow
   */
  export type TenantIncomeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantIncome
     */
    select?: TenantIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantIncome
     */
    omit?: TenantIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantIncomeInclude<ExtArgs> | null
    /**
     * Filter, which TenantIncome to fetch.
     */
    where?: TenantIncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantIncomes to fetch.
     */
    orderBy?: TenantIncomeOrderByWithRelationInput | TenantIncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantIncomes.
     */
    cursor?: TenantIncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantIncomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantIncomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantIncomes.
     */
    distinct?: TenantIncomeScalarFieldEnum | TenantIncomeScalarFieldEnum[]
  }

  /**
   * TenantIncome findMany
   */
  export type TenantIncomeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantIncome
     */
    select?: TenantIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantIncome
     */
    omit?: TenantIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantIncomeInclude<ExtArgs> | null
    /**
     * Filter, which TenantIncomes to fetch.
     */
    where?: TenantIncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantIncomes to fetch.
     */
    orderBy?: TenantIncomeOrderByWithRelationInput | TenantIncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TenantIncomes.
     */
    cursor?: TenantIncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantIncomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantIncomes.
     */
    skip?: number
    distinct?: TenantIncomeScalarFieldEnum | TenantIncomeScalarFieldEnum[]
  }

  /**
   * TenantIncome create
   */
  export type TenantIncomeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantIncome
     */
    select?: TenantIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantIncome
     */
    omit?: TenantIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantIncomeInclude<ExtArgs> | null
    /**
     * The data needed to create a TenantIncome.
     */
    data: XOR<TenantIncomeCreateInput, TenantIncomeUncheckedCreateInput>
  }

  /**
   * TenantIncome createMany
   */
  export type TenantIncomeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TenantIncomes.
     */
    data: TenantIncomeCreateManyInput | TenantIncomeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TenantIncome createManyAndReturn
   */
  export type TenantIncomeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantIncome
     */
    select?: TenantIncomeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TenantIncome
     */
    omit?: TenantIncomeOmit<ExtArgs> | null
    /**
     * The data used to create many TenantIncomes.
     */
    data: TenantIncomeCreateManyInput | TenantIncomeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantIncomeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenantIncome update
   */
  export type TenantIncomeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantIncome
     */
    select?: TenantIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantIncome
     */
    omit?: TenantIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantIncomeInclude<ExtArgs> | null
    /**
     * The data needed to update a TenantIncome.
     */
    data: XOR<TenantIncomeUpdateInput, TenantIncomeUncheckedUpdateInput>
    /**
     * Choose, which TenantIncome to update.
     */
    where: TenantIncomeWhereUniqueInput
  }

  /**
   * TenantIncome updateMany
   */
  export type TenantIncomeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TenantIncomes.
     */
    data: XOR<TenantIncomeUpdateManyMutationInput, TenantIncomeUncheckedUpdateManyInput>
    /**
     * Filter which TenantIncomes to update
     */
    where?: TenantIncomeWhereInput
    /**
     * Limit how many TenantIncomes to update.
     */
    limit?: number
  }

  /**
   * TenantIncome updateManyAndReturn
   */
  export type TenantIncomeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantIncome
     */
    select?: TenantIncomeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TenantIncome
     */
    omit?: TenantIncomeOmit<ExtArgs> | null
    /**
     * The data used to update TenantIncomes.
     */
    data: XOR<TenantIncomeUpdateManyMutationInput, TenantIncomeUncheckedUpdateManyInput>
    /**
     * Filter which TenantIncomes to update
     */
    where?: TenantIncomeWhereInput
    /**
     * Limit how many TenantIncomes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantIncomeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenantIncome upsert
   */
  export type TenantIncomeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantIncome
     */
    select?: TenantIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantIncome
     */
    omit?: TenantIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantIncomeInclude<ExtArgs> | null
    /**
     * The filter to search for the TenantIncome to update in case it exists.
     */
    where: TenantIncomeWhereUniqueInput
    /**
     * In case the TenantIncome found by the `where` argument doesn't exist, create a new TenantIncome with this data.
     */
    create: XOR<TenantIncomeCreateInput, TenantIncomeUncheckedCreateInput>
    /**
     * In case the TenantIncome was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantIncomeUpdateInput, TenantIncomeUncheckedUpdateInput>
  }

  /**
   * TenantIncome delete
   */
  export type TenantIncomeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantIncome
     */
    select?: TenantIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantIncome
     */
    omit?: TenantIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantIncomeInclude<ExtArgs> | null
    /**
     * Filter which TenantIncome to delete.
     */
    where: TenantIncomeWhereUniqueInput
  }

  /**
   * TenantIncome deleteMany
   */
  export type TenantIncomeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantIncomes to delete
     */
    where?: TenantIncomeWhereInput
    /**
     * Limit how many TenantIncomes to delete.
     */
    limit?: number
  }

  /**
   * TenantIncome without action
   */
  export type TenantIncomeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantIncome
     */
    select?: TenantIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantIncome
     */
    omit?: TenantIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantIncomeInclude<ExtArgs> | null
  }


  /**
   * Model Landlord
   */

  export type AggregateLandlord = {
    _count: LandlordCountAggregateOutputType | null
    _min: LandlordMinAggregateOutputType | null
    _max: LandlordMaxAggregateOutputType | null
  }

  export type LandlordMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    state: string | null
    zip: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LandlordMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    state: string | null
    zip: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LandlordCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    email: number
    phone: number
    addressLine1: number
    addressLine2: number
    city: number
    state: number
    zip: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LandlordMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    state?: true
    zip?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LandlordMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    state?: true
    zip?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LandlordCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    state?: true
    zip?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LandlordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Landlord to aggregate.
     */
    where?: LandlordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Landlords to fetch.
     */
    orderBy?: LandlordOrderByWithRelationInput | LandlordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LandlordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Landlords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Landlords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Landlords
    **/
    _count?: true | LandlordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LandlordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LandlordMaxAggregateInputType
  }

  export type GetLandlordAggregateType<T extends LandlordAggregateArgs> = {
        [P in keyof T & keyof AggregateLandlord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLandlord[P]>
      : GetScalarType<T[P], AggregateLandlord[P]>
  }




  export type LandlordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LandlordWhereInput
    orderBy?: LandlordOrderByWithAggregationInput | LandlordOrderByWithAggregationInput[]
    by: LandlordScalarFieldEnum[] | LandlordScalarFieldEnum
    having?: LandlordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LandlordCountAggregateInputType | true
    _min?: LandlordMinAggregateInputType
    _max?: LandlordMaxAggregateInputType
  }

  export type LandlordGroupByOutputType = {
    id: string
    firstName: string
    lastName: string
    email: string
    phone: string
    addressLine1: string
    addressLine2: string | null
    city: string
    state: string
    zip: string
    createdAt: Date
    updatedAt: Date
    _count: LandlordCountAggregateOutputType | null
    _min: LandlordMinAggregateOutputType | null
    _max: LandlordMaxAggregateOutputType | null
  }

  type GetLandlordGroupByPayload<T extends LandlordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LandlordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LandlordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LandlordGroupByOutputType[P]>
            : GetScalarType<T[P], LandlordGroupByOutputType[P]>
        }
      >
    >


  export type LandlordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    zip?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | Landlord$propertyArgs<ExtArgs>
    _count?: boolean | LandlordCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["landlord"]>

  export type LandlordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    zip?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["landlord"]>

  export type LandlordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    zip?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["landlord"]>

  export type LandlordSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    zip?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LandlordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "firstName" | "lastName" | "email" | "phone" | "addressLine1" | "addressLine2" | "city" | "state" | "zip" | "createdAt" | "updatedAt", ExtArgs["result"]["landlord"]>
  export type LandlordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | Landlord$propertyArgs<ExtArgs>
    _count?: boolean | LandlordCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LandlordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type LandlordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LandlordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Landlord"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      firstName: string
      lastName: string
      email: string
      phone: string
      addressLine1: string
      addressLine2: string | null
      city: string
      state: string
      zip: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["landlord"]>
    composites: {}
  }

  type LandlordGetPayload<S extends boolean | null | undefined | LandlordDefaultArgs> = $Result.GetResult<Prisma.$LandlordPayload, S>

  type LandlordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LandlordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LandlordCountAggregateInputType | true
    }

  export interface LandlordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Landlord'], meta: { name: 'Landlord' } }
    /**
     * Find zero or one Landlord that matches the filter.
     * @param {LandlordFindUniqueArgs} args - Arguments to find a Landlord
     * @example
     * // Get one Landlord
     * const landlord = await prisma.landlord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LandlordFindUniqueArgs>(args: SelectSubset<T, LandlordFindUniqueArgs<ExtArgs>>): Prisma__LandlordClient<$Result.GetResult<Prisma.$LandlordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Landlord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LandlordFindUniqueOrThrowArgs} args - Arguments to find a Landlord
     * @example
     * // Get one Landlord
     * const landlord = await prisma.landlord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LandlordFindUniqueOrThrowArgs>(args: SelectSubset<T, LandlordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LandlordClient<$Result.GetResult<Prisma.$LandlordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Landlord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandlordFindFirstArgs} args - Arguments to find a Landlord
     * @example
     * // Get one Landlord
     * const landlord = await prisma.landlord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LandlordFindFirstArgs>(args?: SelectSubset<T, LandlordFindFirstArgs<ExtArgs>>): Prisma__LandlordClient<$Result.GetResult<Prisma.$LandlordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Landlord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandlordFindFirstOrThrowArgs} args - Arguments to find a Landlord
     * @example
     * // Get one Landlord
     * const landlord = await prisma.landlord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LandlordFindFirstOrThrowArgs>(args?: SelectSubset<T, LandlordFindFirstOrThrowArgs<ExtArgs>>): Prisma__LandlordClient<$Result.GetResult<Prisma.$LandlordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Landlords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandlordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Landlords
     * const landlords = await prisma.landlord.findMany()
     * 
     * // Get first 10 Landlords
     * const landlords = await prisma.landlord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const landlordWithIdOnly = await prisma.landlord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LandlordFindManyArgs>(args?: SelectSubset<T, LandlordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LandlordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Landlord.
     * @param {LandlordCreateArgs} args - Arguments to create a Landlord.
     * @example
     * // Create one Landlord
     * const Landlord = await prisma.landlord.create({
     *   data: {
     *     // ... data to create a Landlord
     *   }
     * })
     * 
     */
    create<T extends LandlordCreateArgs>(args: SelectSubset<T, LandlordCreateArgs<ExtArgs>>): Prisma__LandlordClient<$Result.GetResult<Prisma.$LandlordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Landlords.
     * @param {LandlordCreateManyArgs} args - Arguments to create many Landlords.
     * @example
     * // Create many Landlords
     * const landlord = await prisma.landlord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LandlordCreateManyArgs>(args?: SelectSubset<T, LandlordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Landlords and returns the data saved in the database.
     * @param {LandlordCreateManyAndReturnArgs} args - Arguments to create many Landlords.
     * @example
     * // Create many Landlords
     * const landlord = await prisma.landlord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Landlords and only return the `id`
     * const landlordWithIdOnly = await prisma.landlord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LandlordCreateManyAndReturnArgs>(args?: SelectSubset<T, LandlordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LandlordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Landlord.
     * @param {LandlordDeleteArgs} args - Arguments to delete one Landlord.
     * @example
     * // Delete one Landlord
     * const Landlord = await prisma.landlord.delete({
     *   where: {
     *     // ... filter to delete one Landlord
     *   }
     * })
     * 
     */
    delete<T extends LandlordDeleteArgs>(args: SelectSubset<T, LandlordDeleteArgs<ExtArgs>>): Prisma__LandlordClient<$Result.GetResult<Prisma.$LandlordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Landlord.
     * @param {LandlordUpdateArgs} args - Arguments to update one Landlord.
     * @example
     * // Update one Landlord
     * const landlord = await prisma.landlord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LandlordUpdateArgs>(args: SelectSubset<T, LandlordUpdateArgs<ExtArgs>>): Prisma__LandlordClient<$Result.GetResult<Prisma.$LandlordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Landlords.
     * @param {LandlordDeleteManyArgs} args - Arguments to filter Landlords to delete.
     * @example
     * // Delete a few Landlords
     * const { count } = await prisma.landlord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LandlordDeleteManyArgs>(args?: SelectSubset<T, LandlordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Landlords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandlordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Landlords
     * const landlord = await prisma.landlord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LandlordUpdateManyArgs>(args: SelectSubset<T, LandlordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Landlords and returns the data updated in the database.
     * @param {LandlordUpdateManyAndReturnArgs} args - Arguments to update many Landlords.
     * @example
     * // Update many Landlords
     * const landlord = await prisma.landlord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Landlords and only return the `id`
     * const landlordWithIdOnly = await prisma.landlord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LandlordUpdateManyAndReturnArgs>(args: SelectSubset<T, LandlordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LandlordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Landlord.
     * @param {LandlordUpsertArgs} args - Arguments to update or create a Landlord.
     * @example
     * // Update or create a Landlord
     * const landlord = await prisma.landlord.upsert({
     *   create: {
     *     // ... data to create a Landlord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Landlord we want to update
     *   }
     * })
     */
    upsert<T extends LandlordUpsertArgs>(args: SelectSubset<T, LandlordUpsertArgs<ExtArgs>>): Prisma__LandlordClient<$Result.GetResult<Prisma.$LandlordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Landlords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandlordCountArgs} args - Arguments to filter Landlords to count.
     * @example
     * // Count the number of Landlords
     * const count = await prisma.landlord.count({
     *   where: {
     *     // ... the filter for the Landlords we want to count
     *   }
     * })
    **/
    count<T extends LandlordCountArgs>(
      args?: Subset<T, LandlordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LandlordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Landlord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandlordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LandlordAggregateArgs>(args: Subset<T, LandlordAggregateArgs>): Prisma.PrismaPromise<GetLandlordAggregateType<T>>

    /**
     * Group by Landlord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandlordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LandlordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LandlordGroupByArgs['orderBy'] }
        : { orderBy?: LandlordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LandlordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLandlordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Landlord model
   */
  readonly fields: LandlordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Landlord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LandlordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends Landlord$propertyArgs<ExtArgs> = {}>(args?: Subset<T, Landlord$propertyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Landlord model
   */
  interface LandlordFieldRefs {
    readonly id: FieldRef<"Landlord", 'String'>
    readonly firstName: FieldRef<"Landlord", 'String'>
    readonly lastName: FieldRef<"Landlord", 'String'>
    readonly email: FieldRef<"Landlord", 'String'>
    readonly phone: FieldRef<"Landlord", 'String'>
    readonly addressLine1: FieldRef<"Landlord", 'String'>
    readonly addressLine2: FieldRef<"Landlord", 'String'>
    readonly city: FieldRef<"Landlord", 'String'>
    readonly state: FieldRef<"Landlord", 'String'>
    readonly zip: FieldRef<"Landlord", 'String'>
    readonly createdAt: FieldRef<"Landlord", 'DateTime'>
    readonly updatedAt: FieldRef<"Landlord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Landlord findUnique
   */
  export type LandlordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Landlord
     */
    select?: LandlordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Landlord
     */
    omit?: LandlordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandlordInclude<ExtArgs> | null
    /**
     * Filter, which Landlord to fetch.
     */
    where: LandlordWhereUniqueInput
  }

  /**
   * Landlord findUniqueOrThrow
   */
  export type LandlordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Landlord
     */
    select?: LandlordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Landlord
     */
    omit?: LandlordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandlordInclude<ExtArgs> | null
    /**
     * Filter, which Landlord to fetch.
     */
    where: LandlordWhereUniqueInput
  }

  /**
   * Landlord findFirst
   */
  export type LandlordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Landlord
     */
    select?: LandlordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Landlord
     */
    omit?: LandlordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandlordInclude<ExtArgs> | null
    /**
     * Filter, which Landlord to fetch.
     */
    where?: LandlordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Landlords to fetch.
     */
    orderBy?: LandlordOrderByWithRelationInput | LandlordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Landlords.
     */
    cursor?: LandlordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Landlords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Landlords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Landlords.
     */
    distinct?: LandlordScalarFieldEnum | LandlordScalarFieldEnum[]
  }

  /**
   * Landlord findFirstOrThrow
   */
  export type LandlordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Landlord
     */
    select?: LandlordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Landlord
     */
    omit?: LandlordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandlordInclude<ExtArgs> | null
    /**
     * Filter, which Landlord to fetch.
     */
    where?: LandlordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Landlords to fetch.
     */
    orderBy?: LandlordOrderByWithRelationInput | LandlordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Landlords.
     */
    cursor?: LandlordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Landlords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Landlords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Landlords.
     */
    distinct?: LandlordScalarFieldEnum | LandlordScalarFieldEnum[]
  }

  /**
   * Landlord findMany
   */
  export type LandlordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Landlord
     */
    select?: LandlordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Landlord
     */
    omit?: LandlordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandlordInclude<ExtArgs> | null
    /**
     * Filter, which Landlords to fetch.
     */
    where?: LandlordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Landlords to fetch.
     */
    orderBy?: LandlordOrderByWithRelationInput | LandlordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Landlords.
     */
    cursor?: LandlordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Landlords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Landlords.
     */
    skip?: number
    distinct?: LandlordScalarFieldEnum | LandlordScalarFieldEnum[]
  }

  /**
   * Landlord create
   */
  export type LandlordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Landlord
     */
    select?: LandlordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Landlord
     */
    omit?: LandlordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandlordInclude<ExtArgs> | null
    /**
     * The data needed to create a Landlord.
     */
    data: XOR<LandlordCreateInput, LandlordUncheckedCreateInput>
  }

  /**
   * Landlord createMany
   */
  export type LandlordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Landlords.
     */
    data: LandlordCreateManyInput | LandlordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Landlord createManyAndReturn
   */
  export type LandlordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Landlord
     */
    select?: LandlordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Landlord
     */
    omit?: LandlordOmit<ExtArgs> | null
    /**
     * The data used to create many Landlords.
     */
    data: LandlordCreateManyInput | LandlordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Landlord update
   */
  export type LandlordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Landlord
     */
    select?: LandlordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Landlord
     */
    omit?: LandlordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandlordInclude<ExtArgs> | null
    /**
     * The data needed to update a Landlord.
     */
    data: XOR<LandlordUpdateInput, LandlordUncheckedUpdateInput>
    /**
     * Choose, which Landlord to update.
     */
    where: LandlordWhereUniqueInput
  }

  /**
   * Landlord updateMany
   */
  export type LandlordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Landlords.
     */
    data: XOR<LandlordUpdateManyMutationInput, LandlordUncheckedUpdateManyInput>
    /**
     * Filter which Landlords to update
     */
    where?: LandlordWhereInput
    /**
     * Limit how many Landlords to update.
     */
    limit?: number
  }

  /**
   * Landlord updateManyAndReturn
   */
  export type LandlordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Landlord
     */
    select?: LandlordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Landlord
     */
    omit?: LandlordOmit<ExtArgs> | null
    /**
     * The data used to update Landlords.
     */
    data: XOR<LandlordUpdateManyMutationInput, LandlordUncheckedUpdateManyInput>
    /**
     * Filter which Landlords to update
     */
    where?: LandlordWhereInput
    /**
     * Limit how many Landlords to update.
     */
    limit?: number
  }

  /**
   * Landlord upsert
   */
  export type LandlordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Landlord
     */
    select?: LandlordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Landlord
     */
    omit?: LandlordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandlordInclude<ExtArgs> | null
    /**
     * The filter to search for the Landlord to update in case it exists.
     */
    where: LandlordWhereUniqueInput
    /**
     * In case the Landlord found by the `where` argument doesn't exist, create a new Landlord with this data.
     */
    create: XOR<LandlordCreateInput, LandlordUncheckedCreateInput>
    /**
     * In case the Landlord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LandlordUpdateInput, LandlordUncheckedUpdateInput>
  }

  /**
   * Landlord delete
   */
  export type LandlordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Landlord
     */
    select?: LandlordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Landlord
     */
    omit?: LandlordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandlordInclude<ExtArgs> | null
    /**
     * Filter which Landlord to delete.
     */
    where: LandlordWhereUniqueInput
  }

  /**
   * Landlord deleteMany
   */
  export type LandlordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Landlords to delete
     */
    where?: LandlordWhereInput
    /**
     * Limit how many Landlords to delete.
     */
    limit?: number
  }

  /**
   * Landlord.property
   */
  export type Landlord$propertyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    where?: PropertyWhereInput
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    cursor?: PropertyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * Landlord without action
   */
  export type LandlordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Landlord
     */
    select?: LandlordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Landlord
     */
    omit?: LandlordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandlordInclude<ExtArgs> | null
  }


  /**
   * Model Property
   */

  export type AggregateProperty = {
    _count: PropertyCountAggregateOutputType | null
    _avg: PropertyAvgAggregateOutputType | null
    _sum: PropertySumAggregateOutputType | null
    _min: PropertyMinAggregateOutputType | null
    _max: PropertyMaxAggregateOutputType | null
  }

  export type PropertyAvgAggregateOutputType = {
    bedrooms: number | null
    bathrooms: number | null
    squareMeters: number | null
    marketRent: number | null
    deposit: number | null
    leaseTerm: number | null
    sqmt: number | null
  }

  export type PropertySumAggregateOutputType = {
    bedrooms: number | null
    bathrooms: number | null
    squareMeters: number | null
    marketRent: number | null
    deposit: number | null
    leaseTerm: number | null
    sqmt: number | null
  }

  export type PropertyMinAggregateOutputType = {
    id: string | null
    name: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    state: string | null
    zip: string | null
    countryCode: string | null
    ownerId: string | null
    imageUrl: string | null
    propertyType: $Enums.PropertyType | null
    propertyStatus: $Enums.PropertyStatus | null
    bedrooms: number | null
    bathrooms: number | null
    squareMeters: number | null
    marketRent: number | null
    deposit: number | null
    leaseTerm: number | null
    leaseTermType: $Enums.LeaseTermType | null
    createdAt: Date | null
    updatedAt: Date | null
    sqmt: number | null
    test: string | null
  }

  export type PropertyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    state: string | null
    zip: string | null
    countryCode: string | null
    ownerId: string | null
    imageUrl: string | null
    propertyType: $Enums.PropertyType | null
    propertyStatus: $Enums.PropertyStatus | null
    bedrooms: number | null
    bathrooms: number | null
    squareMeters: number | null
    marketRent: number | null
    deposit: number | null
    leaseTerm: number | null
    leaseTermType: $Enums.LeaseTermType | null
    createdAt: Date | null
    updatedAt: Date | null
    sqmt: number | null
    test: string | null
  }

  export type PropertyCountAggregateOutputType = {
    id: number
    name: number
    addressLine1: number
    addressLine2: number
    city: number
    state: number
    zip: number
    countryCode: number
    ownerId: number
    imageUrl: number
    propertyType: number
    propertyStatus: number
    bedrooms: number
    bathrooms: number
    squareMeters: number
    marketRent: number
    deposit: number
    leaseTerm: number
    leaseTermType: number
    createdAt: number
    updatedAt: number
    sqmt: number
    features: number
    amenities: number
    test: number
    _all: number
  }


  export type PropertyAvgAggregateInputType = {
    bedrooms?: true
    bathrooms?: true
    squareMeters?: true
    marketRent?: true
    deposit?: true
    leaseTerm?: true
    sqmt?: true
  }

  export type PropertySumAggregateInputType = {
    bedrooms?: true
    bathrooms?: true
    squareMeters?: true
    marketRent?: true
    deposit?: true
    leaseTerm?: true
    sqmt?: true
  }

  export type PropertyMinAggregateInputType = {
    id?: true
    name?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    state?: true
    zip?: true
    countryCode?: true
    ownerId?: true
    imageUrl?: true
    propertyType?: true
    propertyStatus?: true
    bedrooms?: true
    bathrooms?: true
    squareMeters?: true
    marketRent?: true
    deposit?: true
    leaseTerm?: true
    leaseTermType?: true
    createdAt?: true
    updatedAt?: true
    sqmt?: true
    test?: true
  }

  export type PropertyMaxAggregateInputType = {
    id?: true
    name?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    state?: true
    zip?: true
    countryCode?: true
    ownerId?: true
    imageUrl?: true
    propertyType?: true
    propertyStatus?: true
    bedrooms?: true
    bathrooms?: true
    squareMeters?: true
    marketRent?: true
    deposit?: true
    leaseTerm?: true
    leaseTermType?: true
    createdAt?: true
    updatedAt?: true
    sqmt?: true
    test?: true
  }

  export type PropertyCountAggregateInputType = {
    id?: true
    name?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    state?: true
    zip?: true
    countryCode?: true
    ownerId?: true
    imageUrl?: true
    propertyType?: true
    propertyStatus?: true
    bedrooms?: true
    bathrooms?: true
    squareMeters?: true
    marketRent?: true
    deposit?: true
    leaseTerm?: true
    leaseTermType?: true
    createdAt?: true
    updatedAt?: true
    sqmt?: true
    features?: true
    amenities?: true
    test?: true
    _all?: true
  }

  export type PropertyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Property to aggregate.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Properties
    **/
    _count?: true | PropertyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PropertyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PropertySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyMaxAggregateInputType
  }

  export type GetPropertyAggregateType<T extends PropertyAggregateArgs> = {
        [P in keyof T & keyof AggregateProperty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProperty[P]>
      : GetScalarType<T[P], AggregateProperty[P]>
  }




  export type PropertyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyWhereInput
    orderBy?: PropertyOrderByWithAggregationInput | PropertyOrderByWithAggregationInput[]
    by: PropertyScalarFieldEnum[] | PropertyScalarFieldEnum
    having?: PropertyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyCountAggregateInputType | true
    _avg?: PropertyAvgAggregateInputType
    _sum?: PropertySumAggregateInputType
    _min?: PropertyMinAggregateInputType
    _max?: PropertyMaxAggregateInputType
  }

  export type PropertyGroupByOutputType = {
    id: string
    name: string
    addressLine1: string
    addressLine2: string | null
    city: string
    state: string
    zip: string
    countryCode: string
    ownerId: string
    imageUrl: string | null
    propertyType: $Enums.PropertyType
    propertyStatus: $Enums.PropertyStatus
    bedrooms: number
    bathrooms: number
    squareMeters: number
    marketRent: number
    deposit: number
    leaseTerm: number
    leaseTermType: $Enums.LeaseTermType
    createdAt: Date
    updatedAt: Date
    sqmt: number
    features: string[]
    amenities: string[]
    test: string | null
    _count: PropertyCountAggregateOutputType | null
    _avg: PropertyAvgAggregateOutputType | null
    _sum: PropertySumAggregateOutputType | null
    _min: PropertyMinAggregateOutputType | null
    _max: PropertyMaxAggregateOutputType | null
  }

  type GetPropertyGroupByPayload<T extends PropertyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyGroupByOutputType[P]>
        }
      >
    >


  export type PropertySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    zip?: boolean
    countryCode?: boolean
    ownerId?: boolean
    imageUrl?: boolean
    propertyType?: boolean
    propertyStatus?: boolean
    bedrooms?: boolean
    bathrooms?: boolean
    squareMeters?: boolean
    marketRent?: boolean
    deposit?: boolean
    leaseTerm?: boolean
    leaseTermType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sqmt?: boolean
    features?: boolean
    amenities?: boolean
    test?: boolean
    owner?: boolean | LandlordDefaultArgs<ExtArgs>
    unit?: boolean | Property$unitArgs<ExtArgs>
    propertyDocument?: boolean | Property$propertyDocumentArgs<ExtArgs>
    Lease?: boolean | Property$LeaseArgs<ExtArgs>
    _count?: boolean | PropertyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["property"]>

  export type PropertySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    zip?: boolean
    countryCode?: boolean
    ownerId?: boolean
    imageUrl?: boolean
    propertyType?: boolean
    propertyStatus?: boolean
    bedrooms?: boolean
    bathrooms?: boolean
    squareMeters?: boolean
    marketRent?: boolean
    deposit?: boolean
    leaseTerm?: boolean
    leaseTermType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sqmt?: boolean
    features?: boolean
    amenities?: boolean
    test?: boolean
    owner?: boolean | LandlordDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["property"]>

  export type PropertySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    zip?: boolean
    countryCode?: boolean
    ownerId?: boolean
    imageUrl?: boolean
    propertyType?: boolean
    propertyStatus?: boolean
    bedrooms?: boolean
    bathrooms?: boolean
    squareMeters?: boolean
    marketRent?: boolean
    deposit?: boolean
    leaseTerm?: boolean
    leaseTermType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sqmt?: boolean
    features?: boolean
    amenities?: boolean
    test?: boolean
    owner?: boolean | LandlordDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["property"]>

  export type PropertySelectScalar = {
    id?: boolean
    name?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    zip?: boolean
    countryCode?: boolean
    ownerId?: boolean
    imageUrl?: boolean
    propertyType?: boolean
    propertyStatus?: boolean
    bedrooms?: boolean
    bathrooms?: boolean
    squareMeters?: boolean
    marketRent?: boolean
    deposit?: boolean
    leaseTerm?: boolean
    leaseTermType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sqmt?: boolean
    features?: boolean
    amenities?: boolean
    test?: boolean
  }

  export type PropertyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "addressLine1" | "addressLine2" | "city" | "state" | "zip" | "countryCode" | "ownerId" | "imageUrl" | "propertyType" | "propertyStatus" | "bedrooms" | "bathrooms" | "squareMeters" | "marketRent" | "deposit" | "leaseTerm" | "leaseTermType" | "createdAt" | "updatedAt" | "sqmt" | "features" | "amenities" | "test", ExtArgs["result"]["property"]>
  export type PropertyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | LandlordDefaultArgs<ExtArgs>
    unit?: boolean | Property$unitArgs<ExtArgs>
    propertyDocument?: boolean | Property$propertyDocumentArgs<ExtArgs>
    Lease?: boolean | Property$LeaseArgs<ExtArgs>
    _count?: boolean | PropertyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PropertyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | LandlordDefaultArgs<ExtArgs>
  }
  export type PropertyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | LandlordDefaultArgs<ExtArgs>
  }

  export type $PropertyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Property"
    objects: {
      owner: Prisma.$LandlordPayload<ExtArgs>
      unit: Prisma.$UnitPayload<ExtArgs>[]
      propertyDocument: Prisma.$PropertyDocumentPayload<ExtArgs>[]
      Lease: Prisma.$LeasePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      addressLine1: string
      addressLine2: string | null
      city: string
      state: string
      zip: string
      countryCode: string
      ownerId: string
      imageUrl: string | null
      propertyType: $Enums.PropertyType
      propertyStatus: $Enums.PropertyStatus
      bedrooms: number
      bathrooms: number
      squareMeters: number
      marketRent: number
      deposit: number
      leaseTerm: number
      leaseTermType: $Enums.LeaseTermType
      createdAt: Date
      updatedAt: Date
      sqmt: number
      features: string[]
      amenities: string[]
      test: string | null
    }, ExtArgs["result"]["property"]>
    composites: {}
  }

  type PropertyGetPayload<S extends boolean | null | undefined | PropertyDefaultArgs> = $Result.GetResult<Prisma.$PropertyPayload, S>

  type PropertyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PropertyCountAggregateInputType | true
    }

  export interface PropertyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Property'], meta: { name: 'Property' } }
    /**
     * Find zero or one Property that matches the filter.
     * @param {PropertyFindUniqueArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyFindUniqueArgs>(args: SelectSubset<T, PropertyFindUniqueArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Property that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyFindUniqueOrThrowArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Property that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindFirstArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyFindFirstArgs>(args?: SelectSubset<T, PropertyFindFirstArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Property that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindFirstOrThrowArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Properties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Properties
     * const properties = await prisma.property.findMany()
     * 
     * // Get first 10 Properties
     * const properties = await prisma.property.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyWithIdOnly = await prisma.property.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyFindManyArgs>(args?: SelectSubset<T, PropertyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Property.
     * @param {PropertyCreateArgs} args - Arguments to create a Property.
     * @example
     * // Create one Property
     * const Property = await prisma.property.create({
     *   data: {
     *     // ... data to create a Property
     *   }
     * })
     * 
     */
    create<T extends PropertyCreateArgs>(args: SelectSubset<T, PropertyCreateArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Properties.
     * @param {PropertyCreateManyArgs} args - Arguments to create many Properties.
     * @example
     * // Create many Properties
     * const property = await prisma.property.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyCreateManyArgs>(args?: SelectSubset<T, PropertyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Properties and returns the data saved in the database.
     * @param {PropertyCreateManyAndReturnArgs} args - Arguments to create many Properties.
     * @example
     * // Create many Properties
     * const property = await prisma.property.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Properties and only return the `id`
     * const propertyWithIdOnly = await prisma.property.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Property.
     * @param {PropertyDeleteArgs} args - Arguments to delete one Property.
     * @example
     * // Delete one Property
     * const Property = await prisma.property.delete({
     *   where: {
     *     // ... filter to delete one Property
     *   }
     * })
     * 
     */
    delete<T extends PropertyDeleteArgs>(args: SelectSubset<T, PropertyDeleteArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Property.
     * @param {PropertyUpdateArgs} args - Arguments to update one Property.
     * @example
     * // Update one Property
     * const property = await prisma.property.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyUpdateArgs>(args: SelectSubset<T, PropertyUpdateArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Properties.
     * @param {PropertyDeleteManyArgs} args - Arguments to filter Properties to delete.
     * @example
     * // Delete a few Properties
     * const { count } = await prisma.property.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyDeleteManyArgs>(args?: SelectSubset<T, PropertyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Properties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Properties
     * const property = await prisma.property.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyUpdateManyArgs>(args: SelectSubset<T, PropertyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Properties and returns the data updated in the database.
     * @param {PropertyUpdateManyAndReturnArgs} args - Arguments to update many Properties.
     * @example
     * // Update many Properties
     * const property = await prisma.property.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Properties and only return the `id`
     * const propertyWithIdOnly = await prisma.property.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertyUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Property.
     * @param {PropertyUpsertArgs} args - Arguments to update or create a Property.
     * @example
     * // Update or create a Property
     * const property = await prisma.property.upsert({
     *   create: {
     *     // ... data to create a Property
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Property we want to update
     *   }
     * })
     */
    upsert<T extends PropertyUpsertArgs>(args: SelectSubset<T, PropertyUpsertArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Properties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyCountArgs} args - Arguments to filter Properties to count.
     * @example
     * // Count the number of Properties
     * const count = await prisma.property.count({
     *   where: {
     *     // ... the filter for the Properties we want to count
     *   }
     * })
    **/
    count<T extends PropertyCountArgs>(
      args?: Subset<T, PropertyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Property.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyAggregateArgs>(args: Subset<T, PropertyAggregateArgs>): Prisma.PrismaPromise<GetPropertyAggregateType<T>>

    /**
     * Group by Property.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyGroupByArgs['orderBy'] }
        : { orderBy?: PropertyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Property model
   */
  readonly fields: PropertyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Property.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends LandlordDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LandlordDefaultArgs<ExtArgs>>): Prisma__LandlordClient<$Result.GetResult<Prisma.$LandlordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    unit<T extends Property$unitArgs<ExtArgs> = {}>(args?: Subset<T, Property$unitArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    propertyDocument<T extends Property$propertyDocumentArgs<ExtArgs> = {}>(args?: Subset<T, Property$propertyDocumentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Lease<T extends Property$LeaseArgs<ExtArgs> = {}>(args?: Subset<T, Property$LeaseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Property model
   */
  interface PropertyFieldRefs {
    readonly id: FieldRef<"Property", 'String'>
    readonly name: FieldRef<"Property", 'String'>
    readonly addressLine1: FieldRef<"Property", 'String'>
    readonly addressLine2: FieldRef<"Property", 'String'>
    readonly city: FieldRef<"Property", 'String'>
    readonly state: FieldRef<"Property", 'String'>
    readonly zip: FieldRef<"Property", 'String'>
    readonly countryCode: FieldRef<"Property", 'String'>
    readonly ownerId: FieldRef<"Property", 'String'>
    readonly imageUrl: FieldRef<"Property", 'String'>
    readonly propertyType: FieldRef<"Property", 'PropertyType'>
    readonly propertyStatus: FieldRef<"Property", 'PropertyStatus'>
    readonly bedrooms: FieldRef<"Property", 'Int'>
    readonly bathrooms: FieldRef<"Property", 'Float'>
    readonly squareMeters: FieldRef<"Property", 'Float'>
    readonly marketRent: FieldRef<"Property", 'Float'>
    readonly deposit: FieldRef<"Property", 'Float'>
    readonly leaseTerm: FieldRef<"Property", 'Int'>
    readonly leaseTermType: FieldRef<"Property", 'LeaseTermType'>
    readonly createdAt: FieldRef<"Property", 'DateTime'>
    readonly updatedAt: FieldRef<"Property", 'DateTime'>
    readonly sqmt: FieldRef<"Property", 'Float'>
    readonly features: FieldRef<"Property", 'String[]'>
    readonly amenities: FieldRef<"Property", 'String[]'>
    readonly test: FieldRef<"Property", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Property findUnique
   */
  export type PropertyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property findUniqueOrThrow
   */
  export type PropertyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property findFirst
   */
  export type PropertyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Properties.
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Properties.
     */
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * Property findFirstOrThrow
   */
  export type PropertyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Properties.
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Properties.
     */
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * Property findMany
   */
  export type PropertyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Properties to fetch.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Properties.
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * Property create
   */
  export type PropertyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * The data needed to create a Property.
     */
    data: XOR<PropertyCreateInput, PropertyUncheckedCreateInput>
  }

  /**
   * Property createMany
   */
  export type PropertyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Properties.
     */
    data: PropertyCreateManyInput | PropertyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Property createManyAndReturn
   */
  export type PropertyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * The data used to create many Properties.
     */
    data: PropertyCreateManyInput | PropertyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Property update
   */
  export type PropertyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * The data needed to update a Property.
     */
    data: XOR<PropertyUpdateInput, PropertyUncheckedUpdateInput>
    /**
     * Choose, which Property to update.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property updateMany
   */
  export type PropertyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Properties.
     */
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyInput>
    /**
     * Filter which Properties to update
     */
    where?: PropertyWhereInput
    /**
     * Limit how many Properties to update.
     */
    limit?: number
  }

  /**
   * Property updateManyAndReturn
   */
  export type PropertyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * The data used to update Properties.
     */
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyInput>
    /**
     * Filter which Properties to update
     */
    where?: PropertyWhereInput
    /**
     * Limit how many Properties to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Property upsert
   */
  export type PropertyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * The filter to search for the Property to update in case it exists.
     */
    where: PropertyWhereUniqueInput
    /**
     * In case the Property found by the `where` argument doesn't exist, create a new Property with this data.
     */
    create: XOR<PropertyCreateInput, PropertyUncheckedCreateInput>
    /**
     * In case the Property was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyUpdateInput, PropertyUncheckedUpdateInput>
  }

  /**
   * Property delete
   */
  export type PropertyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter which Property to delete.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property deleteMany
   */
  export type PropertyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Properties to delete
     */
    where?: PropertyWhereInput
    /**
     * Limit how many Properties to delete.
     */
    limit?: number
  }

  /**
   * Property.unit
   */
  export type Property$unitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    where?: UnitWhereInput
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    cursor?: UnitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Property.propertyDocument
   */
  export type Property$propertyDocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyDocument
     */
    select?: PropertyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyDocument
     */
    omit?: PropertyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyDocumentInclude<ExtArgs> | null
    where?: PropertyDocumentWhereInput
    orderBy?: PropertyDocumentOrderByWithRelationInput | PropertyDocumentOrderByWithRelationInput[]
    cursor?: PropertyDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyDocumentScalarFieldEnum | PropertyDocumentScalarFieldEnum[]
  }

  /**
   * Property.Lease
   */
  export type Property$LeaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseInclude<ExtArgs> | null
    where?: LeaseWhereInput
    orderBy?: LeaseOrderByWithRelationInput | LeaseOrderByWithRelationInput[]
    cursor?: LeaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaseScalarFieldEnum | LeaseScalarFieldEnum[]
  }

  /**
   * Property without action
   */
  export type PropertyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
  }


  /**
   * Model Unit
   */

  export type AggregateUnit = {
    _count: UnitCountAggregateOutputType | null
    _avg: UnitAvgAggregateOutputType | null
    _sum: UnitSumAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  export type UnitAvgAggregateOutputType = {
    bedrooms: number | null
    bathrooms: number | null
    sqmt: number | null
    marketRent: number | null
    deposit: number | null
  }

  export type UnitSumAggregateOutputType = {
    bedrooms: number | null
    bathrooms: number | null
    sqmt: number | null
    marketRent: number | null
    deposit: number | null
  }

  export type UnitMinAggregateOutputType = {
    id: string | null
    propertyId: string | null
    name: string | null
    bedrooms: number | null
    bathrooms: number | null
    sqmt: number | null
    marketRent: number | null
    deposit: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnitMaxAggregateOutputType = {
    id: string | null
    propertyId: string | null
    name: string | null
    bedrooms: number | null
    bathrooms: number | null
    sqmt: number | null
    marketRent: number | null
    deposit: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnitCountAggregateOutputType = {
    id: number
    propertyId: number
    name: number
    bedrooms: number
    bathrooms: number
    sqmt: number
    marketRent: number
    deposit: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UnitAvgAggregateInputType = {
    bedrooms?: true
    bathrooms?: true
    sqmt?: true
    marketRent?: true
    deposit?: true
  }

  export type UnitSumAggregateInputType = {
    bedrooms?: true
    bathrooms?: true
    sqmt?: true
    marketRent?: true
    deposit?: true
  }

  export type UnitMinAggregateInputType = {
    id?: true
    propertyId?: true
    name?: true
    bedrooms?: true
    bathrooms?: true
    sqmt?: true
    marketRent?: true
    deposit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnitMaxAggregateInputType = {
    id?: true
    propertyId?: true
    name?: true
    bedrooms?: true
    bathrooms?: true
    sqmt?: true
    marketRent?: true
    deposit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnitCountAggregateInputType = {
    id?: true
    propertyId?: true
    name?: true
    bedrooms?: true
    bathrooms?: true
    sqmt?: true
    marketRent?: true
    deposit?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UnitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Unit to aggregate.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Units
    **/
    _count?: true | UnitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitMaxAggregateInputType
  }

  export type GetUnitAggregateType<T extends UnitAggregateArgs> = {
        [P in keyof T & keyof AggregateUnit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnit[P]>
      : GetScalarType<T[P], AggregateUnit[P]>
  }




  export type UnitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitWhereInput
    orderBy?: UnitOrderByWithAggregationInput | UnitOrderByWithAggregationInput[]
    by: UnitScalarFieldEnum[] | UnitScalarFieldEnum
    having?: UnitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitCountAggregateInputType | true
    _avg?: UnitAvgAggregateInputType
    _sum?: UnitSumAggregateInputType
    _min?: UnitMinAggregateInputType
    _max?: UnitMaxAggregateInputType
  }

  export type UnitGroupByOutputType = {
    id: string
    propertyId: string
    name: string
    bedrooms: number
    bathrooms: number
    sqmt: number
    marketRent: number
    deposit: number
    createdAt: Date
    updatedAt: Date
    _count: UnitCountAggregateOutputType | null
    _avg: UnitAvgAggregateOutputType | null
    _sum: UnitSumAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  type GetUnitGroupByPayload<T extends UnitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitGroupByOutputType[P]>
            : GetScalarType<T[P], UnitGroupByOutputType[P]>
        }
      >
    >


  export type UnitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    name?: boolean
    bedrooms?: boolean
    bathrooms?: boolean
    sqmt?: boolean
    marketRent?: boolean
    deposit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Property?: boolean | PropertyDefaultArgs<ExtArgs>
    lease?: boolean | Unit$leaseArgs<ExtArgs>
    _count?: boolean | UnitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unit"]>

  export type UnitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    name?: boolean
    bedrooms?: boolean
    bathrooms?: boolean
    sqmt?: boolean
    marketRent?: boolean
    deposit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unit"]>

  export type UnitSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    name?: boolean
    bedrooms?: boolean
    bathrooms?: boolean
    sqmt?: boolean
    marketRent?: boolean
    deposit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unit"]>

  export type UnitSelectScalar = {
    id?: boolean
    propertyId?: boolean
    name?: boolean
    bedrooms?: boolean
    bathrooms?: boolean
    sqmt?: boolean
    marketRent?: boolean
    deposit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UnitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "propertyId" | "name" | "bedrooms" | "bathrooms" | "sqmt" | "marketRent" | "deposit" | "createdAt" | "updatedAt", ExtArgs["result"]["unit"]>
  export type UnitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Property?: boolean | PropertyDefaultArgs<ExtArgs>
    lease?: boolean | Unit$leaseArgs<ExtArgs>
    _count?: boolean | UnitCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UnitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type UnitIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Property?: boolean | PropertyDefaultArgs<ExtArgs>
  }

  export type $UnitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Unit"
    objects: {
      Property: Prisma.$PropertyPayload<ExtArgs>
      lease: Prisma.$LeasePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      propertyId: string
      name: string
      bedrooms: number
      bathrooms: number
      sqmt: number
      marketRent: number
      deposit: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["unit"]>
    composites: {}
  }

  type UnitGetPayload<S extends boolean | null | undefined | UnitDefaultArgs> = $Result.GetResult<Prisma.$UnitPayload, S>

  type UnitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UnitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UnitCountAggregateInputType | true
    }

  export interface UnitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Unit'], meta: { name: 'Unit' } }
    /**
     * Find zero or one Unit that matches the filter.
     * @param {UnitFindUniqueArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitFindUniqueArgs>(args: SelectSubset<T, UnitFindUniqueArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Unit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UnitFindUniqueOrThrowArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Unit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindFirstArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitFindFirstArgs>(args?: SelectSubset<T, UnitFindFirstArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Unit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindFirstOrThrowArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Units that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Units
     * const units = await prisma.unit.findMany()
     * 
     * // Get first 10 Units
     * const units = await prisma.unit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitWithIdOnly = await prisma.unit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnitFindManyArgs>(args?: SelectSubset<T, UnitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Unit.
     * @param {UnitCreateArgs} args - Arguments to create a Unit.
     * @example
     * // Create one Unit
     * const Unit = await prisma.unit.create({
     *   data: {
     *     // ... data to create a Unit
     *   }
     * })
     * 
     */
    create<T extends UnitCreateArgs>(args: SelectSubset<T, UnitCreateArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Units.
     * @param {UnitCreateManyArgs} args - Arguments to create many Units.
     * @example
     * // Create many Units
     * const unit = await prisma.unit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitCreateManyArgs>(args?: SelectSubset<T, UnitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Units and returns the data saved in the database.
     * @param {UnitCreateManyAndReturnArgs} args - Arguments to create many Units.
     * @example
     * // Create many Units
     * const unit = await prisma.unit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Units and only return the `id`
     * const unitWithIdOnly = await prisma.unit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UnitCreateManyAndReturnArgs>(args?: SelectSubset<T, UnitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Unit.
     * @param {UnitDeleteArgs} args - Arguments to delete one Unit.
     * @example
     * // Delete one Unit
     * const Unit = await prisma.unit.delete({
     *   where: {
     *     // ... filter to delete one Unit
     *   }
     * })
     * 
     */
    delete<T extends UnitDeleteArgs>(args: SelectSubset<T, UnitDeleteArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Unit.
     * @param {UnitUpdateArgs} args - Arguments to update one Unit.
     * @example
     * // Update one Unit
     * const unit = await prisma.unit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitUpdateArgs>(args: SelectSubset<T, UnitUpdateArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Units.
     * @param {UnitDeleteManyArgs} args - Arguments to filter Units to delete.
     * @example
     * // Delete a few Units
     * const { count } = await prisma.unit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitDeleteManyArgs>(args?: SelectSubset<T, UnitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Units
     * const unit = await prisma.unit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitUpdateManyArgs>(args: SelectSubset<T, UnitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Units and returns the data updated in the database.
     * @param {UnitUpdateManyAndReturnArgs} args - Arguments to update many Units.
     * @example
     * // Update many Units
     * const unit = await prisma.unit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Units and only return the `id`
     * const unitWithIdOnly = await prisma.unit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UnitUpdateManyAndReturnArgs>(args: SelectSubset<T, UnitUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Unit.
     * @param {UnitUpsertArgs} args - Arguments to update or create a Unit.
     * @example
     * // Update or create a Unit
     * const unit = await prisma.unit.upsert({
     *   create: {
     *     // ... data to create a Unit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Unit we want to update
     *   }
     * })
     */
    upsert<T extends UnitUpsertArgs>(args: SelectSubset<T, UnitUpsertArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitCountArgs} args - Arguments to filter Units to count.
     * @example
     * // Count the number of Units
     * const count = await prisma.unit.count({
     *   where: {
     *     // ... the filter for the Units we want to count
     *   }
     * })
    **/
    count<T extends UnitCountArgs>(
      args?: Subset<T, UnitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitAggregateArgs>(args: Subset<T, UnitAggregateArgs>): Prisma.PrismaPromise<GetUnitAggregateType<T>>

    /**
     * Group by Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitGroupByArgs['orderBy'] }
        : { orderBy?: UnitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Unit model
   */
  readonly fields: UnitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Unit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lease<T extends Unit$leaseArgs<ExtArgs> = {}>(args?: Subset<T, Unit$leaseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Unit model
   */
  interface UnitFieldRefs {
    readonly id: FieldRef<"Unit", 'String'>
    readonly propertyId: FieldRef<"Unit", 'String'>
    readonly name: FieldRef<"Unit", 'String'>
    readonly bedrooms: FieldRef<"Unit", 'Int'>
    readonly bathrooms: FieldRef<"Unit", 'Float'>
    readonly sqmt: FieldRef<"Unit", 'Float'>
    readonly marketRent: FieldRef<"Unit", 'Float'>
    readonly deposit: FieldRef<"Unit", 'Float'>
    readonly createdAt: FieldRef<"Unit", 'DateTime'>
    readonly updatedAt: FieldRef<"Unit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Unit findUnique
   */
  export type UnitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit findUniqueOrThrow
   */
  export type UnitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit findFirst
   */
  export type UnitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit findFirstOrThrow
   */
  export type UnitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit findMany
   */
  export type UnitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Units to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit create
   */
  export type UnitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The data needed to create a Unit.
     */
    data: XOR<UnitCreateInput, UnitUncheckedCreateInput>
  }

  /**
   * Unit createMany
   */
  export type UnitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Units.
     */
    data: UnitCreateManyInput | UnitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Unit createManyAndReturn
   */
  export type UnitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * The data used to create many Units.
     */
    data: UnitCreateManyInput | UnitCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Unit update
   */
  export type UnitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The data needed to update a Unit.
     */
    data: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
    /**
     * Choose, which Unit to update.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit updateMany
   */
  export type UnitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Units.
     */
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyInput>
    /**
     * Filter which Units to update
     */
    where?: UnitWhereInput
    /**
     * Limit how many Units to update.
     */
    limit?: number
  }

  /**
   * Unit updateManyAndReturn
   */
  export type UnitUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * The data used to update Units.
     */
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyInput>
    /**
     * Filter which Units to update
     */
    where?: UnitWhereInput
    /**
     * Limit how many Units to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Unit upsert
   */
  export type UnitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The filter to search for the Unit to update in case it exists.
     */
    where: UnitWhereUniqueInput
    /**
     * In case the Unit found by the `where` argument doesn't exist, create a new Unit with this data.
     */
    create: XOR<UnitCreateInput, UnitUncheckedCreateInput>
    /**
     * In case the Unit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
  }

  /**
   * Unit delete
   */
  export type UnitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter which Unit to delete.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit deleteMany
   */
  export type UnitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Units to delete
     */
    where?: UnitWhereInput
    /**
     * Limit how many Units to delete.
     */
    limit?: number
  }

  /**
   * Unit.lease
   */
  export type Unit$leaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseInclude<ExtArgs> | null
    where?: LeaseWhereInput
    orderBy?: LeaseOrderByWithRelationInput | LeaseOrderByWithRelationInput[]
    cursor?: LeaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaseScalarFieldEnum | LeaseScalarFieldEnum[]
  }

  /**
   * Unit without action
   */
  export type UnitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
  }


  /**
   * Model Lease
   */

  export type AggregateLease = {
    _count: LeaseCountAggregateOutputType | null
    _avg: LeaseAvgAggregateOutputType | null
    _sum: LeaseSumAggregateOutputType | null
    _min: LeaseMinAggregateOutputType | null
    _max: LeaseMaxAggregateOutputType | null
  }

  export type LeaseAvgAggregateOutputType = {
    rent: number | null
    deposit: number | null
  }

  export type LeaseSumAggregateOutputType = {
    rent: number | null
    deposit: number | null
  }

  export type LeaseMinAggregateOutputType = {
    id: string | null
    unitId: string | null
    tenantId: string | null
    startDate: Date | null
    endDate: Date | null
    rent: number | null
    deposit: number | null
    rentDueCurrency: string | null
    status: $Enums.LeaseStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    propertyId: string | null
  }

  export type LeaseMaxAggregateOutputType = {
    id: string | null
    unitId: string | null
    tenantId: string | null
    startDate: Date | null
    endDate: Date | null
    rent: number | null
    deposit: number | null
    rentDueCurrency: string | null
    status: $Enums.LeaseStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    propertyId: string | null
  }

  export type LeaseCountAggregateOutputType = {
    id: number
    unitId: number
    tenantId: number
    startDate: number
    endDate: number
    rent: number
    deposit: number
    rentDueCurrency: number
    status: number
    createdAt: number
    updatedAt: number
    propertyId: number
    _all: number
  }


  export type LeaseAvgAggregateInputType = {
    rent?: true
    deposit?: true
  }

  export type LeaseSumAggregateInputType = {
    rent?: true
    deposit?: true
  }

  export type LeaseMinAggregateInputType = {
    id?: true
    unitId?: true
    tenantId?: true
    startDate?: true
    endDate?: true
    rent?: true
    deposit?: true
    rentDueCurrency?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    propertyId?: true
  }

  export type LeaseMaxAggregateInputType = {
    id?: true
    unitId?: true
    tenantId?: true
    startDate?: true
    endDate?: true
    rent?: true
    deposit?: true
    rentDueCurrency?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    propertyId?: true
  }

  export type LeaseCountAggregateInputType = {
    id?: true
    unitId?: true
    tenantId?: true
    startDate?: true
    endDate?: true
    rent?: true
    deposit?: true
    rentDueCurrency?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    propertyId?: true
    _all?: true
  }

  export type LeaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lease to aggregate.
     */
    where?: LeaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leases to fetch.
     */
    orderBy?: LeaseOrderByWithRelationInput | LeaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Leases
    **/
    _count?: true | LeaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaseMaxAggregateInputType
  }

  export type GetLeaseAggregateType<T extends LeaseAggregateArgs> = {
        [P in keyof T & keyof AggregateLease]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLease[P]>
      : GetScalarType<T[P], AggregateLease[P]>
  }




  export type LeaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaseWhereInput
    orderBy?: LeaseOrderByWithAggregationInput | LeaseOrderByWithAggregationInput[]
    by: LeaseScalarFieldEnum[] | LeaseScalarFieldEnum
    having?: LeaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaseCountAggregateInputType | true
    _avg?: LeaseAvgAggregateInputType
    _sum?: LeaseSumAggregateInputType
    _min?: LeaseMinAggregateInputType
    _max?: LeaseMaxAggregateInputType
  }

  export type LeaseGroupByOutputType = {
    id: string
    unitId: string
    tenantId: string
    startDate: Date
    endDate: Date
    rent: number
    deposit: number
    rentDueCurrency: string
    status: $Enums.LeaseStatus
    createdAt: Date
    updatedAt: Date
    propertyId: string | null
    _count: LeaseCountAggregateOutputType | null
    _avg: LeaseAvgAggregateOutputType | null
    _sum: LeaseSumAggregateOutputType | null
    _min: LeaseMinAggregateOutputType | null
    _max: LeaseMaxAggregateOutputType | null
  }

  type GetLeaseGroupByPayload<T extends LeaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaseGroupByOutputType[P]>
            : GetScalarType<T[P], LeaseGroupByOutputType[P]>
        }
      >
    >


  export type LeaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitId?: boolean
    tenantId?: boolean
    startDate?: boolean
    endDate?: boolean
    rent?: boolean
    deposit?: boolean
    rentDueCurrency?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    propertyId?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    tenantLease?: boolean | Lease$tenantLeaseArgs<ExtArgs>
    property?: boolean | Lease$propertyArgs<ExtArgs>
    invoice?: boolean | Lease$invoiceArgs<ExtArgs>
    transactions?: boolean | Lease$transactionsArgs<ExtArgs>
    maintenanceRequest?: boolean | Lease$maintenanceRequestArgs<ExtArgs>
    leaseDocument?: boolean | Lease$leaseDocumentArgs<ExtArgs>
    _count?: boolean | LeaseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lease"]>

  export type LeaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitId?: boolean
    tenantId?: boolean
    startDate?: boolean
    endDate?: boolean
    rent?: boolean
    deposit?: boolean
    rentDueCurrency?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    propertyId?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    property?: boolean | Lease$propertyArgs<ExtArgs>
  }, ExtArgs["result"]["lease"]>

  export type LeaseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitId?: boolean
    tenantId?: boolean
    startDate?: boolean
    endDate?: boolean
    rent?: boolean
    deposit?: boolean
    rentDueCurrency?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    propertyId?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    property?: boolean | Lease$propertyArgs<ExtArgs>
  }, ExtArgs["result"]["lease"]>

  export type LeaseSelectScalar = {
    id?: boolean
    unitId?: boolean
    tenantId?: boolean
    startDate?: boolean
    endDate?: boolean
    rent?: boolean
    deposit?: boolean
    rentDueCurrency?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    propertyId?: boolean
  }

  export type LeaseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "unitId" | "tenantId" | "startDate" | "endDate" | "rent" | "deposit" | "rentDueCurrency" | "status" | "createdAt" | "updatedAt" | "propertyId", ExtArgs["result"]["lease"]>
  export type LeaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    tenantLease?: boolean | Lease$tenantLeaseArgs<ExtArgs>
    property?: boolean | Lease$propertyArgs<ExtArgs>
    invoice?: boolean | Lease$invoiceArgs<ExtArgs>
    transactions?: boolean | Lease$transactionsArgs<ExtArgs>
    maintenanceRequest?: boolean | Lease$maintenanceRequestArgs<ExtArgs>
    leaseDocument?: boolean | Lease$leaseDocumentArgs<ExtArgs>
    _count?: boolean | LeaseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LeaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    property?: boolean | Lease$propertyArgs<ExtArgs>
  }
  export type LeaseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    property?: boolean | Lease$propertyArgs<ExtArgs>
  }

  export type $LeasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lease"
    objects: {
      unit: Prisma.$UnitPayload<ExtArgs>
      tenant: Prisma.$TenantPayload<ExtArgs>
      tenantLease: Prisma.$TenantLeasePayload<ExtArgs>[]
      property: Prisma.$PropertyPayload<ExtArgs> | null
      invoice: Prisma.$InvoicePayload<ExtArgs>[]
      transactions: Prisma.$TransactionsPayload<ExtArgs>[]
      maintenanceRequest: Prisma.$MaintenanceRequestPayload<ExtArgs>[]
      leaseDocument: Prisma.$LeaseDocumentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      unitId: string
      tenantId: string
      startDate: Date
      endDate: Date
      rent: number
      deposit: number
      rentDueCurrency: string
      status: $Enums.LeaseStatus
      createdAt: Date
      updatedAt: Date
      propertyId: string | null
    }, ExtArgs["result"]["lease"]>
    composites: {}
  }

  type LeaseGetPayload<S extends boolean | null | undefined | LeaseDefaultArgs> = $Result.GetResult<Prisma.$LeasePayload, S>

  type LeaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeaseCountAggregateInputType | true
    }

  export interface LeaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lease'], meta: { name: 'Lease' } }
    /**
     * Find zero or one Lease that matches the filter.
     * @param {LeaseFindUniqueArgs} args - Arguments to find a Lease
     * @example
     * // Get one Lease
     * const lease = await prisma.lease.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeaseFindUniqueArgs>(args: SelectSubset<T, LeaseFindUniqueArgs<ExtArgs>>): Prisma__LeaseClient<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lease that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeaseFindUniqueOrThrowArgs} args - Arguments to find a Lease
     * @example
     * // Get one Lease
     * const lease = await prisma.lease.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeaseFindUniqueOrThrowArgs>(args: SelectSubset<T, LeaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeaseClient<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lease that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaseFindFirstArgs} args - Arguments to find a Lease
     * @example
     * // Get one Lease
     * const lease = await prisma.lease.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeaseFindFirstArgs>(args?: SelectSubset<T, LeaseFindFirstArgs<ExtArgs>>): Prisma__LeaseClient<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lease that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaseFindFirstOrThrowArgs} args - Arguments to find a Lease
     * @example
     * // Get one Lease
     * const lease = await prisma.lease.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeaseFindFirstOrThrowArgs>(args?: SelectSubset<T, LeaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeaseClient<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Leases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leases
     * const leases = await prisma.lease.findMany()
     * 
     * // Get first 10 Leases
     * const leases = await prisma.lease.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaseWithIdOnly = await prisma.lease.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeaseFindManyArgs>(args?: SelectSubset<T, LeaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lease.
     * @param {LeaseCreateArgs} args - Arguments to create a Lease.
     * @example
     * // Create one Lease
     * const Lease = await prisma.lease.create({
     *   data: {
     *     // ... data to create a Lease
     *   }
     * })
     * 
     */
    create<T extends LeaseCreateArgs>(args: SelectSubset<T, LeaseCreateArgs<ExtArgs>>): Prisma__LeaseClient<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Leases.
     * @param {LeaseCreateManyArgs} args - Arguments to create many Leases.
     * @example
     * // Create many Leases
     * const lease = await prisma.lease.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeaseCreateManyArgs>(args?: SelectSubset<T, LeaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Leases and returns the data saved in the database.
     * @param {LeaseCreateManyAndReturnArgs} args - Arguments to create many Leases.
     * @example
     * // Create many Leases
     * const lease = await prisma.lease.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Leases and only return the `id`
     * const leaseWithIdOnly = await prisma.lease.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeaseCreateManyAndReturnArgs>(args?: SelectSubset<T, LeaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Lease.
     * @param {LeaseDeleteArgs} args - Arguments to delete one Lease.
     * @example
     * // Delete one Lease
     * const Lease = await prisma.lease.delete({
     *   where: {
     *     // ... filter to delete one Lease
     *   }
     * })
     * 
     */
    delete<T extends LeaseDeleteArgs>(args: SelectSubset<T, LeaseDeleteArgs<ExtArgs>>): Prisma__LeaseClient<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lease.
     * @param {LeaseUpdateArgs} args - Arguments to update one Lease.
     * @example
     * // Update one Lease
     * const lease = await prisma.lease.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeaseUpdateArgs>(args: SelectSubset<T, LeaseUpdateArgs<ExtArgs>>): Prisma__LeaseClient<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Leases.
     * @param {LeaseDeleteManyArgs} args - Arguments to filter Leases to delete.
     * @example
     * // Delete a few Leases
     * const { count } = await prisma.lease.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeaseDeleteManyArgs>(args?: SelectSubset<T, LeaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leases
     * const lease = await prisma.lease.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeaseUpdateManyArgs>(args: SelectSubset<T, LeaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leases and returns the data updated in the database.
     * @param {LeaseUpdateManyAndReturnArgs} args - Arguments to update many Leases.
     * @example
     * // Update many Leases
     * const lease = await prisma.lease.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Leases and only return the `id`
     * const leaseWithIdOnly = await prisma.lease.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeaseUpdateManyAndReturnArgs>(args: SelectSubset<T, LeaseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Lease.
     * @param {LeaseUpsertArgs} args - Arguments to update or create a Lease.
     * @example
     * // Update or create a Lease
     * const lease = await prisma.lease.upsert({
     *   create: {
     *     // ... data to create a Lease
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lease we want to update
     *   }
     * })
     */
    upsert<T extends LeaseUpsertArgs>(args: SelectSubset<T, LeaseUpsertArgs<ExtArgs>>): Prisma__LeaseClient<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Leases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaseCountArgs} args - Arguments to filter Leases to count.
     * @example
     * // Count the number of Leases
     * const count = await prisma.lease.count({
     *   where: {
     *     // ... the filter for the Leases we want to count
     *   }
     * })
    **/
    count<T extends LeaseCountArgs>(
      args?: Subset<T, LeaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lease.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaseAggregateArgs>(args: Subset<T, LeaseAggregateArgs>): Prisma.PrismaPromise<GetLeaseAggregateType<T>>

    /**
     * Group by Lease.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaseGroupByArgs['orderBy'] }
        : { orderBy?: LeaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lease model
   */
  readonly fields: LeaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lease.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    unit<T extends UnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitDefaultArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tenantLease<T extends Lease$tenantLeaseArgs<ExtArgs> = {}>(args?: Subset<T, Lease$tenantLeaseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantLeasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    property<T extends Lease$propertyArgs<ExtArgs> = {}>(args?: Subset<T, Lease$propertyArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    invoice<T extends Lease$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, Lease$invoiceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactions<T extends Lease$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Lease$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    maintenanceRequest<T extends Lease$maintenanceRequestArgs<ExtArgs> = {}>(args?: Subset<T, Lease$maintenanceRequestArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    leaseDocument<T extends Lease$leaseDocumentArgs<ExtArgs> = {}>(args?: Subset<T, Lease$leaseDocumentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaseDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lease model
   */
  interface LeaseFieldRefs {
    readonly id: FieldRef<"Lease", 'String'>
    readonly unitId: FieldRef<"Lease", 'String'>
    readonly tenantId: FieldRef<"Lease", 'String'>
    readonly startDate: FieldRef<"Lease", 'DateTime'>
    readonly endDate: FieldRef<"Lease", 'DateTime'>
    readonly rent: FieldRef<"Lease", 'Float'>
    readonly deposit: FieldRef<"Lease", 'Float'>
    readonly rentDueCurrency: FieldRef<"Lease", 'String'>
    readonly status: FieldRef<"Lease", 'LeaseStatus'>
    readonly createdAt: FieldRef<"Lease", 'DateTime'>
    readonly updatedAt: FieldRef<"Lease", 'DateTime'>
    readonly propertyId: FieldRef<"Lease", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Lease findUnique
   */
  export type LeaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseInclude<ExtArgs> | null
    /**
     * Filter, which Lease to fetch.
     */
    where: LeaseWhereUniqueInput
  }

  /**
   * Lease findUniqueOrThrow
   */
  export type LeaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseInclude<ExtArgs> | null
    /**
     * Filter, which Lease to fetch.
     */
    where: LeaseWhereUniqueInput
  }

  /**
   * Lease findFirst
   */
  export type LeaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseInclude<ExtArgs> | null
    /**
     * Filter, which Lease to fetch.
     */
    where?: LeaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leases to fetch.
     */
    orderBy?: LeaseOrderByWithRelationInput | LeaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leases.
     */
    cursor?: LeaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leases.
     */
    distinct?: LeaseScalarFieldEnum | LeaseScalarFieldEnum[]
  }

  /**
   * Lease findFirstOrThrow
   */
  export type LeaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseInclude<ExtArgs> | null
    /**
     * Filter, which Lease to fetch.
     */
    where?: LeaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leases to fetch.
     */
    orderBy?: LeaseOrderByWithRelationInput | LeaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leases.
     */
    cursor?: LeaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leases.
     */
    distinct?: LeaseScalarFieldEnum | LeaseScalarFieldEnum[]
  }

  /**
   * Lease findMany
   */
  export type LeaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseInclude<ExtArgs> | null
    /**
     * Filter, which Leases to fetch.
     */
    where?: LeaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leases to fetch.
     */
    orderBy?: LeaseOrderByWithRelationInput | LeaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Leases.
     */
    cursor?: LeaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leases.
     */
    skip?: number
    distinct?: LeaseScalarFieldEnum | LeaseScalarFieldEnum[]
  }

  /**
   * Lease create
   */
  export type LeaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseInclude<ExtArgs> | null
    /**
     * The data needed to create a Lease.
     */
    data: XOR<LeaseCreateInput, LeaseUncheckedCreateInput>
  }

  /**
   * Lease createMany
   */
  export type LeaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Leases.
     */
    data: LeaseCreateManyInput | LeaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lease createManyAndReturn
   */
  export type LeaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * The data used to create many Leases.
     */
    data: LeaseCreateManyInput | LeaseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lease update
   */
  export type LeaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseInclude<ExtArgs> | null
    /**
     * The data needed to update a Lease.
     */
    data: XOR<LeaseUpdateInput, LeaseUncheckedUpdateInput>
    /**
     * Choose, which Lease to update.
     */
    where: LeaseWhereUniqueInput
  }

  /**
   * Lease updateMany
   */
  export type LeaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Leases.
     */
    data: XOR<LeaseUpdateManyMutationInput, LeaseUncheckedUpdateManyInput>
    /**
     * Filter which Leases to update
     */
    where?: LeaseWhereInput
    /**
     * Limit how many Leases to update.
     */
    limit?: number
  }

  /**
   * Lease updateManyAndReturn
   */
  export type LeaseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * The data used to update Leases.
     */
    data: XOR<LeaseUpdateManyMutationInput, LeaseUncheckedUpdateManyInput>
    /**
     * Filter which Leases to update
     */
    where?: LeaseWhereInput
    /**
     * Limit how many Leases to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lease upsert
   */
  export type LeaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseInclude<ExtArgs> | null
    /**
     * The filter to search for the Lease to update in case it exists.
     */
    where: LeaseWhereUniqueInput
    /**
     * In case the Lease found by the `where` argument doesn't exist, create a new Lease with this data.
     */
    create: XOR<LeaseCreateInput, LeaseUncheckedCreateInput>
    /**
     * In case the Lease was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaseUpdateInput, LeaseUncheckedUpdateInput>
  }

  /**
   * Lease delete
   */
  export type LeaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseInclude<ExtArgs> | null
    /**
     * Filter which Lease to delete.
     */
    where: LeaseWhereUniqueInput
  }

  /**
   * Lease deleteMany
   */
  export type LeaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leases to delete
     */
    where?: LeaseWhereInput
    /**
     * Limit how many Leases to delete.
     */
    limit?: number
  }

  /**
   * Lease.tenantLease
   */
  export type Lease$tenantLeaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantLease
     */
    select?: TenantLeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantLease
     */
    omit?: TenantLeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantLeaseInclude<ExtArgs> | null
    where?: TenantLeaseWhereInput
    orderBy?: TenantLeaseOrderByWithRelationInput | TenantLeaseOrderByWithRelationInput[]
    cursor?: TenantLeaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TenantLeaseScalarFieldEnum | TenantLeaseScalarFieldEnum[]
  }

  /**
   * Lease.property
   */
  export type Lease$propertyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    where?: PropertyWhereInput
  }

  /**
   * Lease.invoice
   */
  export type Lease$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Lease.transactions
   */
  export type Lease$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    where?: TransactionsWhereInput
    orderBy?: TransactionsOrderByWithRelationInput | TransactionsOrderByWithRelationInput[]
    cursor?: TransactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * Lease.maintenanceRequest
   */
  export type Lease$maintenanceRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    where?: MaintenanceRequestWhereInput
    orderBy?: MaintenanceRequestOrderByWithRelationInput | MaintenanceRequestOrderByWithRelationInput[]
    cursor?: MaintenanceRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaintenanceRequestScalarFieldEnum | MaintenanceRequestScalarFieldEnum[]
  }

  /**
   * Lease.leaseDocument
   */
  export type Lease$leaseDocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaseDocument
     */
    select?: LeaseDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaseDocument
     */
    omit?: LeaseDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseDocumentInclude<ExtArgs> | null
    where?: LeaseDocumentWhereInput
    orderBy?: LeaseDocumentOrderByWithRelationInput | LeaseDocumentOrderByWithRelationInput[]
    cursor?: LeaseDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaseDocumentScalarFieldEnum | LeaseDocumentScalarFieldEnum[]
  }

  /**
   * Lease without action
   */
  export type LeaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    dueAmount: number | null
  }

  export type InvoiceSumAggregateOutputType = {
    dueAmount: number | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    leaseId: string | null
    description: string | null
    dueAmount: number | null
    dueDate: Date | null
    category: $Enums.InvoiceCategory | null
    status: $Enums.InvoiceStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    leaseId: string | null
    description: string | null
    dueAmount: number | null
    dueDate: Date | null
    category: $Enums.InvoiceCategory | null
    status: $Enums.InvoiceStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    leaseId: number
    description: number
    dueAmount: number
    dueDate: number
    category: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    dueAmount?: true
  }

  export type InvoiceSumAggregateInputType = {
    dueAmount?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    leaseId?: true
    description?: true
    dueAmount?: true
    dueDate?: true
    category?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    leaseId?: true
    description?: true
    dueAmount?: true
    dueDate?: true
    category?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    leaseId?: true
    description?: true
    dueAmount?: true
    dueDate?: true
    category?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    leaseId: string
    description: string
    dueAmount: number
    dueDate: Date
    category: $Enums.InvoiceCategory
    status: $Enums.InvoiceStatus
    createdAt: Date
    updatedAt: Date
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leaseId?: boolean
    description?: boolean
    dueAmount?: boolean
    dueDate?: boolean
    category?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lease?: boolean | LeaseDefaultArgs<ExtArgs>
    transactions?: boolean | Invoice$transactionsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leaseId?: boolean
    description?: boolean
    dueAmount?: boolean
    dueDate?: boolean
    category?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lease?: boolean | LeaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leaseId?: boolean
    description?: boolean
    dueAmount?: boolean
    dueDate?: boolean
    category?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lease?: boolean | LeaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    leaseId?: boolean
    description?: boolean
    dueAmount?: boolean
    dueDate?: boolean
    category?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "leaseId" | "description" | "dueAmount" | "dueDate" | "category" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["invoice"]>
  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lease?: boolean | LeaseDefaultArgs<ExtArgs>
    transactions?: boolean | Invoice$transactionsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lease?: boolean | LeaseDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lease?: boolean | LeaseDefaultArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      lease: Prisma.$LeasePayload<ExtArgs>
      transactions: Prisma.$TransactionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      leaseId: string
      description: string
      dueAmount: number
      dueDate: Date
      category: $Enums.InvoiceCategory
      status: $Enums.InvoiceStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices and returns the data updated in the database.
     * @param {InvoiceUpdateManyAndReturnArgs} args - Arguments to update many Invoices.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lease<T extends LeaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LeaseDefaultArgs<ExtArgs>>): Prisma__LeaseClient<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transactions<T extends Invoice$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly leaseId: FieldRef<"Invoice", 'String'>
    readonly description: FieldRef<"Invoice", 'String'>
    readonly dueAmount: FieldRef<"Invoice", 'Float'>
    readonly dueDate: FieldRef<"Invoice", 'DateTime'>
    readonly category: FieldRef<"Invoice", 'InvoiceCategory'>
    readonly status: FieldRef<"Invoice", 'InvoiceStatus'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
    readonly updatedAt: FieldRef<"Invoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
  }

  /**
   * Invoice updateManyAndReturn
   */
  export type InvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to delete.
     */
    limit?: number
  }

  /**
   * Invoice.transactions
   */
  export type Invoice$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    where?: TransactionsWhereInput
    orderBy?: TransactionsOrderByWithRelationInput | TransactionsOrderByWithRelationInput[]
    cursor?: TransactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model Transactions
   */

  export type AggregateTransactions = {
    _count: TransactionsCountAggregateOutputType | null
    _avg: TransactionsAvgAggregateOutputType | null
    _sum: TransactionsSumAggregateOutputType | null
    _min: TransactionsMinAggregateOutputType | null
    _max: TransactionsMaxAggregateOutputType | null
  }

  export type TransactionsAvgAggregateOutputType = {
    amountPaid: number | null
  }

  export type TransactionsSumAggregateOutputType = {
    amountPaid: number | null
  }

  export type TransactionsMinAggregateOutputType = {
    id: string | null
    leaseId: string | null
    description: string | null
    amountPaid: number | null
    referenceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    invoiceId: string | null
  }

  export type TransactionsMaxAggregateOutputType = {
    id: string | null
    leaseId: string | null
    description: string | null
    amountPaid: number | null
    referenceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    invoiceId: string | null
  }

  export type TransactionsCountAggregateOutputType = {
    id: number
    leaseId: number
    description: number
    amountPaid: number
    referenceId: number
    createdAt: number
    updatedAt: number
    invoiceId: number
    _all: number
  }


  export type TransactionsAvgAggregateInputType = {
    amountPaid?: true
  }

  export type TransactionsSumAggregateInputType = {
    amountPaid?: true
  }

  export type TransactionsMinAggregateInputType = {
    id?: true
    leaseId?: true
    description?: true
    amountPaid?: true
    referenceId?: true
    createdAt?: true
    updatedAt?: true
    invoiceId?: true
  }

  export type TransactionsMaxAggregateInputType = {
    id?: true
    leaseId?: true
    description?: true
    amountPaid?: true
    referenceId?: true
    createdAt?: true
    updatedAt?: true
    invoiceId?: true
  }

  export type TransactionsCountAggregateInputType = {
    id?: true
    leaseId?: true
    description?: true
    amountPaid?: true
    referenceId?: true
    createdAt?: true
    updatedAt?: true
    invoiceId?: true
    _all?: true
  }

  export type TransactionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to aggregate.
     */
    where?: TransactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionsOrderByWithRelationInput | TransactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionsMaxAggregateInputType
  }

  export type GetTransactionsAggregateType<T extends TransactionsAggregateArgs> = {
        [P in keyof T & keyof AggregateTransactions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransactions[P]>
      : GetScalarType<T[P], AggregateTransactions[P]>
  }




  export type TransactionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionsWhereInput
    orderBy?: TransactionsOrderByWithAggregationInput | TransactionsOrderByWithAggregationInput[]
    by: TransactionsScalarFieldEnum[] | TransactionsScalarFieldEnum
    having?: TransactionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionsCountAggregateInputType | true
    _avg?: TransactionsAvgAggregateInputType
    _sum?: TransactionsSumAggregateInputType
    _min?: TransactionsMinAggregateInputType
    _max?: TransactionsMaxAggregateInputType
  }

  export type TransactionsGroupByOutputType = {
    id: string
    leaseId: string
    description: string
    amountPaid: number
    referenceId: string | null
    createdAt: Date
    updatedAt: Date
    invoiceId: string | null
    _count: TransactionsCountAggregateOutputType | null
    _avg: TransactionsAvgAggregateOutputType | null
    _sum: TransactionsSumAggregateOutputType | null
    _min: TransactionsMinAggregateOutputType | null
    _max: TransactionsMaxAggregateOutputType | null
  }

  type GetTransactionsGroupByPayload<T extends TransactionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionsGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionsGroupByOutputType[P]>
        }
      >
    >


  export type TransactionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leaseId?: boolean
    description?: boolean
    amountPaid?: boolean
    referenceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoiceId?: boolean
    lease?: boolean | LeaseDefaultArgs<ExtArgs>
    invoice?: boolean | Transactions$invoiceArgs<ExtArgs>
  }, ExtArgs["result"]["transactions"]>

  export type TransactionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leaseId?: boolean
    description?: boolean
    amountPaid?: boolean
    referenceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoiceId?: boolean
    lease?: boolean | LeaseDefaultArgs<ExtArgs>
    invoice?: boolean | Transactions$invoiceArgs<ExtArgs>
  }, ExtArgs["result"]["transactions"]>

  export type TransactionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leaseId?: boolean
    description?: boolean
    amountPaid?: boolean
    referenceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoiceId?: boolean
    lease?: boolean | LeaseDefaultArgs<ExtArgs>
    invoice?: boolean | Transactions$invoiceArgs<ExtArgs>
  }, ExtArgs["result"]["transactions"]>

  export type TransactionsSelectScalar = {
    id?: boolean
    leaseId?: boolean
    description?: boolean
    amountPaid?: boolean
    referenceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoiceId?: boolean
  }

  export type TransactionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "leaseId" | "description" | "amountPaid" | "referenceId" | "createdAt" | "updatedAt" | "invoiceId", ExtArgs["result"]["transactions"]>
  export type TransactionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lease?: boolean | LeaseDefaultArgs<ExtArgs>
    invoice?: boolean | Transactions$invoiceArgs<ExtArgs>
  }
  export type TransactionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lease?: boolean | LeaseDefaultArgs<ExtArgs>
    invoice?: boolean | Transactions$invoiceArgs<ExtArgs>
  }
  export type TransactionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lease?: boolean | LeaseDefaultArgs<ExtArgs>
    invoice?: boolean | Transactions$invoiceArgs<ExtArgs>
  }

  export type $TransactionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transactions"
    objects: {
      lease: Prisma.$LeasePayload<ExtArgs>
      invoice: Prisma.$InvoicePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      leaseId: string
      description: string
      amountPaid: number
      referenceId: string | null
      createdAt: Date
      updatedAt: Date
      invoiceId: string | null
    }, ExtArgs["result"]["transactions"]>
    composites: {}
  }

  type TransactionsGetPayload<S extends boolean | null | undefined | TransactionsDefaultArgs> = $Result.GetResult<Prisma.$TransactionsPayload, S>

  type TransactionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionsCountAggregateInputType | true
    }

  export interface TransactionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transactions'], meta: { name: 'Transactions' } }
    /**
     * Find zero or one Transactions that matches the filter.
     * @param {TransactionsFindUniqueArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionsFindUniqueArgs>(args: SelectSubset<T, TransactionsFindUniqueArgs<ExtArgs>>): Prisma__TransactionsClient<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transactions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionsFindUniqueOrThrowArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionsFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionsClient<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsFindFirstArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionsFindFirstArgs>(args?: SelectSubset<T, TransactionsFindFirstArgs<ExtArgs>>): Prisma__TransactionsClient<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transactions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsFindFirstOrThrowArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionsFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionsClient<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transactions.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transactions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionsWithIdOnly = await prisma.transactions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionsFindManyArgs>(args?: SelectSubset<T, TransactionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transactions.
     * @param {TransactionsCreateArgs} args - Arguments to create a Transactions.
     * @example
     * // Create one Transactions
     * const Transactions = await prisma.transactions.create({
     *   data: {
     *     // ... data to create a Transactions
     *   }
     * })
     * 
     */
    create<T extends TransactionsCreateArgs>(args: SelectSubset<T, TransactionsCreateArgs<ExtArgs>>): Prisma__TransactionsClient<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {TransactionsCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transactions = await prisma.transactions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionsCreateManyArgs>(args?: SelectSubset<T, TransactionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionsCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transactions = await prisma.transactions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionsWithIdOnly = await prisma.transactions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionsCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transactions.
     * @param {TransactionsDeleteArgs} args - Arguments to delete one Transactions.
     * @example
     * // Delete one Transactions
     * const Transactions = await prisma.transactions.delete({
     *   where: {
     *     // ... filter to delete one Transactions
     *   }
     * })
     * 
     */
    delete<T extends TransactionsDeleteArgs>(args: SelectSubset<T, TransactionsDeleteArgs<ExtArgs>>): Prisma__TransactionsClient<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transactions.
     * @param {TransactionsUpdateArgs} args - Arguments to update one Transactions.
     * @example
     * // Update one Transactions
     * const transactions = await prisma.transactions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionsUpdateArgs>(args: SelectSubset<T, TransactionsUpdateArgs<ExtArgs>>): Prisma__TransactionsClient<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionsDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transactions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionsDeleteManyArgs>(args?: SelectSubset<T, TransactionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transactions = await prisma.transactions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionsUpdateManyArgs>(args: SelectSubset<T, TransactionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions and returns the data updated in the database.
     * @param {TransactionsUpdateManyAndReturnArgs} args - Arguments to update many Transactions.
     * @example
     * // Update many Transactions
     * const transactions = await prisma.transactions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transactions and only return the `id`
     * const transactionsWithIdOnly = await prisma.transactions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionsUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transactions.
     * @param {TransactionsUpsertArgs} args - Arguments to update or create a Transactions.
     * @example
     * // Update or create a Transactions
     * const transactions = await prisma.transactions.upsert({
     *   create: {
     *     // ... data to create a Transactions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transactions we want to update
     *   }
     * })
     */
    upsert<T extends TransactionsUpsertArgs>(args: SelectSubset<T, TransactionsUpsertArgs<ExtArgs>>): Prisma__TransactionsClient<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transactions.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionsCountArgs>(
      args?: Subset<T, TransactionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionsAggregateArgs>(args: Subset<T, TransactionsAggregateArgs>): Prisma.PrismaPromise<GetTransactionsAggregateType<T>>

    /**
     * Group by Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionsGroupByArgs['orderBy'] }
        : { orderBy?: TransactionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transactions model
   */
  readonly fields: TransactionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transactions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lease<T extends LeaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LeaseDefaultArgs<ExtArgs>>): Prisma__LeaseClient<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    invoice<T extends Transactions$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, Transactions$invoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transactions model
   */
  interface TransactionsFieldRefs {
    readonly id: FieldRef<"Transactions", 'String'>
    readonly leaseId: FieldRef<"Transactions", 'String'>
    readonly description: FieldRef<"Transactions", 'String'>
    readonly amountPaid: FieldRef<"Transactions", 'Float'>
    readonly referenceId: FieldRef<"Transactions", 'String'>
    readonly createdAt: FieldRef<"Transactions", 'DateTime'>
    readonly updatedAt: FieldRef<"Transactions", 'DateTime'>
    readonly invoiceId: FieldRef<"Transactions", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Transactions findUnique
   */
  export type TransactionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where: TransactionsWhereUniqueInput
  }

  /**
   * Transactions findUniqueOrThrow
   */
  export type TransactionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where: TransactionsWhereUniqueInput
  }

  /**
   * Transactions findFirst
   */
  export type TransactionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionsOrderByWithRelationInput | TransactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * Transactions findFirstOrThrow
   */
  export type TransactionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionsOrderByWithRelationInput | TransactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * Transactions findMany
   */
  export type TransactionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionsOrderByWithRelationInput | TransactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * Transactions create
   */
  export type TransactionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    /**
     * The data needed to create a Transactions.
     */
    data: XOR<TransactionsCreateInput, TransactionsUncheckedCreateInput>
  }

  /**
   * Transactions createMany
   */
  export type TransactionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionsCreateManyInput | TransactionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transactions createManyAndReturn
   */
  export type TransactionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionsCreateManyInput | TransactionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transactions update
   */
  export type TransactionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    /**
     * The data needed to update a Transactions.
     */
    data: XOR<TransactionsUpdateInput, TransactionsUncheckedUpdateInput>
    /**
     * Choose, which Transactions to update.
     */
    where: TransactionsWhereUniqueInput
  }

  /**
   * Transactions updateMany
   */
  export type TransactionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionsUpdateManyMutationInput, TransactionsUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionsWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
  }

  /**
   * Transactions updateManyAndReturn
   */
  export type TransactionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionsUpdateManyMutationInput, TransactionsUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionsWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transactions upsert
   */
  export type TransactionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    /**
     * The filter to search for the Transactions to update in case it exists.
     */
    where: TransactionsWhereUniqueInput
    /**
     * In case the Transactions found by the `where` argument doesn't exist, create a new Transactions with this data.
     */
    create: XOR<TransactionsCreateInput, TransactionsUncheckedCreateInput>
    /**
     * In case the Transactions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionsUpdateInput, TransactionsUncheckedUpdateInput>
  }

  /**
   * Transactions delete
   */
  export type TransactionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    /**
     * Filter which Transactions to delete.
     */
    where: TransactionsWhereUniqueInput
  }

  /**
   * Transactions deleteMany
   */
  export type TransactionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionsWhereInput
    /**
     * Limit how many Transactions to delete.
     */
    limit?: number
  }

  /**
   * Transactions.invoice
   */
  export type Transactions$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
  }

  /**
   * Transactions without action
   */
  export type TransactionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
  }


  /**
   * Model TenantLease
   */

  export type AggregateTenantLease = {
    _count: TenantLeaseCountAggregateOutputType | null
    _min: TenantLeaseMinAggregateOutputType | null
    _max: TenantLeaseMaxAggregateOutputType | null
  }

  export type TenantLeaseMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    leaseId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantLeaseMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    leaseId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantLeaseCountAggregateOutputType = {
    id: number
    tenantId: number
    leaseId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TenantLeaseMinAggregateInputType = {
    id?: true
    tenantId?: true
    leaseId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantLeaseMaxAggregateInputType = {
    id?: true
    tenantId?: true
    leaseId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantLeaseCountAggregateInputType = {
    id?: true
    tenantId?: true
    leaseId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TenantLeaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantLease to aggregate.
     */
    where?: TenantLeaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantLeases to fetch.
     */
    orderBy?: TenantLeaseOrderByWithRelationInput | TenantLeaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantLeaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantLeases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantLeases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TenantLeases
    **/
    _count?: true | TenantLeaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantLeaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantLeaseMaxAggregateInputType
  }

  export type GetTenantLeaseAggregateType<T extends TenantLeaseAggregateArgs> = {
        [P in keyof T & keyof AggregateTenantLease]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenantLease[P]>
      : GetScalarType<T[P], AggregateTenantLease[P]>
  }




  export type TenantLeaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantLeaseWhereInput
    orderBy?: TenantLeaseOrderByWithAggregationInput | TenantLeaseOrderByWithAggregationInput[]
    by: TenantLeaseScalarFieldEnum[] | TenantLeaseScalarFieldEnum
    having?: TenantLeaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantLeaseCountAggregateInputType | true
    _min?: TenantLeaseMinAggregateInputType
    _max?: TenantLeaseMaxAggregateInputType
  }

  export type TenantLeaseGroupByOutputType = {
    id: string
    tenantId: string
    leaseId: string
    createdAt: Date
    updatedAt: Date
    _count: TenantLeaseCountAggregateOutputType | null
    _min: TenantLeaseMinAggregateOutputType | null
    _max: TenantLeaseMaxAggregateOutputType | null
  }

  type GetTenantLeaseGroupByPayload<T extends TenantLeaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantLeaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantLeaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantLeaseGroupByOutputType[P]>
            : GetScalarType<T[P], TenantLeaseGroupByOutputType[P]>
        }
      >
    >


  export type TenantLeaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    leaseId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    lease?: boolean | LeaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantLease"]>

  export type TenantLeaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    leaseId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    lease?: boolean | LeaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantLease"]>

  export type TenantLeaseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    leaseId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    lease?: boolean | LeaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantLease"]>

  export type TenantLeaseSelectScalar = {
    id?: boolean
    tenantId?: boolean
    leaseId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TenantLeaseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "leaseId" | "createdAt" | "updatedAt", ExtArgs["result"]["tenantLease"]>
  export type TenantLeaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    lease?: boolean | LeaseDefaultArgs<ExtArgs>
  }
  export type TenantLeaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    lease?: boolean | LeaseDefaultArgs<ExtArgs>
  }
  export type TenantLeaseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    lease?: boolean | LeaseDefaultArgs<ExtArgs>
  }

  export type $TenantLeasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TenantLease"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      lease: Prisma.$LeasePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      leaseId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tenantLease"]>
    composites: {}
  }

  type TenantLeaseGetPayload<S extends boolean | null | undefined | TenantLeaseDefaultArgs> = $Result.GetResult<Prisma.$TenantLeasePayload, S>

  type TenantLeaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TenantLeaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantLeaseCountAggregateInputType | true
    }

  export interface TenantLeaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TenantLease'], meta: { name: 'TenantLease' } }
    /**
     * Find zero or one TenantLease that matches the filter.
     * @param {TenantLeaseFindUniqueArgs} args - Arguments to find a TenantLease
     * @example
     * // Get one TenantLease
     * const tenantLease = await prisma.tenantLease.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantLeaseFindUniqueArgs>(args: SelectSubset<T, TenantLeaseFindUniqueArgs<ExtArgs>>): Prisma__TenantLeaseClient<$Result.GetResult<Prisma.$TenantLeasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TenantLease that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TenantLeaseFindUniqueOrThrowArgs} args - Arguments to find a TenantLease
     * @example
     * // Get one TenantLease
     * const tenantLease = await prisma.tenantLease.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantLeaseFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantLeaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantLeaseClient<$Result.GetResult<Prisma.$TenantLeasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantLease that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantLeaseFindFirstArgs} args - Arguments to find a TenantLease
     * @example
     * // Get one TenantLease
     * const tenantLease = await prisma.tenantLease.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantLeaseFindFirstArgs>(args?: SelectSubset<T, TenantLeaseFindFirstArgs<ExtArgs>>): Prisma__TenantLeaseClient<$Result.GetResult<Prisma.$TenantLeasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantLease that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantLeaseFindFirstOrThrowArgs} args - Arguments to find a TenantLease
     * @example
     * // Get one TenantLease
     * const tenantLease = await prisma.tenantLease.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantLeaseFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantLeaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantLeaseClient<$Result.GetResult<Prisma.$TenantLeasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TenantLeases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantLeaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TenantLeases
     * const tenantLeases = await prisma.tenantLease.findMany()
     * 
     * // Get first 10 TenantLeases
     * const tenantLeases = await prisma.tenantLease.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantLeaseWithIdOnly = await prisma.tenantLease.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantLeaseFindManyArgs>(args?: SelectSubset<T, TenantLeaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantLeasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TenantLease.
     * @param {TenantLeaseCreateArgs} args - Arguments to create a TenantLease.
     * @example
     * // Create one TenantLease
     * const TenantLease = await prisma.tenantLease.create({
     *   data: {
     *     // ... data to create a TenantLease
     *   }
     * })
     * 
     */
    create<T extends TenantLeaseCreateArgs>(args: SelectSubset<T, TenantLeaseCreateArgs<ExtArgs>>): Prisma__TenantLeaseClient<$Result.GetResult<Prisma.$TenantLeasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TenantLeases.
     * @param {TenantLeaseCreateManyArgs} args - Arguments to create many TenantLeases.
     * @example
     * // Create many TenantLeases
     * const tenantLease = await prisma.tenantLease.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantLeaseCreateManyArgs>(args?: SelectSubset<T, TenantLeaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TenantLeases and returns the data saved in the database.
     * @param {TenantLeaseCreateManyAndReturnArgs} args - Arguments to create many TenantLeases.
     * @example
     * // Create many TenantLeases
     * const tenantLease = await prisma.tenantLease.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TenantLeases and only return the `id`
     * const tenantLeaseWithIdOnly = await prisma.tenantLease.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantLeaseCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantLeaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantLeasePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TenantLease.
     * @param {TenantLeaseDeleteArgs} args - Arguments to delete one TenantLease.
     * @example
     * // Delete one TenantLease
     * const TenantLease = await prisma.tenantLease.delete({
     *   where: {
     *     // ... filter to delete one TenantLease
     *   }
     * })
     * 
     */
    delete<T extends TenantLeaseDeleteArgs>(args: SelectSubset<T, TenantLeaseDeleteArgs<ExtArgs>>): Prisma__TenantLeaseClient<$Result.GetResult<Prisma.$TenantLeasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TenantLease.
     * @param {TenantLeaseUpdateArgs} args - Arguments to update one TenantLease.
     * @example
     * // Update one TenantLease
     * const tenantLease = await prisma.tenantLease.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantLeaseUpdateArgs>(args: SelectSubset<T, TenantLeaseUpdateArgs<ExtArgs>>): Prisma__TenantLeaseClient<$Result.GetResult<Prisma.$TenantLeasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TenantLeases.
     * @param {TenantLeaseDeleteManyArgs} args - Arguments to filter TenantLeases to delete.
     * @example
     * // Delete a few TenantLeases
     * const { count } = await prisma.tenantLease.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantLeaseDeleteManyArgs>(args?: SelectSubset<T, TenantLeaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantLeases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantLeaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TenantLeases
     * const tenantLease = await prisma.tenantLease.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantLeaseUpdateManyArgs>(args: SelectSubset<T, TenantLeaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantLeases and returns the data updated in the database.
     * @param {TenantLeaseUpdateManyAndReturnArgs} args - Arguments to update many TenantLeases.
     * @example
     * // Update many TenantLeases
     * const tenantLease = await prisma.tenantLease.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TenantLeases and only return the `id`
     * const tenantLeaseWithIdOnly = await prisma.tenantLease.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TenantLeaseUpdateManyAndReturnArgs>(args: SelectSubset<T, TenantLeaseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantLeasePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TenantLease.
     * @param {TenantLeaseUpsertArgs} args - Arguments to update or create a TenantLease.
     * @example
     * // Update or create a TenantLease
     * const tenantLease = await prisma.tenantLease.upsert({
     *   create: {
     *     // ... data to create a TenantLease
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TenantLease we want to update
     *   }
     * })
     */
    upsert<T extends TenantLeaseUpsertArgs>(args: SelectSubset<T, TenantLeaseUpsertArgs<ExtArgs>>): Prisma__TenantLeaseClient<$Result.GetResult<Prisma.$TenantLeasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TenantLeases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantLeaseCountArgs} args - Arguments to filter TenantLeases to count.
     * @example
     * // Count the number of TenantLeases
     * const count = await prisma.tenantLease.count({
     *   where: {
     *     // ... the filter for the TenantLeases we want to count
     *   }
     * })
    **/
    count<T extends TenantLeaseCountArgs>(
      args?: Subset<T, TenantLeaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantLeaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TenantLease.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantLeaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantLeaseAggregateArgs>(args: Subset<T, TenantLeaseAggregateArgs>): Prisma.PrismaPromise<GetTenantLeaseAggregateType<T>>

    /**
     * Group by TenantLease.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantLeaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantLeaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantLeaseGroupByArgs['orderBy'] }
        : { orderBy?: TenantLeaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantLeaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantLeaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TenantLease model
   */
  readonly fields: TenantLeaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TenantLease.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantLeaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lease<T extends LeaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LeaseDefaultArgs<ExtArgs>>): Prisma__LeaseClient<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TenantLease model
   */
  interface TenantLeaseFieldRefs {
    readonly id: FieldRef<"TenantLease", 'String'>
    readonly tenantId: FieldRef<"TenantLease", 'String'>
    readonly leaseId: FieldRef<"TenantLease", 'String'>
    readonly createdAt: FieldRef<"TenantLease", 'DateTime'>
    readonly updatedAt: FieldRef<"TenantLease", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TenantLease findUnique
   */
  export type TenantLeaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantLease
     */
    select?: TenantLeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantLease
     */
    omit?: TenantLeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantLeaseInclude<ExtArgs> | null
    /**
     * Filter, which TenantLease to fetch.
     */
    where: TenantLeaseWhereUniqueInput
  }

  /**
   * TenantLease findUniqueOrThrow
   */
  export type TenantLeaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantLease
     */
    select?: TenantLeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantLease
     */
    omit?: TenantLeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantLeaseInclude<ExtArgs> | null
    /**
     * Filter, which TenantLease to fetch.
     */
    where: TenantLeaseWhereUniqueInput
  }

  /**
   * TenantLease findFirst
   */
  export type TenantLeaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantLease
     */
    select?: TenantLeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantLease
     */
    omit?: TenantLeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantLeaseInclude<ExtArgs> | null
    /**
     * Filter, which TenantLease to fetch.
     */
    where?: TenantLeaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantLeases to fetch.
     */
    orderBy?: TenantLeaseOrderByWithRelationInput | TenantLeaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantLeases.
     */
    cursor?: TenantLeaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantLeases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantLeases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantLeases.
     */
    distinct?: TenantLeaseScalarFieldEnum | TenantLeaseScalarFieldEnum[]
  }

  /**
   * TenantLease findFirstOrThrow
   */
  export type TenantLeaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantLease
     */
    select?: TenantLeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantLease
     */
    omit?: TenantLeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantLeaseInclude<ExtArgs> | null
    /**
     * Filter, which TenantLease to fetch.
     */
    where?: TenantLeaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantLeases to fetch.
     */
    orderBy?: TenantLeaseOrderByWithRelationInput | TenantLeaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantLeases.
     */
    cursor?: TenantLeaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantLeases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantLeases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantLeases.
     */
    distinct?: TenantLeaseScalarFieldEnum | TenantLeaseScalarFieldEnum[]
  }

  /**
   * TenantLease findMany
   */
  export type TenantLeaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantLease
     */
    select?: TenantLeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantLease
     */
    omit?: TenantLeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantLeaseInclude<ExtArgs> | null
    /**
     * Filter, which TenantLeases to fetch.
     */
    where?: TenantLeaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantLeases to fetch.
     */
    orderBy?: TenantLeaseOrderByWithRelationInput | TenantLeaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TenantLeases.
     */
    cursor?: TenantLeaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantLeases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantLeases.
     */
    skip?: number
    distinct?: TenantLeaseScalarFieldEnum | TenantLeaseScalarFieldEnum[]
  }

  /**
   * TenantLease create
   */
  export type TenantLeaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantLease
     */
    select?: TenantLeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantLease
     */
    omit?: TenantLeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantLeaseInclude<ExtArgs> | null
    /**
     * The data needed to create a TenantLease.
     */
    data: XOR<TenantLeaseCreateInput, TenantLeaseUncheckedCreateInput>
  }

  /**
   * TenantLease createMany
   */
  export type TenantLeaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TenantLeases.
     */
    data: TenantLeaseCreateManyInput | TenantLeaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TenantLease createManyAndReturn
   */
  export type TenantLeaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantLease
     */
    select?: TenantLeaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TenantLease
     */
    omit?: TenantLeaseOmit<ExtArgs> | null
    /**
     * The data used to create many TenantLeases.
     */
    data: TenantLeaseCreateManyInput | TenantLeaseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantLeaseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenantLease update
   */
  export type TenantLeaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantLease
     */
    select?: TenantLeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantLease
     */
    omit?: TenantLeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantLeaseInclude<ExtArgs> | null
    /**
     * The data needed to update a TenantLease.
     */
    data: XOR<TenantLeaseUpdateInput, TenantLeaseUncheckedUpdateInput>
    /**
     * Choose, which TenantLease to update.
     */
    where: TenantLeaseWhereUniqueInput
  }

  /**
   * TenantLease updateMany
   */
  export type TenantLeaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TenantLeases.
     */
    data: XOR<TenantLeaseUpdateManyMutationInput, TenantLeaseUncheckedUpdateManyInput>
    /**
     * Filter which TenantLeases to update
     */
    where?: TenantLeaseWhereInput
    /**
     * Limit how many TenantLeases to update.
     */
    limit?: number
  }

  /**
   * TenantLease updateManyAndReturn
   */
  export type TenantLeaseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantLease
     */
    select?: TenantLeaseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TenantLease
     */
    omit?: TenantLeaseOmit<ExtArgs> | null
    /**
     * The data used to update TenantLeases.
     */
    data: XOR<TenantLeaseUpdateManyMutationInput, TenantLeaseUncheckedUpdateManyInput>
    /**
     * Filter which TenantLeases to update
     */
    where?: TenantLeaseWhereInput
    /**
     * Limit how many TenantLeases to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantLeaseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenantLease upsert
   */
  export type TenantLeaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantLease
     */
    select?: TenantLeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantLease
     */
    omit?: TenantLeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantLeaseInclude<ExtArgs> | null
    /**
     * The filter to search for the TenantLease to update in case it exists.
     */
    where: TenantLeaseWhereUniqueInput
    /**
     * In case the TenantLease found by the `where` argument doesn't exist, create a new TenantLease with this data.
     */
    create: XOR<TenantLeaseCreateInput, TenantLeaseUncheckedCreateInput>
    /**
     * In case the TenantLease was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantLeaseUpdateInput, TenantLeaseUncheckedUpdateInput>
  }

  /**
   * TenantLease delete
   */
  export type TenantLeaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantLease
     */
    select?: TenantLeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantLease
     */
    omit?: TenantLeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantLeaseInclude<ExtArgs> | null
    /**
     * Filter which TenantLease to delete.
     */
    where: TenantLeaseWhereUniqueInput
  }

  /**
   * TenantLease deleteMany
   */
  export type TenantLeaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantLeases to delete
     */
    where?: TenantLeaseWhereInput
    /**
     * Limit how many TenantLeases to delete.
     */
    limit?: number
  }

  /**
   * TenantLease without action
   */
  export type TenantLeaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantLease
     */
    select?: TenantLeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantLease
     */
    omit?: TenantLeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantLeaseInclude<ExtArgs> | null
  }


  /**
   * Model MaintenanceRequest
   */

  export type AggregateMaintenanceRequest = {
    _count: MaintenanceRequestCountAggregateOutputType | null
    _min: MaintenanceRequestMinAggregateOutputType | null
    _max: MaintenanceRequestMaxAggregateOutputType | null
  }

  export type MaintenanceRequestMinAggregateOutputType = {
    id: string | null
    leaseId: string | null
    description: string | null
    status: $Enums.MaintenanceRequestStatus | null
    priority: $Enums.MaintenanceRequestPriority | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MaintenanceRequestMaxAggregateOutputType = {
    id: string | null
    leaseId: string | null
    description: string | null
    status: $Enums.MaintenanceRequestStatus | null
    priority: $Enums.MaintenanceRequestPriority | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MaintenanceRequestCountAggregateOutputType = {
    id: number
    leaseId: number
    description: number
    status: number
    priority: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MaintenanceRequestMinAggregateInputType = {
    id?: true
    leaseId?: true
    description?: true
    status?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MaintenanceRequestMaxAggregateInputType = {
    id?: true
    leaseId?: true
    description?: true
    status?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MaintenanceRequestCountAggregateInputType = {
    id?: true
    leaseId?: true
    description?: true
    status?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MaintenanceRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaintenanceRequest to aggregate.
     */
    where?: MaintenanceRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceRequests to fetch.
     */
    orderBy?: MaintenanceRequestOrderByWithRelationInput | MaintenanceRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaintenanceRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MaintenanceRequests
    **/
    _count?: true | MaintenanceRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaintenanceRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaintenanceRequestMaxAggregateInputType
  }

  export type GetMaintenanceRequestAggregateType<T extends MaintenanceRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateMaintenanceRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaintenanceRequest[P]>
      : GetScalarType<T[P], AggregateMaintenanceRequest[P]>
  }




  export type MaintenanceRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceRequestWhereInput
    orderBy?: MaintenanceRequestOrderByWithAggregationInput | MaintenanceRequestOrderByWithAggregationInput[]
    by: MaintenanceRequestScalarFieldEnum[] | MaintenanceRequestScalarFieldEnum
    having?: MaintenanceRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaintenanceRequestCountAggregateInputType | true
    _min?: MaintenanceRequestMinAggregateInputType
    _max?: MaintenanceRequestMaxAggregateInputType
  }

  export type MaintenanceRequestGroupByOutputType = {
    id: string
    leaseId: string
    description: string
    status: $Enums.MaintenanceRequestStatus
    priority: $Enums.MaintenanceRequestPriority
    createdAt: Date
    updatedAt: Date
    _count: MaintenanceRequestCountAggregateOutputType | null
    _min: MaintenanceRequestMinAggregateOutputType | null
    _max: MaintenanceRequestMaxAggregateOutputType | null
  }

  type GetMaintenanceRequestGroupByPayload<T extends MaintenanceRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaintenanceRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaintenanceRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaintenanceRequestGroupByOutputType[P]>
            : GetScalarType<T[P], MaintenanceRequestGroupByOutputType[P]>
        }
      >
    >


  export type MaintenanceRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leaseId?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lease?: boolean | LeaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenanceRequest"]>

  export type MaintenanceRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leaseId?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lease?: boolean | LeaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenanceRequest"]>

  export type MaintenanceRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leaseId?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lease?: boolean | LeaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenanceRequest"]>

  export type MaintenanceRequestSelectScalar = {
    id?: boolean
    leaseId?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MaintenanceRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "leaseId" | "description" | "status" | "priority" | "createdAt" | "updatedAt", ExtArgs["result"]["maintenanceRequest"]>
  export type MaintenanceRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lease?: boolean | LeaseDefaultArgs<ExtArgs>
  }
  export type MaintenanceRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lease?: boolean | LeaseDefaultArgs<ExtArgs>
  }
  export type MaintenanceRequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lease?: boolean | LeaseDefaultArgs<ExtArgs>
  }

  export type $MaintenanceRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MaintenanceRequest"
    objects: {
      lease: Prisma.$LeasePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      leaseId: string
      description: string
      status: $Enums.MaintenanceRequestStatus
      priority: $Enums.MaintenanceRequestPriority
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["maintenanceRequest"]>
    composites: {}
  }

  type MaintenanceRequestGetPayload<S extends boolean | null | undefined | MaintenanceRequestDefaultArgs> = $Result.GetResult<Prisma.$MaintenanceRequestPayload, S>

  type MaintenanceRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MaintenanceRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MaintenanceRequestCountAggregateInputType | true
    }

  export interface MaintenanceRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MaintenanceRequest'], meta: { name: 'MaintenanceRequest' } }
    /**
     * Find zero or one MaintenanceRequest that matches the filter.
     * @param {MaintenanceRequestFindUniqueArgs} args - Arguments to find a MaintenanceRequest
     * @example
     * // Get one MaintenanceRequest
     * const maintenanceRequest = await prisma.maintenanceRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaintenanceRequestFindUniqueArgs>(args: SelectSubset<T, MaintenanceRequestFindUniqueArgs<ExtArgs>>): Prisma__MaintenanceRequestClient<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MaintenanceRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MaintenanceRequestFindUniqueOrThrowArgs} args - Arguments to find a MaintenanceRequest
     * @example
     * // Get one MaintenanceRequest
     * const maintenanceRequest = await prisma.maintenanceRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaintenanceRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, MaintenanceRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaintenanceRequestClient<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MaintenanceRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceRequestFindFirstArgs} args - Arguments to find a MaintenanceRequest
     * @example
     * // Get one MaintenanceRequest
     * const maintenanceRequest = await prisma.maintenanceRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaintenanceRequestFindFirstArgs>(args?: SelectSubset<T, MaintenanceRequestFindFirstArgs<ExtArgs>>): Prisma__MaintenanceRequestClient<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MaintenanceRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceRequestFindFirstOrThrowArgs} args - Arguments to find a MaintenanceRequest
     * @example
     * // Get one MaintenanceRequest
     * const maintenanceRequest = await prisma.maintenanceRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaintenanceRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, MaintenanceRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaintenanceRequestClient<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MaintenanceRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MaintenanceRequests
     * const maintenanceRequests = await prisma.maintenanceRequest.findMany()
     * 
     * // Get first 10 MaintenanceRequests
     * const maintenanceRequests = await prisma.maintenanceRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const maintenanceRequestWithIdOnly = await prisma.maintenanceRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaintenanceRequestFindManyArgs>(args?: SelectSubset<T, MaintenanceRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MaintenanceRequest.
     * @param {MaintenanceRequestCreateArgs} args - Arguments to create a MaintenanceRequest.
     * @example
     * // Create one MaintenanceRequest
     * const MaintenanceRequest = await prisma.maintenanceRequest.create({
     *   data: {
     *     // ... data to create a MaintenanceRequest
     *   }
     * })
     * 
     */
    create<T extends MaintenanceRequestCreateArgs>(args: SelectSubset<T, MaintenanceRequestCreateArgs<ExtArgs>>): Prisma__MaintenanceRequestClient<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MaintenanceRequests.
     * @param {MaintenanceRequestCreateManyArgs} args - Arguments to create many MaintenanceRequests.
     * @example
     * // Create many MaintenanceRequests
     * const maintenanceRequest = await prisma.maintenanceRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaintenanceRequestCreateManyArgs>(args?: SelectSubset<T, MaintenanceRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MaintenanceRequests and returns the data saved in the database.
     * @param {MaintenanceRequestCreateManyAndReturnArgs} args - Arguments to create many MaintenanceRequests.
     * @example
     * // Create many MaintenanceRequests
     * const maintenanceRequest = await prisma.maintenanceRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MaintenanceRequests and only return the `id`
     * const maintenanceRequestWithIdOnly = await prisma.maintenanceRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaintenanceRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, MaintenanceRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MaintenanceRequest.
     * @param {MaintenanceRequestDeleteArgs} args - Arguments to delete one MaintenanceRequest.
     * @example
     * // Delete one MaintenanceRequest
     * const MaintenanceRequest = await prisma.maintenanceRequest.delete({
     *   where: {
     *     // ... filter to delete one MaintenanceRequest
     *   }
     * })
     * 
     */
    delete<T extends MaintenanceRequestDeleteArgs>(args: SelectSubset<T, MaintenanceRequestDeleteArgs<ExtArgs>>): Prisma__MaintenanceRequestClient<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MaintenanceRequest.
     * @param {MaintenanceRequestUpdateArgs} args - Arguments to update one MaintenanceRequest.
     * @example
     * // Update one MaintenanceRequest
     * const maintenanceRequest = await prisma.maintenanceRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaintenanceRequestUpdateArgs>(args: SelectSubset<T, MaintenanceRequestUpdateArgs<ExtArgs>>): Prisma__MaintenanceRequestClient<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MaintenanceRequests.
     * @param {MaintenanceRequestDeleteManyArgs} args - Arguments to filter MaintenanceRequests to delete.
     * @example
     * // Delete a few MaintenanceRequests
     * const { count } = await prisma.maintenanceRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaintenanceRequestDeleteManyArgs>(args?: SelectSubset<T, MaintenanceRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaintenanceRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MaintenanceRequests
     * const maintenanceRequest = await prisma.maintenanceRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaintenanceRequestUpdateManyArgs>(args: SelectSubset<T, MaintenanceRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaintenanceRequests and returns the data updated in the database.
     * @param {MaintenanceRequestUpdateManyAndReturnArgs} args - Arguments to update many MaintenanceRequests.
     * @example
     * // Update many MaintenanceRequests
     * const maintenanceRequest = await prisma.maintenanceRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MaintenanceRequests and only return the `id`
     * const maintenanceRequestWithIdOnly = await prisma.maintenanceRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MaintenanceRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, MaintenanceRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MaintenanceRequest.
     * @param {MaintenanceRequestUpsertArgs} args - Arguments to update or create a MaintenanceRequest.
     * @example
     * // Update or create a MaintenanceRequest
     * const maintenanceRequest = await prisma.maintenanceRequest.upsert({
     *   create: {
     *     // ... data to create a MaintenanceRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MaintenanceRequest we want to update
     *   }
     * })
     */
    upsert<T extends MaintenanceRequestUpsertArgs>(args: SelectSubset<T, MaintenanceRequestUpsertArgs<ExtArgs>>): Prisma__MaintenanceRequestClient<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MaintenanceRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceRequestCountArgs} args - Arguments to filter MaintenanceRequests to count.
     * @example
     * // Count the number of MaintenanceRequests
     * const count = await prisma.maintenanceRequest.count({
     *   where: {
     *     // ... the filter for the MaintenanceRequests we want to count
     *   }
     * })
    **/
    count<T extends MaintenanceRequestCountArgs>(
      args?: Subset<T, MaintenanceRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaintenanceRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MaintenanceRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaintenanceRequestAggregateArgs>(args: Subset<T, MaintenanceRequestAggregateArgs>): Prisma.PrismaPromise<GetMaintenanceRequestAggregateType<T>>

    /**
     * Group by MaintenanceRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaintenanceRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaintenanceRequestGroupByArgs['orderBy'] }
        : { orderBy?: MaintenanceRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaintenanceRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaintenanceRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MaintenanceRequest model
   */
  readonly fields: MaintenanceRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MaintenanceRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaintenanceRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lease<T extends LeaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LeaseDefaultArgs<ExtArgs>>): Prisma__LeaseClient<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MaintenanceRequest model
   */
  interface MaintenanceRequestFieldRefs {
    readonly id: FieldRef<"MaintenanceRequest", 'String'>
    readonly leaseId: FieldRef<"MaintenanceRequest", 'String'>
    readonly description: FieldRef<"MaintenanceRequest", 'String'>
    readonly status: FieldRef<"MaintenanceRequest", 'MaintenanceRequestStatus'>
    readonly priority: FieldRef<"MaintenanceRequest", 'MaintenanceRequestPriority'>
    readonly createdAt: FieldRef<"MaintenanceRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"MaintenanceRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MaintenanceRequest findUnique
   */
  export type MaintenanceRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceRequest to fetch.
     */
    where: MaintenanceRequestWhereUniqueInput
  }

  /**
   * MaintenanceRequest findUniqueOrThrow
   */
  export type MaintenanceRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceRequest to fetch.
     */
    where: MaintenanceRequestWhereUniqueInput
  }

  /**
   * MaintenanceRequest findFirst
   */
  export type MaintenanceRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceRequest to fetch.
     */
    where?: MaintenanceRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceRequests to fetch.
     */
    orderBy?: MaintenanceRequestOrderByWithRelationInput | MaintenanceRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaintenanceRequests.
     */
    cursor?: MaintenanceRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaintenanceRequests.
     */
    distinct?: MaintenanceRequestScalarFieldEnum | MaintenanceRequestScalarFieldEnum[]
  }

  /**
   * MaintenanceRequest findFirstOrThrow
   */
  export type MaintenanceRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceRequest to fetch.
     */
    where?: MaintenanceRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceRequests to fetch.
     */
    orderBy?: MaintenanceRequestOrderByWithRelationInput | MaintenanceRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaintenanceRequests.
     */
    cursor?: MaintenanceRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaintenanceRequests.
     */
    distinct?: MaintenanceRequestScalarFieldEnum | MaintenanceRequestScalarFieldEnum[]
  }

  /**
   * MaintenanceRequest findMany
   */
  export type MaintenanceRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceRequests to fetch.
     */
    where?: MaintenanceRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceRequests to fetch.
     */
    orderBy?: MaintenanceRequestOrderByWithRelationInput | MaintenanceRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MaintenanceRequests.
     */
    cursor?: MaintenanceRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceRequests.
     */
    skip?: number
    distinct?: MaintenanceRequestScalarFieldEnum | MaintenanceRequestScalarFieldEnum[]
  }

  /**
   * MaintenanceRequest create
   */
  export type MaintenanceRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a MaintenanceRequest.
     */
    data: XOR<MaintenanceRequestCreateInput, MaintenanceRequestUncheckedCreateInput>
  }

  /**
   * MaintenanceRequest createMany
   */
  export type MaintenanceRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MaintenanceRequests.
     */
    data: MaintenanceRequestCreateManyInput | MaintenanceRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MaintenanceRequest createManyAndReturn
   */
  export type MaintenanceRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * The data used to create many MaintenanceRequests.
     */
    data: MaintenanceRequestCreateManyInput | MaintenanceRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MaintenanceRequest update
   */
  export type MaintenanceRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a MaintenanceRequest.
     */
    data: XOR<MaintenanceRequestUpdateInput, MaintenanceRequestUncheckedUpdateInput>
    /**
     * Choose, which MaintenanceRequest to update.
     */
    where: MaintenanceRequestWhereUniqueInput
  }

  /**
   * MaintenanceRequest updateMany
   */
  export type MaintenanceRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MaintenanceRequests.
     */
    data: XOR<MaintenanceRequestUpdateManyMutationInput, MaintenanceRequestUncheckedUpdateManyInput>
    /**
     * Filter which MaintenanceRequests to update
     */
    where?: MaintenanceRequestWhereInput
    /**
     * Limit how many MaintenanceRequests to update.
     */
    limit?: number
  }

  /**
   * MaintenanceRequest updateManyAndReturn
   */
  export type MaintenanceRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * The data used to update MaintenanceRequests.
     */
    data: XOR<MaintenanceRequestUpdateManyMutationInput, MaintenanceRequestUncheckedUpdateManyInput>
    /**
     * Filter which MaintenanceRequests to update
     */
    where?: MaintenanceRequestWhereInput
    /**
     * Limit how many MaintenanceRequests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MaintenanceRequest upsert
   */
  export type MaintenanceRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the MaintenanceRequest to update in case it exists.
     */
    where: MaintenanceRequestWhereUniqueInput
    /**
     * In case the MaintenanceRequest found by the `where` argument doesn't exist, create a new MaintenanceRequest with this data.
     */
    create: XOR<MaintenanceRequestCreateInput, MaintenanceRequestUncheckedCreateInput>
    /**
     * In case the MaintenanceRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaintenanceRequestUpdateInput, MaintenanceRequestUncheckedUpdateInput>
  }

  /**
   * MaintenanceRequest delete
   */
  export type MaintenanceRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    /**
     * Filter which MaintenanceRequest to delete.
     */
    where: MaintenanceRequestWhereUniqueInput
  }

  /**
   * MaintenanceRequest deleteMany
   */
  export type MaintenanceRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaintenanceRequests to delete
     */
    where?: MaintenanceRequestWhereInput
    /**
     * Limit how many MaintenanceRequests to delete.
     */
    limit?: number
  }

  /**
   * MaintenanceRequest without action
   */
  export type MaintenanceRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
  }


  /**
   * Model TenantDocument
   */

  export type AggregateTenantDocument = {
    _count: TenantDocumentCountAggregateOutputType | null
    _min: TenantDocumentMinAggregateOutputType | null
    _max: TenantDocumentMaxAggregateOutputType | null
  }

  export type TenantDocumentMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    documentType: $Enums.TenantDocumentType | null
    documentUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantDocumentMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    documentType: $Enums.TenantDocumentType | null
    documentUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantDocumentCountAggregateOutputType = {
    id: number
    tenantId: number
    documentType: number
    documentUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TenantDocumentMinAggregateInputType = {
    id?: true
    tenantId?: true
    documentType?: true
    documentUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantDocumentMaxAggregateInputType = {
    id?: true
    tenantId?: true
    documentType?: true
    documentUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantDocumentCountAggregateInputType = {
    id?: true
    tenantId?: true
    documentType?: true
    documentUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TenantDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantDocument to aggregate.
     */
    where?: TenantDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantDocuments to fetch.
     */
    orderBy?: TenantDocumentOrderByWithRelationInput | TenantDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TenantDocuments
    **/
    _count?: true | TenantDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantDocumentMaxAggregateInputType
  }

  export type GetTenantDocumentAggregateType<T extends TenantDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateTenantDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenantDocument[P]>
      : GetScalarType<T[P], AggregateTenantDocument[P]>
  }




  export type TenantDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantDocumentWhereInput
    orderBy?: TenantDocumentOrderByWithAggregationInput | TenantDocumentOrderByWithAggregationInput[]
    by: TenantDocumentScalarFieldEnum[] | TenantDocumentScalarFieldEnum
    having?: TenantDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantDocumentCountAggregateInputType | true
    _min?: TenantDocumentMinAggregateInputType
    _max?: TenantDocumentMaxAggregateInputType
  }

  export type TenantDocumentGroupByOutputType = {
    id: string
    tenantId: string
    documentType: $Enums.TenantDocumentType
    documentUrl: string
    createdAt: Date
    updatedAt: Date
    _count: TenantDocumentCountAggregateOutputType | null
    _min: TenantDocumentMinAggregateOutputType | null
    _max: TenantDocumentMaxAggregateOutputType | null
  }

  type GetTenantDocumentGroupByPayload<T extends TenantDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], TenantDocumentGroupByOutputType[P]>
        }
      >
    >


  export type TenantDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    documentType?: boolean
    documentUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantDocument"]>

  export type TenantDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    documentType?: boolean
    documentUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantDocument"]>

  export type TenantDocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    documentType?: boolean
    documentUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantDocument"]>

  export type TenantDocumentSelectScalar = {
    id?: boolean
    tenantId?: boolean
    documentType?: boolean
    documentUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TenantDocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "documentType" | "documentUrl" | "createdAt" | "updatedAt", ExtArgs["result"]["tenantDocument"]>
  export type TenantDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type TenantDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type TenantDocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $TenantDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TenantDocument"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      documentType: $Enums.TenantDocumentType
      documentUrl: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tenantDocument"]>
    composites: {}
  }

  type TenantDocumentGetPayload<S extends boolean | null | undefined | TenantDocumentDefaultArgs> = $Result.GetResult<Prisma.$TenantDocumentPayload, S>

  type TenantDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TenantDocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantDocumentCountAggregateInputType | true
    }

  export interface TenantDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TenantDocument'], meta: { name: 'TenantDocument' } }
    /**
     * Find zero or one TenantDocument that matches the filter.
     * @param {TenantDocumentFindUniqueArgs} args - Arguments to find a TenantDocument
     * @example
     * // Get one TenantDocument
     * const tenantDocument = await prisma.tenantDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantDocumentFindUniqueArgs>(args: SelectSubset<T, TenantDocumentFindUniqueArgs<ExtArgs>>): Prisma__TenantDocumentClient<$Result.GetResult<Prisma.$TenantDocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TenantDocument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TenantDocumentFindUniqueOrThrowArgs} args - Arguments to find a TenantDocument
     * @example
     * // Get one TenantDocument
     * const tenantDocument = await prisma.tenantDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantDocumentClient<$Result.GetResult<Prisma.$TenantDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantDocumentFindFirstArgs} args - Arguments to find a TenantDocument
     * @example
     * // Get one TenantDocument
     * const tenantDocument = await prisma.tenantDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantDocumentFindFirstArgs>(args?: SelectSubset<T, TenantDocumentFindFirstArgs<ExtArgs>>): Prisma__TenantDocumentClient<$Result.GetResult<Prisma.$TenantDocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantDocumentFindFirstOrThrowArgs} args - Arguments to find a TenantDocument
     * @example
     * // Get one TenantDocument
     * const tenantDocument = await prisma.tenantDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantDocumentClient<$Result.GetResult<Prisma.$TenantDocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TenantDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TenantDocuments
     * const tenantDocuments = await prisma.tenantDocument.findMany()
     * 
     * // Get first 10 TenantDocuments
     * const tenantDocuments = await prisma.tenantDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantDocumentWithIdOnly = await prisma.tenantDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantDocumentFindManyArgs>(args?: SelectSubset<T, TenantDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TenantDocument.
     * @param {TenantDocumentCreateArgs} args - Arguments to create a TenantDocument.
     * @example
     * // Create one TenantDocument
     * const TenantDocument = await prisma.tenantDocument.create({
     *   data: {
     *     // ... data to create a TenantDocument
     *   }
     * })
     * 
     */
    create<T extends TenantDocumentCreateArgs>(args: SelectSubset<T, TenantDocumentCreateArgs<ExtArgs>>): Prisma__TenantDocumentClient<$Result.GetResult<Prisma.$TenantDocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TenantDocuments.
     * @param {TenantDocumentCreateManyArgs} args - Arguments to create many TenantDocuments.
     * @example
     * // Create many TenantDocuments
     * const tenantDocument = await prisma.tenantDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantDocumentCreateManyArgs>(args?: SelectSubset<T, TenantDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TenantDocuments and returns the data saved in the database.
     * @param {TenantDocumentCreateManyAndReturnArgs} args - Arguments to create many TenantDocuments.
     * @example
     * // Create many TenantDocuments
     * const tenantDocument = await prisma.tenantDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TenantDocuments and only return the `id`
     * const tenantDocumentWithIdOnly = await prisma.tenantDocument.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantDocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TenantDocument.
     * @param {TenantDocumentDeleteArgs} args - Arguments to delete one TenantDocument.
     * @example
     * // Delete one TenantDocument
     * const TenantDocument = await prisma.tenantDocument.delete({
     *   where: {
     *     // ... filter to delete one TenantDocument
     *   }
     * })
     * 
     */
    delete<T extends TenantDocumentDeleteArgs>(args: SelectSubset<T, TenantDocumentDeleteArgs<ExtArgs>>): Prisma__TenantDocumentClient<$Result.GetResult<Prisma.$TenantDocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TenantDocument.
     * @param {TenantDocumentUpdateArgs} args - Arguments to update one TenantDocument.
     * @example
     * // Update one TenantDocument
     * const tenantDocument = await prisma.tenantDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantDocumentUpdateArgs>(args: SelectSubset<T, TenantDocumentUpdateArgs<ExtArgs>>): Prisma__TenantDocumentClient<$Result.GetResult<Prisma.$TenantDocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TenantDocuments.
     * @param {TenantDocumentDeleteManyArgs} args - Arguments to filter TenantDocuments to delete.
     * @example
     * // Delete a few TenantDocuments
     * const { count } = await prisma.tenantDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantDocumentDeleteManyArgs>(args?: SelectSubset<T, TenantDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TenantDocuments
     * const tenantDocument = await prisma.tenantDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantDocumentUpdateManyArgs>(args: SelectSubset<T, TenantDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantDocuments and returns the data updated in the database.
     * @param {TenantDocumentUpdateManyAndReturnArgs} args - Arguments to update many TenantDocuments.
     * @example
     * // Update many TenantDocuments
     * const tenantDocument = await prisma.tenantDocument.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TenantDocuments and only return the `id`
     * const tenantDocumentWithIdOnly = await prisma.tenantDocument.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TenantDocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, TenantDocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantDocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TenantDocument.
     * @param {TenantDocumentUpsertArgs} args - Arguments to update or create a TenantDocument.
     * @example
     * // Update or create a TenantDocument
     * const tenantDocument = await prisma.tenantDocument.upsert({
     *   create: {
     *     // ... data to create a TenantDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TenantDocument we want to update
     *   }
     * })
     */
    upsert<T extends TenantDocumentUpsertArgs>(args: SelectSubset<T, TenantDocumentUpsertArgs<ExtArgs>>): Prisma__TenantDocumentClient<$Result.GetResult<Prisma.$TenantDocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TenantDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantDocumentCountArgs} args - Arguments to filter TenantDocuments to count.
     * @example
     * // Count the number of TenantDocuments
     * const count = await prisma.tenantDocument.count({
     *   where: {
     *     // ... the filter for the TenantDocuments we want to count
     *   }
     * })
    **/
    count<T extends TenantDocumentCountArgs>(
      args?: Subset<T, TenantDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TenantDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantDocumentAggregateArgs>(args: Subset<T, TenantDocumentAggregateArgs>): Prisma.PrismaPromise<GetTenantDocumentAggregateType<T>>

    /**
     * Group by TenantDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantDocumentGroupByArgs['orderBy'] }
        : { orderBy?: TenantDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TenantDocument model
   */
  readonly fields: TenantDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TenantDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TenantDocument model
   */
  interface TenantDocumentFieldRefs {
    readonly id: FieldRef<"TenantDocument", 'String'>
    readonly tenantId: FieldRef<"TenantDocument", 'String'>
    readonly documentType: FieldRef<"TenantDocument", 'TenantDocumentType'>
    readonly documentUrl: FieldRef<"TenantDocument", 'String'>
    readonly createdAt: FieldRef<"TenantDocument", 'DateTime'>
    readonly updatedAt: FieldRef<"TenantDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TenantDocument findUnique
   */
  export type TenantDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantDocument
     */
    select?: TenantDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantDocument
     */
    omit?: TenantDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantDocumentInclude<ExtArgs> | null
    /**
     * Filter, which TenantDocument to fetch.
     */
    where: TenantDocumentWhereUniqueInput
  }

  /**
   * TenantDocument findUniqueOrThrow
   */
  export type TenantDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantDocument
     */
    select?: TenantDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantDocument
     */
    omit?: TenantDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantDocumentInclude<ExtArgs> | null
    /**
     * Filter, which TenantDocument to fetch.
     */
    where: TenantDocumentWhereUniqueInput
  }

  /**
   * TenantDocument findFirst
   */
  export type TenantDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantDocument
     */
    select?: TenantDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantDocument
     */
    omit?: TenantDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantDocumentInclude<ExtArgs> | null
    /**
     * Filter, which TenantDocument to fetch.
     */
    where?: TenantDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantDocuments to fetch.
     */
    orderBy?: TenantDocumentOrderByWithRelationInput | TenantDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantDocuments.
     */
    cursor?: TenantDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantDocuments.
     */
    distinct?: TenantDocumentScalarFieldEnum | TenantDocumentScalarFieldEnum[]
  }

  /**
   * TenantDocument findFirstOrThrow
   */
  export type TenantDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantDocument
     */
    select?: TenantDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantDocument
     */
    omit?: TenantDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantDocumentInclude<ExtArgs> | null
    /**
     * Filter, which TenantDocument to fetch.
     */
    where?: TenantDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantDocuments to fetch.
     */
    orderBy?: TenantDocumentOrderByWithRelationInput | TenantDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantDocuments.
     */
    cursor?: TenantDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantDocuments.
     */
    distinct?: TenantDocumentScalarFieldEnum | TenantDocumentScalarFieldEnum[]
  }

  /**
   * TenantDocument findMany
   */
  export type TenantDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantDocument
     */
    select?: TenantDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantDocument
     */
    omit?: TenantDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantDocumentInclude<ExtArgs> | null
    /**
     * Filter, which TenantDocuments to fetch.
     */
    where?: TenantDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantDocuments to fetch.
     */
    orderBy?: TenantDocumentOrderByWithRelationInput | TenantDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TenantDocuments.
     */
    cursor?: TenantDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantDocuments.
     */
    skip?: number
    distinct?: TenantDocumentScalarFieldEnum | TenantDocumentScalarFieldEnum[]
  }

  /**
   * TenantDocument create
   */
  export type TenantDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantDocument
     */
    select?: TenantDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantDocument
     */
    omit?: TenantDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a TenantDocument.
     */
    data: XOR<TenantDocumentCreateInput, TenantDocumentUncheckedCreateInput>
  }

  /**
   * TenantDocument createMany
   */
  export type TenantDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TenantDocuments.
     */
    data: TenantDocumentCreateManyInput | TenantDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TenantDocument createManyAndReturn
   */
  export type TenantDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantDocument
     */
    select?: TenantDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TenantDocument
     */
    omit?: TenantDocumentOmit<ExtArgs> | null
    /**
     * The data used to create many TenantDocuments.
     */
    data: TenantDocumentCreateManyInput | TenantDocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantDocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenantDocument update
   */
  export type TenantDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantDocument
     */
    select?: TenantDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantDocument
     */
    omit?: TenantDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a TenantDocument.
     */
    data: XOR<TenantDocumentUpdateInput, TenantDocumentUncheckedUpdateInput>
    /**
     * Choose, which TenantDocument to update.
     */
    where: TenantDocumentWhereUniqueInput
  }

  /**
   * TenantDocument updateMany
   */
  export type TenantDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TenantDocuments.
     */
    data: XOR<TenantDocumentUpdateManyMutationInput, TenantDocumentUncheckedUpdateManyInput>
    /**
     * Filter which TenantDocuments to update
     */
    where?: TenantDocumentWhereInput
    /**
     * Limit how many TenantDocuments to update.
     */
    limit?: number
  }

  /**
   * TenantDocument updateManyAndReturn
   */
  export type TenantDocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantDocument
     */
    select?: TenantDocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TenantDocument
     */
    omit?: TenantDocumentOmit<ExtArgs> | null
    /**
     * The data used to update TenantDocuments.
     */
    data: XOR<TenantDocumentUpdateManyMutationInput, TenantDocumentUncheckedUpdateManyInput>
    /**
     * Filter which TenantDocuments to update
     */
    where?: TenantDocumentWhereInput
    /**
     * Limit how many TenantDocuments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantDocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenantDocument upsert
   */
  export type TenantDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantDocument
     */
    select?: TenantDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantDocument
     */
    omit?: TenantDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the TenantDocument to update in case it exists.
     */
    where: TenantDocumentWhereUniqueInput
    /**
     * In case the TenantDocument found by the `where` argument doesn't exist, create a new TenantDocument with this data.
     */
    create: XOR<TenantDocumentCreateInput, TenantDocumentUncheckedCreateInput>
    /**
     * In case the TenantDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantDocumentUpdateInput, TenantDocumentUncheckedUpdateInput>
  }

  /**
   * TenantDocument delete
   */
  export type TenantDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantDocument
     */
    select?: TenantDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantDocument
     */
    omit?: TenantDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantDocumentInclude<ExtArgs> | null
    /**
     * Filter which TenantDocument to delete.
     */
    where: TenantDocumentWhereUniqueInput
  }

  /**
   * TenantDocument deleteMany
   */
  export type TenantDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantDocuments to delete
     */
    where?: TenantDocumentWhereInput
    /**
     * Limit how many TenantDocuments to delete.
     */
    limit?: number
  }

  /**
   * TenantDocument without action
   */
  export type TenantDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantDocument
     */
    select?: TenantDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantDocument
     */
    omit?: TenantDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantDocumentInclude<ExtArgs> | null
  }


  /**
   * Model LeaseDocument
   */

  export type AggregateLeaseDocument = {
    _count: LeaseDocumentCountAggregateOutputType | null
    _min: LeaseDocumentMinAggregateOutputType | null
    _max: LeaseDocumentMaxAggregateOutputType | null
  }

  export type LeaseDocumentMinAggregateOutputType = {
    id: string | null
    leaseId: string | null
    documentType: $Enums.DocumentType | null
    documentUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeaseDocumentMaxAggregateOutputType = {
    id: string | null
    leaseId: string | null
    documentType: $Enums.DocumentType | null
    documentUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeaseDocumentCountAggregateOutputType = {
    id: number
    leaseId: number
    documentType: number
    documentUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LeaseDocumentMinAggregateInputType = {
    id?: true
    leaseId?: true
    documentType?: true
    documentUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeaseDocumentMaxAggregateInputType = {
    id?: true
    leaseId?: true
    documentType?: true
    documentUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeaseDocumentCountAggregateInputType = {
    id?: true
    leaseId?: true
    documentType?: true
    documentUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LeaseDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaseDocument to aggregate.
     */
    where?: LeaseDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaseDocuments to fetch.
     */
    orderBy?: LeaseDocumentOrderByWithRelationInput | LeaseDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaseDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaseDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaseDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeaseDocuments
    **/
    _count?: true | LeaseDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaseDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaseDocumentMaxAggregateInputType
  }

  export type GetLeaseDocumentAggregateType<T extends LeaseDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateLeaseDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeaseDocument[P]>
      : GetScalarType<T[P], AggregateLeaseDocument[P]>
  }




  export type LeaseDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaseDocumentWhereInput
    orderBy?: LeaseDocumentOrderByWithAggregationInput | LeaseDocumentOrderByWithAggregationInput[]
    by: LeaseDocumentScalarFieldEnum[] | LeaseDocumentScalarFieldEnum
    having?: LeaseDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaseDocumentCountAggregateInputType | true
    _min?: LeaseDocumentMinAggregateInputType
    _max?: LeaseDocumentMaxAggregateInputType
  }

  export type LeaseDocumentGroupByOutputType = {
    id: string
    leaseId: string
    documentType: $Enums.DocumentType
    documentUrl: string
    createdAt: Date
    updatedAt: Date
    _count: LeaseDocumentCountAggregateOutputType | null
    _min: LeaseDocumentMinAggregateOutputType | null
    _max: LeaseDocumentMaxAggregateOutputType | null
  }

  type GetLeaseDocumentGroupByPayload<T extends LeaseDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaseDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaseDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaseDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], LeaseDocumentGroupByOutputType[P]>
        }
      >
    >


  export type LeaseDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leaseId?: boolean
    documentType?: boolean
    documentUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lease?: boolean | LeaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaseDocument"]>

  export type LeaseDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leaseId?: boolean
    documentType?: boolean
    documentUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lease?: boolean | LeaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaseDocument"]>

  export type LeaseDocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leaseId?: boolean
    documentType?: boolean
    documentUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lease?: boolean | LeaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaseDocument"]>

  export type LeaseDocumentSelectScalar = {
    id?: boolean
    leaseId?: boolean
    documentType?: boolean
    documentUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LeaseDocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "leaseId" | "documentType" | "documentUrl" | "createdAt" | "updatedAt", ExtArgs["result"]["leaseDocument"]>
  export type LeaseDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lease?: boolean | LeaseDefaultArgs<ExtArgs>
  }
  export type LeaseDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lease?: boolean | LeaseDefaultArgs<ExtArgs>
  }
  export type LeaseDocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lease?: boolean | LeaseDefaultArgs<ExtArgs>
  }

  export type $LeaseDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeaseDocument"
    objects: {
      lease: Prisma.$LeasePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      leaseId: string
      documentType: $Enums.DocumentType
      documentUrl: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["leaseDocument"]>
    composites: {}
  }

  type LeaseDocumentGetPayload<S extends boolean | null | undefined | LeaseDocumentDefaultArgs> = $Result.GetResult<Prisma.$LeaseDocumentPayload, S>

  type LeaseDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeaseDocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeaseDocumentCountAggregateInputType | true
    }

  export interface LeaseDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeaseDocument'], meta: { name: 'LeaseDocument' } }
    /**
     * Find zero or one LeaseDocument that matches the filter.
     * @param {LeaseDocumentFindUniqueArgs} args - Arguments to find a LeaseDocument
     * @example
     * // Get one LeaseDocument
     * const leaseDocument = await prisma.leaseDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeaseDocumentFindUniqueArgs>(args: SelectSubset<T, LeaseDocumentFindUniqueArgs<ExtArgs>>): Prisma__LeaseDocumentClient<$Result.GetResult<Prisma.$LeaseDocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LeaseDocument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeaseDocumentFindUniqueOrThrowArgs} args - Arguments to find a LeaseDocument
     * @example
     * // Get one LeaseDocument
     * const leaseDocument = await prisma.leaseDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeaseDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, LeaseDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeaseDocumentClient<$Result.GetResult<Prisma.$LeaseDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeaseDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaseDocumentFindFirstArgs} args - Arguments to find a LeaseDocument
     * @example
     * // Get one LeaseDocument
     * const leaseDocument = await prisma.leaseDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeaseDocumentFindFirstArgs>(args?: SelectSubset<T, LeaseDocumentFindFirstArgs<ExtArgs>>): Prisma__LeaseDocumentClient<$Result.GetResult<Prisma.$LeaseDocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeaseDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaseDocumentFindFirstOrThrowArgs} args - Arguments to find a LeaseDocument
     * @example
     * // Get one LeaseDocument
     * const leaseDocument = await prisma.leaseDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeaseDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, LeaseDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeaseDocumentClient<$Result.GetResult<Prisma.$LeaseDocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LeaseDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaseDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeaseDocuments
     * const leaseDocuments = await prisma.leaseDocument.findMany()
     * 
     * // Get first 10 LeaseDocuments
     * const leaseDocuments = await prisma.leaseDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaseDocumentWithIdOnly = await prisma.leaseDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeaseDocumentFindManyArgs>(args?: SelectSubset<T, LeaseDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaseDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LeaseDocument.
     * @param {LeaseDocumentCreateArgs} args - Arguments to create a LeaseDocument.
     * @example
     * // Create one LeaseDocument
     * const LeaseDocument = await prisma.leaseDocument.create({
     *   data: {
     *     // ... data to create a LeaseDocument
     *   }
     * })
     * 
     */
    create<T extends LeaseDocumentCreateArgs>(args: SelectSubset<T, LeaseDocumentCreateArgs<ExtArgs>>): Prisma__LeaseDocumentClient<$Result.GetResult<Prisma.$LeaseDocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LeaseDocuments.
     * @param {LeaseDocumentCreateManyArgs} args - Arguments to create many LeaseDocuments.
     * @example
     * // Create many LeaseDocuments
     * const leaseDocument = await prisma.leaseDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeaseDocumentCreateManyArgs>(args?: SelectSubset<T, LeaseDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LeaseDocuments and returns the data saved in the database.
     * @param {LeaseDocumentCreateManyAndReturnArgs} args - Arguments to create many LeaseDocuments.
     * @example
     * // Create many LeaseDocuments
     * const leaseDocument = await prisma.leaseDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LeaseDocuments and only return the `id`
     * const leaseDocumentWithIdOnly = await prisma.leaseDocument.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeaseDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, LeaseDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaseDocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LeaseDocument.
     * @param {LeaseDocumentDeleteArgs} args - Arguments to delete one LeaseDocument.
     * @example
     * // Delete one LeaseDocument
     * const LeaseDocument = await prisma.leaseDocument.delete({
     *   where: {
     *     // ... filter to delete one LeaseDocument
     *   }
     * })
     * 
     */
    delete<T extends LeaseDocumentDeleteArgs>(args: SelectSubset<T, LeaseDocumentDeleteArgs<ExtArgs>>): Prisma__LeaseDocumentClient<$Result.GetResult<Prisma.$LeaseDocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LeaseDocument.
     * @param {LeaseDocumentUpdateArgs} args - Arguments to update one LeaseDocument.
     * @example
     * // Update one LeaseDocument
     * const leaseDocument = await prisma.leaseDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeaseDocumentUpdateArgs>(args: SelectSubset<T, LeaseDocumentUpdateArgs<ExtArgs>>): Prisma__LeaseDocumentClient<$Result.GetResult<Prisma.$LeaseDocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LeaseDocuments.
     * @param {LeaseDocumentDeleteManyArgs} args - Arguments to filter LeaseDocuments to delete.
     * @example
     * // Delete a few LeaseDocuments
     * const { count } = await prisma.leaseDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeaseDocumentDeleteManyArgs>(args?: SelectSubset<T, LeaseDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeaseDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaseDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeaseDocuments
     * const leaseDocument = await prisma.leaseDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeaseDocumentUpdateManyArgs>(args: SelectSubset<T, LeaseDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeaseDocuments and returns the data updated in the database.
     * @param {LeaseDocumentUpdateManyAndReturnArgs} args - Arguments to update many LeaseDocuments.
     * @example
     * // Update many LeaseDocuments
     * const leaseDocument = await prisma.leaseDocument.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LeaseDocuments and only return the `id`
     * const leaseDocumentWithIdOnly = await prisma.leaseDocument.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeaseDocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, LeaseDocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaseDocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LeaseDocument.
     * @param {LeaseDocumentUpsertArgs} args - Arguments to update or create a LeaseDocument.
     * @example
     * // Update or create a LeaseDocument
     * const leaseDocument = await prisma.leaseDocument.upsert({
     *   create: {
     *     // ... data to create a LeaseDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeaseDocument we want to update
     *   }
     * })
     */
    upsert<T extends LeaseDocumentUpsertArgs>(args: SelectSubset<T, LeaseDocumentUpsertArgs<ExtArgs>>): Prisma__LeaseDocumentClient<$Result.GetResult<Prisma.$LeaseDocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LeaseDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaseDocumentCountArgs} args - Arguments to filter LeaseDocuments to count.
     * @example
     * // Count the number of LeaseDocuments
     * const count = await prisma.leaseDocument.count({
     *   where: {
     *     // ... the filter for the LeaseDocuments we want to count
     *   }
     * })
    **/
    count<T extends LeaseDocumentCountArgs>(
      args?: Subset<T, LeaseDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaseDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeaseDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaseDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaseDocumentAggregateArgs>(args: Subset<T, LeaseDocumentAggregateArgs>): Prisma.PrismaPromise<GetLeaseDocumentAggregateType<T>>

    /**
     * Group by LeaseDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaseDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaseDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaseDocumentGroupByArgs['orderBy'] }
        : { orderBy?: LeaseDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaseDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaseDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeaseDocument model
   */
  readonly fields: LeaseDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeaseDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaseDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lease<T extends LeaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LeaseDefaultArgs<ExtArgs>>): Prisma__LeaseClient<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LeaseDocument model
   */
  interface LeaseDocumentFieldRefs {
    readonly id: FieldRef<"LeaseDocument", 'String'>
    readonly leaseId: FieldRef<"LeaseDocument", 'String'>
    readonly documentType: FieldRef<"LeaseDocument", 'DocumentType'>
    readonly documentUrl: FieldRef<"LeaseDocument", 'String'>
    readonly createdAt: FieldRef<"LeaseDocument", 'DateTime'>
    readonly updatedAt: FieldRef<"LeaseDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LeaseDocument findUnique
   */
  export type LeaseDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaseDocument
     */
    select?: LeaseDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaseDocument
     */
    omit?: LeaseDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseDocumentInclude<ExtArgs> | null
    /**
     * Filter, which LeaseDocument to fetch.
     */
    where: LeaseDocumentWhereUniqueInput
  }

  /**
   * LeaseDocument findUniqueOrThrow
   */
  export type LeaseDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaseDocument
     */
    select?: LeaseDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaseDocument
     */
    omit?: LeaseDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseDocumentInclude<ExtArgs> | null
    /**
     * Filter, which LeaseDocument to fetch.
     */
    where: LeaseDocumentWhereUniqueInput
  }

  /**
   * LeaseDocument findFirst
   */
  export type LeaseDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaseDocument
     */
    select?: LeaseDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaseDocument
     */
    omit?: LeaseDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseDocumentInclude<ExtArgs> | null
    /**
     * Filter, which LeaseDocument to fetch.
     */
    where?: LeaseDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaseDocuments to fetch.
     */
    orderBy?: LeaseDocumentOrderByWithRelationInput | LeaseDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaseDocuments.
     */
    cursor?: LeaseDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaseDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaseDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaseDocuments.
     */
    distinct?: LeaseDocumentScalarFieldEnum | LeaseDocumentScalarFieldEnum[]
  }

  /**
   * LeaseDocument findFirstOrThrow
   */
  export type LeaseDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaseDocument
     */
    select?: LeaseDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaseDocument
     */
    omit?: LeaseDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseDocumentInclude<ExtArgs> | null
    /**
     * Filter, which LeaseDocument to fetch.
     */
    where?: LeaseDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaseDocuments to fetch.
     */
    orderBy?: LeaseDocumentOrderByWithRelationInput | LeaseDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaseDocuments.
     */
    cursor?: LeaseDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaseDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaseDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaseDocuments.
     */
    distinct?: LeaseDocumentScalarFieldEnum | LeaseDocumentScalarFieldEnum[]
  }

  /**
   * LeaseDocument findMany
   */
  export type LeaseDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaseDocument
     */
    select?: LeaseDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaseDocument
     */
    omit?: LeaseDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseDocumentInclude<ExtArgs> | null
    /**
     * Filter, which LeaseDocuments to fetch.
     */
    where?: LeaseDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaseDocuments to fetch.
     */
    orderBy?: LeaseDocumentOrderByWithRelationInput | LeaseDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeaseDocuments.
     */
    cursor?: LeaseDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaseDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaseDocuments.
     */
    skip?: number
    distinct?: LeaseDocumentScalarFieldEnum | LeaseDocumentScalarFieldEnum[]
  }

  /**
   * LeaseDocument create
   */
  export type LeaseDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaseDocument
     */
    select?: LeaseDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaseDocument
     */
    omit?: LeaseDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a LeaseDocument.
     */
    data: XOR<LeaseDocumentCreateInput, LeaseDocumentUncheckedCreateInput>
  }

  /**
   * LeaseDocument createMany
   */
  export type LeaseDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LeaseDocuments.
     */
    data: LeaseDocumentCreateManyInput | LeaseDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeaseDocument createManyAndReturn
   */
  export type LeaseDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaseDocument
     */
    select?: LeaseDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeaseDocument
     */
    omit?: LeaseDocumentOmit<ExtArgs> | null
    /**
     * The data used to create many LeaseDocuments.
     */
    data: LeaseDocumentCreateManyInput | LeaseDocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseDocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeaseDocument update
   */
  export type LeaseDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaseDocument
     */
    select?: LeaseDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaseDocument
     */
    omit?: LeaseDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a LeaseDocument.
     */
    data: XOR<LeaseDocumentUpdateInput, LeaseDocumentUncheckedUpdateInput>
    /**
     * Choose, which LeaseDocument to update.
     */
    where: LeaseDocumentWhereUniqueInput
  }

  /**
   * LeaseDocument updateMany
   */
  export type LeaseDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeaseDocuments.
     */
    data: XOR<LeaseDocumentUpdateManyMutationInput, LeaseDocumentUncheckedUpdateManyInput>
    /**
     * Filter which LeaseDocuments to update
     */
    where?: LeaseDocumentWhereInput
    /**
     * Limit how many LeaseDocuments to update.
     */
    limit?: number
  }

  /**
   * LeaseDocument updateManyAndReturn
   */
  export type LeaseDocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaseDocument
     */
    select?: LeaseDocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeaseDocument
     */
    omit?: LeaseDocumentOmit<ExtArgs> | null
    /**
     * The data used to update LeaseDocuments.
     */
    data: XOR<LeaseDocumentUpdateManyMutationInput, LeaseDocumentUncheckedUpdateManyInput>
    /**
     * Filter which LeaseDocuments to update
     */
    where?: LeaseDocumentWhereInput
    /**
     * Limit how many LeaseDocuments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseDocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeaseDocument upsert
   */
  export type LeaseDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaseDocument
     */
    select?: LeaseDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaseDocument
     */
    omit?: LeaseDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the LeaseDocument to update in case it exists.
     */
    where: LeaseDocumentWhereUniqueInput
    /**
     * In case the LeaseDocument found by the `where` argument doesn't exist, create a new LeaseDocument with this data.
     */
    create: XOR<LeaseDocumentCreateInput, LeaseDocumentUncheckedCreateInput>
    /**
     * In case the LeaseDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaseDocumentUpdateInput, LeaseDocumentUncheckedUpdateInput>
  }

  /**
   * LeaseDocument delete
   */
  export type LeaseDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaseDocument
     */
    select?: LeaseDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaseDocument
     */
    omit?: LeaseDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseDocumentInclude<ExtArgs> | null
    /**
     * Filter which LeaseDocument to delete.
     */
    where: LeaseDocumentWhereUniqueInput
  }

  /**
   * LeaseDocument deleteMany
   */
  export type LeaseDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaseDocuments to delete
     */
    where?: LeaseDocumentWhereInput
    /**
     * Limit how many LeaseDocuments to delete.
     */
    limit?: number
  }

  /**
   * LeaseDocument without action
   */
  export type LeaseDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaseDocument
     */
    select?: LeaseDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaseDocument
     */
    omit?: LeaseDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseDocumentInclude<ExtArgs> | null
  }


  /**
   * Model PropertyDocument
   */

  export type AggregatePropertyDocument = {
    _count: PropertyDocumentCountAggregateOutputType | null
    _min: PropertyDocumentMinAggregateOutputType | null
    _max: PropertyDocumentMaxAggregateOutputType | null
  }

  export type PropertyDocumentMinAggregateOutputType = {
    id: string | null
    propertyId: string | null
    documentType: $Enums.DocumentType | null
    documentUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertyDocumentMaxAggregateOutputType = {
    id: string | null
    propertyId: string | null
    documentType: $Enums.DocumentType | null
    documentUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertyDocumentCountAggregateOutputType = {
    id: number
    propertyId: number
    documentType: number
    documentUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PropertyDocumentMinAggregateInputType = {
    id?: true
    propertyId?: true
    documentType?: true
    documentUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertyDocumentMaxAggregateInputType = {
    id?: true
    propertyId?: true
    documentType?: true
    documentUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertyDocumentCountAggregateInputType = {
    id?: true
    propertyId?: true
    documentType?: true
    documentUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PropertyDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyDocument to aggregate.
     */
    where?: PropertyDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyDocuments to fetch.
     */
    orderBy?: PropertyDocumentOrderByWithRelationInput | PropertyDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyDocuments
    **/
    _count?: true | PropertyDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyDocumentMaxAggregateInputType
  }

  export type GetPropertyDocumentAggregateType<T extends PropertyDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyDocument[P]>
      : GetScalarType<T[P], AggregatePropertyDocument[P]>
  }




  export type PropertyDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyDocumentWhereInput
    orderBy?: PropertyDocumentOrderByWithAggregationInput | PropertyDocumentOrderByWithAggregationInput[]
    by: PropertyDocumentScalarFieldEnum[] | PropertyDocumentScalarFieldEnum
    having?: PropertyDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyDocumentCountAggregateInputType | true
    _min?: PropertyDocumentMinAggregateInputType
    _max?: PropertyDocumentMaxAggregateInputType
  }

  export type PropertyDocumentGroupByOutputType = {
    id: string
    propertyId: string
    documentType: $Enums.DocumentType
    documentUrl: string
    createdAt: Date
    updatedAt: Date
    _count: PropertyDocumentCountAggregateOutputType | null
    _min: PropertyDocumentMinAggregateOutputType | null
    _max: PropertyDocumentMaxAggregateOutputType | null
  }

  type GetPropertyDocumentGroupByPayload<T extends PropertyDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyDocumentGroupByOutputType[P]>
        }
      >
    >


  export type PropertyDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    documentType?: boolean
    documentUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyDocument"]>

  export type PropertyDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    documentType?: boolean
    documentUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyDocument"]>

  export type PropertyDocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    documentType?: boolean
    documentUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyDocument"]>

  export type PropertyDocumentSelectScalar = {
    id?: boolean
    propertyId?: boolean
    documentType?: boolean
    documentUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PropertyDocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "propertyId" | "documentType" | "documentUrl" | "createdAt" | "updatedAt", ExtArgs["result"]["propertyDocument"]>
  export type PropertyDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type PropertyDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type PropertyDocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }

  export type $PropertyDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyDocument"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      propertyId: string
      documentType: $Enums.DocumentType
      documentUrl: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["propertyDocument"]>
    composites: {}
  }

  type PropertyDocumentGetPayload<S extends boolean | null | undefined | PropertyDocumentDefaultArgs> = $Result.GetResult<Prisma.$PropertyDocumentPayload, S>

  type PropertyDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyDocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PropertyDocumentCountAggregateInputType | true
    }

  export interface PropertyDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyDocument'], meta: { name: 'PropertyDocument' } }
    /**
     * Find zero or one PropertyDocument that matches the filter.
     * @param {PropertyDocumentFindUniqueArgs} args - Arguments to find a PropertyDocument
     * @example
     * // Get one PropertyDocument
     * const propertyDocument = await prisma.propertyDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyDocumentFindUniqueArgs>(args: SelectSubset<T, PropertyDocumentFindUniqueArgs<ExtArgs>>): Prisma__PropertyDocumentClient<$Result.GetResult<Prisma.$PropertyDocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PropertyDocument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyDocumentFindUniqueOrThrowArgs} args - Arguments to find a PropertyDocument
     * @example
     * // Get one PropertyDocument
     * const propertyDocument = await prisma.propertyDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyDocumentClient<$Result.GetResult<Prisma.$PropertyDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyDocumentFindFirstArgs} args - Arguments to find a PropertyDocument
     * @example
     * // Get one PropertyDocument
     * const propertyDocument = await prisma.propertyDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyDocumentFindFirstArgs>(args?: SelectSubset<T, PropertyDocumentFindFirstArgs<ExtArgs>>): Prisma__PropertyDocumentClient<$Result.GetResult<Prisma.$PropertyDocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyDocumentFindFirstOrThrowArgs} args - Arguments to find a PropertyDocument
     * @example
     * // Get one PropertyDocument
     * const propertyDocument = await prisma.propertyDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyDocumentClient<$Result.GetResult<Prisma.$PropertyDocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PropertyDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyDocuments
     * const propertyDocuments = await prisma.propertyDocument.findMany()
     * 
     * // Get first 10 PropertyDocuments
     * const propertyDocuments = await prisma.propertyDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyDocumentWithIdOnly = await prisma.propertyDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyDocumentFindManyArgs>(args?: SelectSubset<T, PropertyDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PropertyDocument.
     * @param {PropertyDocumentCreateArgs} args - Arguments to create a PropertyDocument.
     * @example
     * // Create one PropertyDocument
     * const PropertyDocument = await prisma.propertyDocument.create({
     *   data: {
     *     // ... data to create a PropertyDocument
     *   }
     * })
     * 
     */
    create<T extends PropertyDocumentCreateArgs>(args: SelectSubset<T, PropertyDocumentCreateArgs<ExtArgs>>): Prisma__PropertyDocumentClient<$Result.GetResult<Prisma.$PropertyDocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PropertyDocuments.
     * @param {PropertyDocumentCreateManyArgs} args - Arguments to create many PropertyDocuments.
     * @example
     * // Create many PropertyDocuments
     * const propertyDocument = await prisma.propertyDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyDocumentCreateManyArgs>(args?: SelectSubset<T, PropertyDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PropertyDocuments and returns the data saved in the database.
     * @param {PropertyDocumentCreateManyAndReturnArgs} args - Arguments to create many PropertyDocuments.
     * @example
     * // Create many PropertyDocuments
     * const propertyDocument = await prisma.propertyDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PropertyDocuments and only return the `id`
     * const propertyDocumentWithIdOnly = await prisma.propertyDocument.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyDocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PropertyDocument.
     * @param {PropertyDocumentDeleteArgs} args - Arguments to delete one PropertyDocument.
     * @example
     * // Delete one PropertyDocument
     * const PropertyDocument = await prisma.propertyDocument.delete({
     *   where: {
     *     // ... filter to delete one PropertyDocument
     *   }
     * })
     * 
     */
    delete<T extends PropertyDocumentDeleteArgs>(args: SelectSubset<T, PropertyDocumentDeleteArgs<ExtArgs>>): Prisma__PropertyDocumentClient<$Result.GetResult<Prisma.$PropertyDocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PropertyDocument.
     * @param {PropertyDocumentUpdateArgs} args - Arguments to update one PropertyDocument.
     * @example
     * // Update one PropertyDocument
     * const propertyDocument = await prisma.propertyDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyDocumentUpdateArgs>(args: SelectSubset<T, PropertyDocumentUpdateArgs<ExtArgs>>): Prisma__PropertyDocumentClient<$Result.GetResult<Prisma.$PropertyDocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PropertyDocuments.
     * @param {PropertyDocumentDeleteManyArgs} args - Arguments to filter PropertyDocuments to delete.
     * @example
     * // Delete a few PropertyDocuments
     * const { count } = await prisma.propertyDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyDocumentDeleteManyArgs>(args?: SelectSubset<T, PropertyDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyDocuments
     * const propertyDocument = await prisma.propertyDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyDocumentUpdateManyArgs>(args: SelectSubset<T, PropertyDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyDocuments and returns the data updated in the database.
     * @param {PropertyDocumentUpdateManyAndReturnArgs} args - Arguments to update many PropertyDocuments.
     * @example
     * // Update many PropertyDocuments
     * const propertyDocument = await prisma.propertyDocument.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PropertyDocuments and only return the `id`
     * const propertyDocumentWithIdOnly = await prisma.propertyDocument.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertyDocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertyDocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyDocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PropertyDocument.
     * @param {PropertyDocumentUpsertArgs} args - Arguments to update or create a PropertyDocument.
     * @example
     * // Update or create a PropertyDocument
     * const propertyDocument = await prisma.propertyDocument.upsert({
     *   create: {
     *     // ... data to create a PropertyDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyDocument we want to update
     *   }
     * })
     */
    upsert<T extends PropertyDocumentUpsertArgs>(args: SelectSubset<T, PropertyDocumentUpsertArgs<ExtArgs>>): Prisma__PropertyDocumentClient<$Result.GetResult<Prisma.$PropertyDocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PropertyDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyDocumentCountArgs} args - Arguments to filter PropertyDocuments to count.
     * @example
     * // Count the number of PropertyDocuments
     * const count = await prisma.propertyDocument.count({
     *   where: {
     *     // ... the filter for the PropertyDocuments we want to count
     *   }
     * })
    **/
    count<T extends PropertyDocumentCountArgs>(
      args?: Subset<T, PropertyDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyDocumentAggregateArgs>(args: Subset<T, PropertyDocumentAggregateArgs>): Prisma.PrismaPromise<GetPropertyDocumentAggregateType<T>>

    /**
     * Group by PropertyDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyDocumentGroupByArgs['orderBy'] }
        : { orderBy?: PropertyDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyDocument model
   */
  readonly fields: PropertyDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertyDocument model
   */
  interface PropertyDocumentFieldRefs {
    readonly id: FieldRef<"PropertyDocument", 'String'>
    readonly propertyId: FieldRef<"PropertyDocument", 'String'>
    readonly documentType: FieldRef<"PropertyDocument", 'DocumentType'>
    readonly documentUrl: FieldRef<"PropertyDocument", 'String'>
    readonly createdAt: FieldRef<"PropertyDocument", 'DateTime'>
    readonly updatedAt: FieldRef<"PropertyDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PropertyDocument findUnique
   */
  export type PropertyDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyDocument
     */
    select?: PropertyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyDocument
     */
    omit?: PropertyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyDocumentInclude<ExtArgs> | null
    /**
     * Filter, which PropertyDocument to fetch.
     */
    where: PropertyDocumentWhereUniqueInput
  }

  /**
   * PropertyDocument findUniqueOrThrow
   */
  export type PropertyDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyDocument
     */
    select?: PropertyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyDocument
     */
    omit?: PropertyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyDocumentInclude<ExtArgs> | null
    /**
     * Filter, which PropertyDocument to fetch.
     */
    where: PropertyDocumentWhereUniqueInput
  }

  /**
   * PropertyDocument findFirst
   */
  export type PropertyDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyDocument
     */
    select?: PropertyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyDocument
     */
    omit?: PropertyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyDocumentInclude<ExtArgs> | null
    /**
     * Filter, which PropertyDocument to fetch.
     */
    where?: PropertyDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyDocuments to fetch.
     */
    orderBy?: PropertyDocumentOrderByWithRelationInput | PropertyDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyDocuments.
     */
    cursor?: PropertyDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyDocuments.
     */
    distinct?: PropertyDocumentScalarFieldEnum | PropertyDocumentScalarFieldEnum[]
  }

  /**
   * PropertyDocument findFirstOrThrow
   */
  export type PropertyDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyDocument
     */
    select?: PropertyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyDocument
     */
    omit?: PropertyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyDocumentInclude<ExtArgs> | null
    /**
     * Filter, which PropertyDocument to fetch.
     */
    where?: PropertyDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyDocuments to fetch.
     */
    orderBy?: PropertyDocumentOrderByWithRelationInput | PropertyDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyDocuments.
     */
    cursor?: PropertyDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyDocuments.
     */
    distinct?: PropertyDocumentScalarFieldEnum | PropertyDocumentScalarFieldEnum[]
  }

  /**
   * PropertyDocument findMany
   */
  export type PropertyDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyDocument
     */
    select?: PropertyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyDocument
     */
    omit?: PropertyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyDocumentInclude<ExtArgs> | null
    /**
     * Filter, which PropertyDocuments to fetch.
     */
    where?: PropertyDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyDocuments to fetch.
     */
    orderBy?: PropertyDocumentOrderByWithRelationInput | PropertyDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyDocuments.
     */
    cursor?: PropertyDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyDocuments.
     */
    skip?: number
    distinct?: PropertyDocumentScalarFieldEnum | PropertyDocumentScalarFieldEnum[]
  }

  /**
   * PropertyDocument create
   */
  export type PropertyDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyDocument
     */
    select?: PropertyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyDocument
     */
    omit?: PropertyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertyDocument.
     */
    data: XOR<PropertyDocumentCreateInput, PropertyDocumentUncheckedCreateInput>
  }

  /**
   * PropertyDocument createMany
   */
  export type PropertyDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyDocuments.
     */
    data: PropertyDocumentCreateManyInput | PropertyDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertyDocument createManyAndReturn
   */
  export type PropertyDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyDocument
     */
    select?: PropertyDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyDocument
     */
    omit?: PropertyDocumentOmit<ExtArgs> | null
    /**
     * The data used to create many PropertyDocuments.
     */
    data: PropertyDocumentCreateManyInput | PropertyDocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyDocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyDocument update
   */
  export type PropertyDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyDocument
     */
    select?: PropertyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyDocument
     */
    omit?: PropertyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertyDocument.
     */
    data: XOR<PropertyDocumentUpdateInput, PropertyDocumentUncheckedUpdateInput>
    /**
     * Choose, which PropertyDocument to update.
     */
    where: PropertyDocumentWhereUniqueInput
  }

  /**
   * PropertyDocument updateMany
   */
  export type PropertyDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyDocuments.
     */
    data: XOR<PropertyDocumentUpdateManyMutationInput, PropertyDocumentUncheckedUpdateManyInput>
    /**
     * Filter which PropertyDocuments to update
     */
    where?: PropertyDocumentWhereInput
    /**
     * Limit how many PropertyDocuments to update.
     */
    limit?: number
  }

  /**
   * PropertyDocument updateManyAndReturn
   */
  export type PropertyDocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyDocument
     */
    select?: PropertyDocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyDocument
     */
    omit?: PropertyDocumentOmit<ExtArgs> | null
    /**
     * The data used to update PropertyDocuments.
     */
    data: XOR<PropertyDocumentUpdateManyMutationInput, PropertyDocumentUncheckedUpdateManyInput>
    /**
     * Filter which PropertyDocuments to update
     */
    where?: PropertyDocumentWhereInput
    /**
     * Limit how many PropertyDocuments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyDocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyDocument upsert
   */
  export type PropertyDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyDocument
     */
    select?: PropertyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyDocument
     */
    omit?: PropertyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertyDocument to update in case it exists.
     */
    where: PropertyDocumentWhereUniqueInput
    /**
     * In case the PropertyDocument found by the `where` argument doesn't exist, create a new PropertyDocument with this data.
     */
    create: XOR<PropertyDocumentCreateInput, PropertyDocumentUncheckedCreateInput>
    /**
     * In case the PropertyDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyDocumentUpdateInput, PropertyDocumentUncheckedUpdateInput>
  }

  /**
   * PropertyDocument delete
   */
  export type PropertyDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyDocument
     */
    select?: PropertyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyDocument
     */
    omit?: PropertyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyDocumentInclude<ExtArgs> | null
    /**
     * Filter which PropertyDocument to delete.
     */
    where: PropertyDocumentWhereUniqueInput
  }

  /**
   * PropertyDocument deleteMany
   */
  export type PropertyDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyDocuments to delete
     */
    where?: PropertyDocumentWhereInput
    /**
     * Limit how many PropertyDocuments to delete.
     */
    limit?: number
  }

  /**
   * PropertyDocument without action
   */
  export type PropertyDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyDocument
     */
    select?: PropertyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyDocument
     */
    omit?: PropertyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyDocumentInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TenantScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    altEmail: 'altEmail',
    phone: 'phone',
    altPhone: 'altPhone',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TenantScalarFieldEnum = (typeof TenantScalarFieldEnum)[keyof typeof TenantScalarFieldEnum]


  export const TenantEmergencyContactScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    name: 'name',
    phone: 'phone',
    email: 'email',
    relationship: 'relationship',
    addressLine1: 'addressLine1',
    addressLine2: 'addressLine2',
    city: 'city',
    state: 'state',
    zip: 'zip',
    countryCode: 'countryCode',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TenantEmergencyContactScalarFieldEnum = (typeof TenantEmergencyContactScalarFieldEnum)[keyof typeof TenantEmergencyContactScalarFieldEnum]


  export const TenantIncomeScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    income: 'income',
    incomeType: 'incomeType',
    position: 'position',
    employer: 'employer',
    employerAddressLine1: 'employerAddressLine1',
    employerAddressLine2: 'employerAddressLine2',
    employerCity: 'employerCity',
    employerState: 'employerState',
    employerZip: 'employerZip',
    employerCountryCode: 'employerCountryCode',
    startDate: 'startDate',
    endDate: 'endDate',
    currentIncome: 'currentIncome',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TenantIncomeScalarFieldEnum = (typeof TenantIncomeScalarFieldEnum)[keyof typeof TenantIncomeScalarFieldEnum]


  export const LandlordScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    addressLine1: 'addressLine1',
    addressLine2: 'addressLine2',
    city: 'city',
    state: 'state',
    zip: 'zip',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LandlordScalarFieldEnum = (typeof LandlordScalarFieldEnum)[keyof typeof LandlordScalarFieldEnum]


  export const PropertyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    addressLine1: 'addressLine1',
    addressLine2: 'addressLine2',
    city: 'city',
    state: 'state',
    zip: 'zip',
    countryCode: 'countryCode',
    ownerId: 'ownerId',
    imageUrl: 'imageUrl',
    propertyType: 'propertyType',
    propertyStatus: 'propertyStatus',
    bedrooms: 'bedrooms',
    bathrooms: 'bathrooms',
    squareMeters: 'squareMeters',
    marketRent: 'marketRent',
    deposit: 'deposit',
    leaseTerm: 'leaseTerm',
    leaseTermType: 'leaseTermType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    sqmt: 'sqmt',
    features: 'features',
    amenities: 'amenities',
    test: 'test'
  };

  export type PropertyScalarFieldEnum = (typeof PropertyScalarFieldEnum)[keyof typeof PropertyScalarFieldEnum]


  export const UnitScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    name: 'name',
    bedrooms: 'bedrooms',
    bathrooms: 'bathrooms',
    sqmt: 'sqmt',
    marketRent: 'marketRent',
    deposit: 'deposit',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UnitScalarFieldEnum = (typeof UnitScalarFieldEnum)[keyof typeof UnitScalarFieldEnum]


  export const LeaseScalarFieldEnum: {
    id: 'id',
    unitId: 'unitId',
    tenantId: 'tenantId',
    startDate: 'startDate',
    endDate: 'endDate',
    rent: 'rent',
    deposit: 'deposit',
    rentDueCurrency: 'rentDueCurrency',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    propertyId: 'propertyId'
  };

  export type LeaseScalarFieldEnum = (typeof LeaseScalarFieldEnum)[keyof typeof LeaseScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    leaseId: 'leaseId',
    description: 'description',
    dueAmount: 'dueAmount',
    dueDate: 'dueDate',
    category: 'category',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const TransactionsScalarFieldEnum: {
    id: 'id',
    leaseId: 'leaseId',
    description: 'description',
    amountPaid: 'amountPaid',
    referenceId: 'referenceId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    invoiceId: 'invoiceId'
  };

  export type TransactionsScalarFieldEnum = (typeof TransactionsScalarFieldEnum)[keyof typeof TransactionsScalarFieldEnum]


  export const TenantLeaseScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    leaseId: 'leaseId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TenantLeaseScalarFieldEnum = (typeof TenantLeaseScalarFieldEnum)[keyof typeof TenantLeaseScalarFieldEnum]


  export const MaintenanceRequestScalarFieldEnum: {
    id: 'id',
    leaseId: 'leaseId',
    description: 'description',
    status: 'status',
    priority: 'priority',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MaintenanceRequestScalarFieldEnum = (typeof MaintenanceRequestScalarFieldEnum)[keyof typeof MaintenanceRequestScalarFieldEnum]


  export const TenantDocumentScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    documentType: 'documentType',
    documentUrl: 'documentUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TenantDocumentScalarFieldEnum = (typeof TenantDocumentScalarFieldEnum)[keyof typeof TenantDocumentScalarFieldEnum]


  export const LeaseDocumentScalarFieldEnum: {
    id: 'id',
    leaseId: 'leaseId',
    documentType: 'documentType',
    documentUrl: 'documentUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LeaseDocumentScalarFieldEnum = (typeof LeaseDocumentScalarFieldEnum)[keyof typeof LeaseDocumentScalarFieldEnum]


  export const PropertyDocumentScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    documentType: 'documentType',
    documentUrl: 'documentUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PropertyDocumentScalarFieldEnum = (typeof PropertyDocumentScalarFieldEnum)[keyof typeof PropertyDocumentScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'TenantRelationship'
   */
  export type EnumTenantRelationshipFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TenantRelationship'>
    


  /**
   * Reference to a field of type 'TenantRelationship[]'
   */
  export type ListEnumTenantRelationshipFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TenantRelationship[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'TenantIncomeType'
   */
  export type EnumTenantIncomeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TenantIncomeType'>
    


  /**
   * Reference to a field of type 'TenantIncomeType[]'
   */
  export type ListEnumTenantIncomeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TenantIncomeType[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'PropertyType'
   */
  export type EnumPropertyTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PropertyType'>
    


  /**
   * Reference to a field of type 'PropertyType[]'
   */
  export type ListEnumPropertyTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PropertyType[]'>
    


  /**
   * Reference to a field of type 'PropertyStatus'
   */
  export type EnumPropertyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PropertyStatus'>
    


  /**
   * Reference to a field of type 'PropertyStatus[]'
   */
  export type ListEnumPropertyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PropertyStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'LeaseTermType'
   */
  export type EnumLeaseTermTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaseTermType'>
    


  /**
   * Reference to a field of type 'LeaseTermType[]'
   */
  export type ListEnumLeaseTermTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaseTermType[]'>
    


  /**
   * Reference to a field of type 'LeaseStatus'
   */
  export type EnumLeaseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaseStatus'>
    


  /**
   * Reference to a field of type 'LeaseStatus[]'
   */
  export type ListEnumLeaseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaseStatus[]'>
    


  /**
   * Reference to a field of type 'InvoiceCategory'
   */
  export type EnumInvoiceCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceCategory'>
    


  /**
   * Reference to a field of type 'InvoiceCategory[]'
   */
  export type ListEnumInvoiceCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceCategory[]'>
    


  /**
   * Reference to a field of type 'InvoiceStatus'
   */
  export type EnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus'>
    


  /**
   * Reference to a field of type 'InvoiceStatus[]'
   */
  export type ListEnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus[]'>
    


  /**
   * Reference to a field of type 'MaintenanceRequestStatus'
   */
  export type EnumMaintenanceRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaintenanceRequestStatus'>
    


  /**
   * Reference to a field of type 'MaintenanceRequestStatus[]'
   */
  export type ListEnumMaintenanceRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaintenanceRequestStatus[]'>
    


  /**
   * Reference to a field of type 'MaintenanceRequestPriority'
   */
  export type EnumMaintenanceRequestPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaintenanceRequestPriority'>
    


  /**
   * Reference to a field of type 'MaintenanceRequestPriority[]'
   */
  export type ListEnumMaintenanceRequestPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaintenanceRequestPriority[]'>
    


  /**
   * Reference to a field of type 'TenantDocumentType'
   */
  export type EnumTenantDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TenantDocumentType'>
    


  /**
   * Reference to a field of type 'TenantDocumentType[]'
   */
  export type ListEnumTenantDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TenantDocumentType[]'>
    


  /**
   * Reference to a field of type 'DocumentType'
   */
  export type EnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType'>
    


  /**
   * Reference to a field of type 'DocumentType[]'
   */
  export type ListEnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType[]'>
    
  /**
   * Deep Input Types
   */


  export type TenantWhereInput = {
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    id?: StringFilter<"Tenant"> | string
    firstName?: StringFilter<"Tenant"> | string
    lastName?: StringFilter<"Tenant"> | string
    email?: StringFilter<"Tenant"> | string
    altEmail?: StringNullableFilter<"Tenant"> | string | null
    phone?: StringFilter<"Tenant"> | string
    altPhone?: StringNullableFilter<"Tenant"> | string | null
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    Lease?: LeaseListRelationFilter
    tenantLease?: TenantLeaseListRelationFilter
    tenantDocument?: TenantDocumentListRelationFilter
    tenantEmergencyContact?: TenantEmergencyContactListRelationFilter
    tenantIncome?: TenantIncomeListRelationFilter
  }

  export type TenantOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    altEmail?: SortOrderInput | SortOrder
    phone?: SortOrder
    altPhone?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Lease?: LeaseOrderByRelationAggregateInput
    tenantLease?: TenantLeaseOrderByRelationAggregateInput
    tenantDocument?: TenantDocumentOrderByRelationAggregateInput
    tenantEmergencyContact?: TenantEmergencyContactOrderByRelationAggregateInput
    tenantIncome?: TenantIncomeOrderByRelationAggregateInput
  }

  export type TenantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    firstName?: StringFilter<"Tenant"> | string
    lastName?: StringFilter<"Tenant"> | string
    email?: StringFilter<"Tenant"> | string
    altEmail?: StringNullableFilter<"Tenant"> | string | null
    phone?: StringFilter<"Tenant"> | string
    altPhone?: StringNullableFilter<"Tenant"> | string | null
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    Lease?: LeaseListRelationFilter
    tenantLease?: TenantLeaseListRelationFilter
    tenantDocument?: TenantDocumentListRelationFilter
    tenantEmergencyContact?: TenantEmergencyContactListRelationFilter
    tenantIncome?: TenantIncomeListRelationFilter
  }, "id">

  export type TenantOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    altEmail?: SortOrderInput | SortOrder
    phone?: SortOrder
    altPhone?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TenantCountOrderByAggregateInput
    _max?: TenantMaxOrderByAggregateInput
    _min?: TenantMinOrderByAggregateInput
  }

  export type TenantScalarWhereWithAggregatesInput = {
    AND?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    OR?: TenantScalarWhereWithAggregatesInput[]
    NOT?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tenant"> | string
    firstName?: StringWithAggregatesFilter<"Tenant"> | string
    lastName?: StringWithAggregatesFilter<"Tenant"> | string
    email?: StringWithAggregatesFilter<"Tenant"> | string
    altEmail?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    phone?: StringWithAggregatesFilter<"Tenant"> | string
    altPhone?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
  }

  export type TenantEmergencyContactWhereInput = {
    AND?: TenantEmergencyContactWhereInput | TenantEmergencyContactWhereInput[]
    OR?: TenantEmergencyContactWhereInput[]
    NOT?: TenantEmergencyContactWhereInput | TenantEmergencyContactWhereInput[]
    id?: StringFilter<"TenantEmergencyContact"> | string
    tenantId?: StringFilter<"TenantEmergencyContact"> | string
    name?: StringFilter<"TenantEmergencyContact"> | string
    phone?: StringFilter<"TenantEmergencyContact"> | string
    email?: StringFilter<"TenantEmergencyContact"> | string
    relationship?: EnumTenantRelationshipFilter<"TenantEmergencyContact"> | $Enums.TenantRelationship
    addressLine1?: StringFilter<"TenantEmergencyContact"> | string
    addressLine2?: StringNullableFilter<"TenantEmergencyContact"> | string | null
    city?: StringFilter<"TenantEmergencyContact"> | string
    state?: StringFilter<"TenantEmergencyContact"> | string
    zip?: StringFilter<"TenantEmergencyContact"> | string
    countryCode?: StringFilter<"TenantEmergencyContact"> | string
    createdAt?: DateTimeFilter<"TenantEmergencyContact"> | Date | string
    updatedAt?: DateTimeFilter<"TenantEmergencyContact"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type TenantEmergencyContactOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    relationship?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    countryCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type TenantEmergencyContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TenantEmergencyContactWhereInput | TenantEmergencyContactWhereInput[]
    OR?: TenantEmergencyContactWhereInput[]
    NOT?: TenantEmergencyContactWhereInput | TenantEmergencyContactWhereInput[]
    tenantId?: StringFilter<"TenantEmergencyContact"> | string
    name?: StringFilter<"TenantEmergencyContact"> | string
    phone?: StringFilter<"TenantEmergencyContact"> | string
    email?: StringFilter<"TenantEmergencyContact"> | string
    relationship?: EnumTenantRelationshipFilter<"TenantEmergencyContact"> | $Enums.TenantRelationship
    addressLine1?: StringFilter<"TenantEmergencyContact"> | string
    addressLine2?: StringNullableFilter<"TenantEmergencyContact"> | string | null
    city?: StringFilter<"TenantEmergencyContact"> | string
    state?: StringFilter<"TenantEmergencyContact"> | string
    zip?: StringFilter<"TenantEmergencyContact"> | string
    countryCode?: StringFilter<"TenantEmergencyContact"> | string
    createdAt?: DateTimeFilter<"TenantEmergencyContact"> | Date | string
    updatedAt?: DateTimeFilter<"TenantEmergencyContact"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id">

  export type TenantEmergencyContactOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    relationship?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    countryCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TenantEmergencyContactCountOrderByAggregateInput
    _max?: TenantEmergencyContactMaxOrderByAggregateInput
    _min?: TenantEmergencyContactMinOrderByAggregateInput
  }

  export type TenantEmergencyContactScalarWhereWithAggregatesInput = {
    AND?: TenantEmergencyContactScalarWhereWithAggregatesInput | TenantEmergencyContactScalarWhereWithAggregatesInput[]
    OR?: TenantEmergencyContactScalarWhereWithAggregatesInput[]
    NOT?: TenantEmergencyContactScalarWhereWithAggregatesInput | TenantEmergencyContactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TenantEmergencyContact"> | string
    tenantId?: StringWithAggregatesFilter<"TenantEmergencyContact"> | string
    name?: StringWithAggregatesFilter<"TenantEmergencyContact"> | string
    phone?: StringWithAggregatesFilter<"TenantEmergencyContact"> | string
    email?: StringWithAggregatesFilter<"TenantEmergencyContact"> | string
    relationship?: EnumTenantRelationshipWithAggregatesFilter<"TenantEmergencyContact"> | $Enums.TenantRelationship
    addressLine1?: StringWithAggregatesFilter<"TenantEmergencyContact"> | string
    addressLine2?: StringNullableWithAggregatesFilter<"TenantEmergencyContact"> | string | null
    city?: StringWithAggregatesFilter<"TenantEmergencyContact"> | string
    state?: StringWithAggregatesFilter<"TenantEmergencyContact"> | string
    zip?: StringWithAggregatesFilter<"TenantEmergencyContact"> | string
    countryCode?: StringWithAggregatesFilter<"TenantEmergencyContact"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TenantEmergencyContact"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TenantEmergencyContact"> | Date | string
  }

  export type TenantIncomeWhereInput = {
    AND?: TenantIncomeWhereInput | TenantIncomeWhereInput[]
    OR?: TenantIncomeWhereInput[]
    NOT?: TenantIncomeWhereInput | TenantIncomeWhereInput[]
    id?: StringFilter<"TenantIncome"> | string
    tenantId?: StringFilter<"TenantIncome"> | string
    income?: FloatFilter<"TenantIncome"> | number
    incomeType?: EnumTenantIncomeTypeFilter<"TenantIncome"> | $Enums.TenantIncomeType
    position?: StringNullableFilter<"TenantIncome"> | string | null
    employer?: StringNullableFilter<"TenantIncome"> | string | null
    employerAddressLine1?: StringNullableFilter<"TenantIncome"> | string | null
    employerAddressLine2?: StringNullableFilter<"TenantIncome"> | string | null
    employerCity?: StringNullableFilter<"TenantIncome"> | string | null
    employerState?: StringNullableFilter<"TenantIncome"> | string | null
    employerZip?: StringNullableFilter<"TenantIncome"> | string | null
    employerCountryCode?: StringNullableFilter<"TenantIncome"> | string | null
    startDate?: DateTimeFilter<"TenantIncome"> | Date | string
    endDate?: DateTimeFilter<"TenantIncome"> | Date | string
    currentIncome?: BoolFilter<"TenantIncome"> | boolean
    createdAt?: DateTimeFilter<"TenantIncome"> | Date | string
    updatedAt?: DateTimeFilter<"TenantIncome"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type TenantIncomeOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    income?: SortOrder
    incomeType?: SortOrder
    position?: SortOrderInput | SortOrder
    employer?: SortOrderInput | SortOrder
    employerAddressLine1?: SortOrderInput | SortOrder
    employerAddressLine2?: SortOrderInput | SortOrder
    employerCity?: SortOrderInput | SortOrder
    employerState?: SortOrderInput | SortOrder
    employerZip?: SortOrderInput | SortOrder
    employerCountryCode?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    currentIncome?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type TenantIncomeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TenantIncomeWhereInput | TenantIncomeWhereInput[]
    OR?: TenantIncomeWhereInput[]
    NOT?: TenantIncomeWhereInput | TenantIncomeWhereInput[]
    tenantId?: StringFilter<"TenantIncome"> | string
    income?: FloatFilter<"TenantIncome"> | number
    incomeType?: EnumTenantIncomeTypeFilter<"TenantIncome"> | $Enums.TenantIncomeType
    position?: StringNullableFilter<"TenantIncome"> | string | null
    employer?: StringNullableFilter<"TenantIncome"> | string | null
    employerAddressLine1?: StringNullableFilter<"TenantIncome"> | string | null
    employerAddressLine2?: StringNullableFilter<"TenantIncome"> | string | null
    employerCity?: StringNullableFilter<"TenantIncome"> | string | null
    employerState?: StringNullableFilter<"TenantIncome"> | string | null
    employerZip?: StringNullableFilter<"TenantIncome"> | string | null
    employerCountryCode?: StringNullableFilter<"TenantIncome"> | string | null
    startDate?: DateTimeFilter<"TenantIncome"> | Date | string
    endDate?: DateTimeFilter<"TenantIncome"> | Date | string
    currentIncome?: BoolFilter<"TenantIncome"> | boolean
    createdAt?: DateTimeFilter<"TenantIncome"> | Date | string
    updatedAt?: DateTimeFilter<"TenantIncome"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id">

  export type TenantIncomeOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    income?: SortOrder
    incomeType?: SortOrder
    position?: SortOrderInput | SortOrder
    employer?: SortOrderInput | SortOrder
    employerAddressLine1?: SortOrderInput | SortOrder
    employerAddressLine2?: SortOrderInput | SortOrder
    employerCity?: SortOrderInput | SortOrder
    employerState?: SortOrderInput | SortOrder
    employerZip?: SortOrderInput | SortOrder
    employerCountryCode?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    currentIncome?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TenantIncomeCountOrderByAggregateInput
    _avg?: TenantIncomeAvgOrderByAggregateInput
    _max?: TenantIncomeMaxOrderByAggregateInput
    _min?: TenantIncomeMinOrderByAggregateInput
    _sum?: TenantIncomeSumOrderByAggregateInput
  }

  export type TenantIncomeScalarWhereWithAggregatesInput = {
    AND?: TenantIncomeScalarWhereWithAggregatesInput | TenantIncomeScalarWhereWithAggregatesInput[]
    OR?: TenantIncomeScalarWhereWithAggregatesInput[]
    NOT?: TenantIncomeScalarWhereWithAggregatesInput | TenantIncomeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TenantIncome"> | string
    tenantId?: StringWithAggregatesFilter<"TenantIncome"> | string
    income?: FloatWithAggregatesFilter<"TenantIncome"> | number
    incomeType?: EnumTenantIncomeTypeWithAggregatesFilter<"TenantIncome"> | $Enums.TenantIncomeType
    position?: StringNullableWithAggregatesFilter<"TenantIncome"> | string | null
    employer?: StringNullableWithAggregatesFilter<"TenantIncome"> | string | null
    employerAddressLine1?: StringNullableWithAggregatesFilter<"TenantIncome"> | string | null
    employerAddressLine2?: StringNullableWithAggregatesFilter<"TenantIncome"> | string | null
    employerCity?: StringNullableWithAggregatesFilter<"TenantIncome"> | string | null
    employerState?: StringNullableWithAggregatesFilter<"TenantIncome"> | string | null
    employerZip?: StringNullableWithAggregatesFilter<"TenantIncome"> | string | null
    employerCountryCode?: StringNullableWithAggregatesFilter<"TenantIncome"> | string | null
    startDate?: DateTimeWithAggregatesFilter<"TenantIncome"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"TenantIncome"> | Date | string
    currentIncome?: BoolWithAggregatesFilter<"TenantIncome"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TenantIncome"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TenantIncome"> | Date | string
  }

  export type LandlordWhereInput = {
    AND?: LandlordWhereInput | LandlordWhereInput[]
    OR?: LandlordWhereInput[]
    NOT?: LandlordWhereInput | LandlordWhereInput[]
    id?: StringFilter<"Landlord"> | string
    firstName?: StringFilter<"Landlord"> | string
    lastName?: StringFilter<"Landlord"> | string
    email?: StringFilter<"Landlord"> | string
    phone?: StringFilter<"Landlord"> | string
    addressLine1?: StringFilter<"Landlord"> | string
    addressLine2?: StringNullableFilter<"Landlord"> | string | null
    city?: StringFilter<"Landlord"> | string
    state?: StringFilter<"Landlord"> | string
    zip?: StringFilter<"Landlord"> | string
    createdAt?: DateTimeFilter<"Landlord"> | Date | string
    updatedAt?: DateTimeFilter<"Landlord"> | Date | string
    property?: PropertyListRelationFilter
  }

  export type LandlordOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    property?: PropertyOrderByRelationAggregateInput
  }

  export type LandlordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LandlordWhereInput | LandlordWhereInput[]
    OR?: LandlordWhereInput[]
    NOT?: LandlordWhereInput | LandlordWhereInput[]
    firstName?: StringFilter<"Landlord"> | string
    lastName?: StringFilter<"Landlord"> | string
    email?: StringFilter<"Landlord"> | string
    phone?: StringFilter<"Landlord"> | string
    addressLine1?: StringFilter<"Landlord"> | string
    addressLine2?: StringNullableFilter<"Landlord"> | string | null
    city?: StringFilter<"Landlord"> | string
    state?: StringFilter<"Landlord"> | string
    zip?: StringFilter<"Landlord"> | string
    createdAt?: DateTimeFilter<"Landlord"> | Date | string
    updatedAt?: DateTimeFilter<"Landlord"> | Date | string
    property?: PropertyListRelationFilter
  }, "id">

  export type LandlordOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LandlordCountOrderByAggregateInput
    _max?: LandlordMaxOrderByAggregateInput
    _min?: LandlordMinOrderByAggregateInput
  }

  export type LandlordScalarWhereWithAggregatesInput = {
    AND?: LandlordScalarWhereWithAggregatesInput | LandlordScalarWhereWithAggregatesInput[]
    OR?: LandlordScalarWhereWithAggregatesInput[]
    NOT?: LandlordScalarWhereWithAggregatesInput | LandlordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Landlord"> | string
    firstName?: StringWithAggregatesFilter<"Landlord"> | string
    lastName?: StringWithAggregatesFilter<"Landlord"> | string
    email?: StringWithAggregatesFilter<"Landlord"> | string
    phone?: StringWithAggregatesFilter<"Landlord"> | string
    addressLine1?: StringWithAggregatesFilter<"Landlord"> | string
    addressLine2?: StringNullableWithAggregatesFilter<"Landlord"> | string | null
    city?: StringWithAggregatesFilter<"Landlord"> | string
    state?: StringWithAggregatesFilter<"Landlord"> | string
    zip?: StringWithAggregatesFilter<"Landlord"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Landlord"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Landlord"> | Date | string
  }

  export type PropertyWhereInput = {
    AND?: PropertyWhereInput | PropertyWhereInput[]
    OR?: PropertyWhereInput[]
    NOT?: PropertyWhereInput | PropertyWhereInput[]
    id?: StringFilter<"Property"> | string
    name?: StringFilter<"Property"> | string
    addressLine1?: StringFilter<"Property"> | string
    addressLine2?: StringNullableFilter<"Property"> | string | null
    city?: StringFilter<"Property"> | string
    state?: StringFilter<"Property"> | string
    zip?: StringFilter<"Property"> | string
    countryCode?: StringFilter<"Property"> | string
    ownerId?: StringFilter<"Property"> | string
    imageUrl?: StringNullableFilter<"Property"> | string | null
    propertyType?: EnumPropertyTypeFilter<"Property"> | $Enums.PropertyType
    propertyStatus?: EnumPropertyStatusFilter<"Property"> | $Enums.PropertyStatus
    bedrooms?: IntFilter<"Property"> | number
    bathrooms?: FloatFilter<"Property"> | number
    squareMeters?: FloatFilter<"Property"> | number
    marketRent?: FloatFilter<"Property"> | number
    deposit?: FloatFilter<"Property"> | number
    leaseTerm?: IntFilter<"Property"> | number
    leaseTermType?: EnumLeaseTermTypeFilter<"Property"> | $Enums.LeaseTermType
    createdAt?: DateTimeFilter<"Property"> | Date | string
    updatedAt?: DateTimeFilter<"Property"> | Date | string
    sqmt?: FloatFilter<"Property"> | number
    features?: StringNullableListFilter<"Property">
    amenities?: StringNullableListFilter<"Property">
    test?: StringNullableFilter<"Property"> | string | null
    owner?: XOR<LandlordScalarRelationFilter, LandlordWhereInput>
    unit?: UnitListRelationFilter
    propertyDocument?: PropertyDocumentListRelationFilter
    Lease?: LeaseListRelationFilter
  }

  export type PropertyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    countryCode?: SortOrder
    ownerId?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    propertyType?: SortOrder
    propertyStatus?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    squareMeters?: SortOrder
    marketRent?: SortOrder
    deposit?: SortOrder
    leaseTerm?: SortOrder
    leaseTermType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sqmt?: SortOrder
    features?: SortOrder
    amenities?: SortOrder
    test?: SortOrderInput | SortOrder
    owner?: LandlordOrderByWithRelationInput
    unit?: UnitOrderByRelationAggregateInput
    propertyDocument?: PropertyDocumentOrderByRelationAggregateInput
    Lease?: LeaseOrderByRelationAggregateInput
  }

  export type PropertyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PropertyWhereInput | PropertyWhereInput[]
    OR?: PropertyWhereInput[]
    NOT?: PropertyWhereInput | PropertyWhereInput[]
    name?: StringFilter<"Property"> | string
    addressLine1?: StringFilter<"Property"> | string
    addressLine2?: StringNullableFilter<"Property"> | string | null
    city?: StringFilter<"Property"> | string
    state?: StringFilter<"Property"> | string
    zip?: StringFilter<"Property"> | string
    countryCode?: StringFilter<"Property"> | string
    ownerId?: StringFilter<"Property"> | string
    imageUrl?: StringNullableFilter<"Property"> | string | null
    propertyType?: EnumPropertyTypeFilter<"Property"> | $Enums.PropertyType
    propertyStatus?: EnumPropertyStatusFilter<"Property"> | $Enums.PropertyStatus
    bedrooms?: IntFilter<"Property"> | number
    bathrooms?: FloatFilter<"Property"> | number
    squareMeters?: FloatFilter<"Property"> | number
    marketRent?: FloatFilter<"Property"> | number
    deposit?: FloatFilter<"Property"> | number
    leaseTerm?: IntFilter<"Property"> | number
    leaseTermType?: EnumLeaseTermTypeFilter<"Property"> | $Enums.LeaseTermType
    createdAt?: DateTimeFilter<"Property"> | Date | string
    updatedAt?: DateTimeFilter<"Property"> | Date | string
    sqmt?: FloatFilter<"Property"> | number
    features?: StringNullableListFilter<"Property">
    amenities?: StringNullableListFilter<"Property">
    test?: StringNullableFilter<"Property"> | string | null
    owner?: XOR<LandlordScalarRelationFilter, LandlordWhereInput>
    unit?: UnitListRelationFilter
    propertyDocument?: PropertyDocumentListRelationFilter
    Lease?: LeaseListRelationFilter
  }, "id">

  export type PropertyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    countryCode?: SortOrder
    ownerId?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    propertyType?: SortOrder
    propertyStatus?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    squareMeters?: SortOrder
    marketRent?: SortOrder
    deposit?: SortOrder
    leaseTerm?: SortOrder
    leaseTermType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sqmt?: SortOrder
    features?: SortOrder
    amenities?: SortOrder
    test?: SortOrderInput | SortOrder
    _count?: PropertyCountOrderByAggregateInput
    _avg?: PropertyAvgOrderByAggregateInput
    _max?: PropertyMaxOrderByAggregateInput
    _min?: PropertyMinOrderByAggregateInput
    _sum?: PropertySumOrderByAggregateInput
  }

  export type PropertyScalarWhereWithAggregatesInput = {
    AND?: PropertyScalarWhereWithAggregatesInput | PropertyScalarWhereWithAggregatesInput[]
    OR?: PropertyScalarWhereWithAggregatesInput[]
    NOT?: PropertyScalarWhereWithAggregatesInput | PropertyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Property"> | string
    name?: StringWithAggregatesFilter<"Property"> | string
    addressLine1?: StringWithAggregatesFilter<"Property"> | string
    addressLine2?: StringNullableWithAggregatesFilter<"Property"> | string | null
    city?: StringWithAggregatesFilter<"Property"> | string
    state?: StringWithAggregatesFilter<"Property"> | string
    zip?: StringWithAggregatesFilter<"Property"> | string
    countryCode?: StringWithAggregatesFilter<"Property"> | string
    ownerId?: StringWithAggregatesFilter<"Property"> | string
    imageUrl?: StringNullableWithAggregatesFilter<"Property"> | string | null
    propertyType?: EnumPropertyTypeWithAggregatesFilter<"Property"> | $Enums.PropertyType
    propertyStatus?: EnumPropertyStatusWithAggregatesFilter<"Property"> | $Enums.PropertyStatus
    bedrooms?: IntWithAggregatesFilter<"Property"> | number
    bathrooms?: FloatWithAggregatesFilter<"Property"> | number
    squareMeters?: FloatWithAggregatesFilter<"Property"> | number
    marketRent?: FloatWithAggregatesFilter<"Property"> | number
    deposit?: FloatWithAggregatesFilter<"Property"> | number
    leaseTerm?: IntWithAggregatesFilter<"Property"> | number
    leaseTermType?: EnumLeaseTermTypeWithAggregatesFilter<"Property"> | $Enums.LeaseTermType
    createdAt?: DateTimeWithAggregatesFilter<"Property"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Property"> | Date | string
    sqmt?: FloatWithAggregatesFilter<"Property"> | number
    features?: StringNullableListFilter<"Property">
    amenities?: StringNullableListFilter<"Property">
    test?: StringNullableWithAggregatesFilter<"Property"> | string | null
  }

  export type UnitWhereInput = {
    AND?: UnitWhereInput | UnitWhereInput[]
    OR?: UnitWhereInput[]
    NOT?: UnitWhereInput | UnitWhereInput[]
    id?: StringFilter<"Unit"> | string
    propertyId?: StringFilter<"Unit"> | string
    name?: StringFilter<"Unit"> | string
    bedrooms?: IntFilter<"Unit"> | number
    bathrooms?: FloatFilter<"Unit"> | number
    sqmt?: FloatFilter<"Unit"> | number
    marketRent?: FloatFilter<"Unit"> | number
    deposit?: FloatFilter<"Unit"> | number
    createdAt?: DateTimeFilter<"Unit"> | Date | string
    updatedAt?: DateTimeFilter<"Unit"> | Date | string
    Property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    lease?: LeaseListRelationFilter
  }

  export type UnitOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    name?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    sqmt?: SortOrder
    marketRent?: SortOrder
    deposit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Property?: PropertyOrderByWithRelationInput
    lease?: LeaseOrderByRelationAggregateInput
  }

  export type UnitWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UnitWhereInput | UnitWhereInput[]
    OR?: UnitWhereInput[]
    NOT?: UnitWhereInput | UnitWhereInput[]
    propertyId?: StringFilter<"Unit"> | string
    name?: StringFilter<"Unit"> | string
    bedrooms?: IntFilter<"Unit"> | number
    bathrooms?: FloatFilter<"Unit"> | number
    sqmt?: FloatFilter<"Unit"> | number
    marketRent?: FloatFilter<"Unit"> | number
    deposit?: FloatFilter<"Unit"> | number
    createdAt?: DateTimeFilter<"Unit"> | Date | string
    updatedAt?: DateTimeFilter<"Unit"> | Date | string
    Property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    lease?: LeaseListRelationFilter
  }, "id">

  export type UnitOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    name?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    sqmt?: SortOrder
    marketRent?: SortOrder
    deposit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UnitCountOrderByAggregateInput
    _avg?: UnitAvgOrderByAggregateInput
    _max?: UnitMaxOrderByAggregateInput
    _min?: UnitMinOrderByAggregateInput
    _sum?: UnitSumOrderByAggregateInput
  }

  export type UnitScalarWhereWithAggregatesInput = {
    AND?: UnitScalarWhereWithAggregatesInput | UnitScalarWhereWithAggregatesInput[]
    OR?: UnitScalarWhereWithAggregatesInput[]
    NOT?: UnitScalarWhereWithAggregatesInput | UnitScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Unit"> | string
    propertyId?: StringWithAggregatesFilter<"Unit"> | string
    name?: StringWithAggregatesFilter<"Unit"> | string
    bedrooms?: IntWithAggregatesFilter<"Unit"> | number
    bathrooms?: FloatWithAggregatesFilter<"Unit"> | number
    sqmt?: FloatWithAggregatesFilter<"Unit"> | number
    marketRent?: FloatWithAggregatesFilter<"Unit"> | number
    deposit?: FloatWithAggregatesFilter<"Unit"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Unit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Unit"> | Date | string
  }

  export type LeaseWhereInput = {
    AND?: LeaseWhereInput | LeaseWhereInput[]
    OR?: LeaseWhereInput[]
    NOT?: LeaseWhereInput | LeaseWhereInput[]
    id?: StringFilter<"Lease"> | string
    unitId?: StringFilter<"Lease"> | string
    tenantId?: StringFilter<"Lease"> | string
    startDate?: DateTimeFilter<"Lease"> | Date | string
    endDate?: DateTimeFilter<"Lease"> | Date | string
    rent?: FloatFilter<"Lease"> | number
    deposit?: FloatFilter<"Lease"> | number
    rentDueCurrency?: StringFilter<"Lease"> | string
    status?: EnumLeaseStatusFilter<"Lease"> | $Enums.LeaseStatus
    createdAt?: DateTimeFilter<"Lease"> | Date | string
    updatedAt?: DateTimeFilter<"Lease"> | Date | string
    propertyId?: StringNullableFilter<"Lease"> | string | null
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    tenantLease?: TenantLeaseListRelationFilter
    property?: XOR<PropertyNullableScalarRelationFilter, PropertyWhereInput> | null
    invoice?: InvoiceListRelationFilter
    transactions?: TransactionsListRelationFilter
    maintenanceRequest?: MaintenanceRequestListRelationFilter
    leaseDocument?: LeaseDocumentListRelationFilter
  }

  export type LeaseOrderByWithRelationInput = {
    id?: SortOrder
    unitId?: SortOrder
    tenantId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    rent?: SortOrder
    deposit?: SortOrder
    rentDueCurrency?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    propertyId?: SortOrderInput | SortOrder
    unit?: UnitOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
    tenantLease?: TenantLeaseOrderByRelationAggregateInput
    property?: PropertyOrderByWithRelationInput
    invoice?: InvoiceOrderByRelationAggregateInput
    transactions?: TransactionsOrderByRelationAggregateInput
    maintenanceRequest?: MaintenanceRequestOrderByRelationAggregateInput
    leaseDocument?: LeaseDocumentOrderByRelationAggregateInput
  }

  export type LeaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LeaseWhereInput | LeaseWhereInput[]
    OR?: LeaseWhereInput[]
    NOT?: LeaseWhereInput | LeaseWhereInput[]
    unitId?: StringFilter<"Lease"> | string
    tenantId?: StringFilter<"Lease"> | string
    startDate?: DateTimeFilter<"Lease"> | Date | string
    endDate?: DateTimeFilter<"Lease"> | Date | string
    rent?: FloatFilter<"Lease"> | number
    deposit?: FloatFilter<"Lease"> | number
    rentDueCurrency?: StringFilter<"Lease"> | string
    status?: EnumLeaseStatusFilter<"Lease"> | $Enums.LeaseStatus
    createdAt?: DateTimeFilter<"Lease"> | Date | string
    updatedAt?: DateTimeFilter<"Lease"> | Date | string
    propertyId?: StringNullableFilter<"Lease"> | string | null
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    tenantLease?: TenantLeaseListRelationFilter
    property?: XOR<PropertyNullableScalarRelationFilter, PropertyWhereInput> | null
    invoice?: InvoiceListRelationFilter
    transactions?: TransactionsListRelationFilter
    maintenanceRequest?: MaintenanceRequestListRelationFilter
    leaseDocument?: LeaseDocumentListRelationFilter
  }, "id">

  export type LeaseOrderByWithAggregationInput = {
    id?: SortOrder
    unitId?: SortOrder
    tenantId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    rent?: SortOrder
    deposit?: SortOrder
    rentDueCurrency?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    propertyId?: SortOrderInput | SortOrder
    _count?: LeaseCountOrderByAggregateInput
    _avg?: LeaseAvgOrderByAggregateInput
    _max?: LeaseMaxOrderByAggregateInput
    _min?: LeaseMinOrderByAggregateInput
    _sum?: LeaseSumOrderByAggregateInput
  }

  export type LeaseScalarWhereWithAggregatesInput = {
    AND?: LeaseScalarWhereWithAggregatesInput | LeaseScalarWhereWithAggregatesInput[]
    OR?: LeaseScalarWhereWithAggregatesInput[]
    NOT?: LeaseScalarWhereWithAggregatesInput | LeaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lease"> | string
    unitId?: StringWithAggregatesFilter<"Lease"> | string
    tenantId?: StringWithAggregatesFilter<"Lease"> | string
    startDate?: DateTimeWithAggregatesFilter<"Lease"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Lease"> | Date | string
    rent?: FloatWithAggregatesFilter<"Lease"> | number
    deposit?: FloatWithAggregatesFilter<"Lease"> | number
    rentDueCurrency?: StringWithAggregatesFilter<"Lease"> | string
    status?: EnumLeaseStatusWithAggregatesFilter<"Lease"> | $Enums.LeaseStatus
    createdAt?: DateTimeWithAggregatesFilter<"Lease"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Lease"> | Date | string
    propertyId?: StringNullableWithAggregatesFilter<"Lease"> | string | null
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: StringFilter<"Invoice"> | string
    leaseId?: StringFilter<"Invoice"> | string
    description?: StringFilter<"Invoice"> | string
    dueAmount?: FloatFilter<"Invoice"> | number
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    category?: EnumInvoiceCategoryFilter<"Invoice"> | $Enums.InvoiceCategory
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    lease?: XOR<LeaseScalarRelationFilter, LeaseWhereInput>
    transactions?: TransactionsListRelationFilter
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    leaseId?: SortOrder
    description?: SortOrder
    dueAmount?: SortOrder
    dueDate?: SortOrder
    category?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lease?: LeaseOrderByWithRelationInput
    transactions?: TransactionsOrderByRelationAggregateInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    leaseId?: StringFilter<"Invoice"> | string
    description?: StringFilter<"Invoice"> | string
    dueAmount?: FloatFilter<"Invoice"> | number
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    category?: EnumInvoiceCategoryFilter<"Invoice"> | $Enums.InvoiceCategory
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    lease?: XOR<LeaseScalarRelationFilter, LeaseWhereInput>
    transactions?: TransactionsListRelationFilter
  }, "id">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    leaseId?: SortOrder
    description?: SortOrder
    dueAmount?: SortOrder
    dueDate?: SortOrder
    category?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invoice"> | string
    leaseId?: StringWithAggregatesFilter<"Invoice"> | string
    description?: StringWithAggregatesFilter<"Invoice"> | string
    dueAmount?: FloatWithAggregatesFilter<"Invoice"> | number
    dueDate?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    category?: EnumInvoiceCategoryWithAggregatesFilter<"Invoice"> | $Enums.InvoiceCategory
    status?: EnumInvoiceStatusWithAggregatesFilter<"Invoice"> | $Enums.InvoiceStatus
    createdAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
  }

  export type TransactionsWhereInput = {
    AND?: TransactionsWhereInput | TransactionsWhereInput[]
    OR?: TransactionsWhereInput[]
    NOT?: TransactionsWhereInput | TransactionsWhereInput[]
    id?: StringFilter<"Transactions"> | string
    leaseId?: StringFilter<"Transactions"> | string
    description?: StringFilter<"Transactions"> | string
    amountPaid?: FloatFilter<"Transactions"> | number
    referenceId?: StringNullableFilter<"Transactions"> | string | null
    createdAt?: DateTimeFilter<"Transactions"> | Date | string
    updatedAt?: DateTimeFilter<"Transactions"> | Date | string
    invoiceId?: StringNullableFilter<"Transactions"> | string | null
    lease?: XOR<LeaseScalarRelationFilter, LeaseWhereInput>
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
  }

  export type TransactionsOrderByWithRelationInput = {
    id?: SortOrder
    leaseId?: SortOrder
    description?: SortOrder
    amountPaid?: SortOrder
    referenceId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invoiceId?: SortOrderInput | SortOrder
    lease?: LeaseOrderByWithRelationInput
    invoice?: InvoiceOrderByWithRelationInput
  }

  export type TransactionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransactionsWhereInput | TransactionsWhereInput[]
    OR?: TransactionsWhereInput[]
    NOT?: TransactionsWhereInput | TransactionsWhereInput[]
    leaseId?: StringFilter<"Transactions"> | string
    description?: StringFilter<"Transactions"> | string
    amountPaid?: FloatFilter<"Transactions"> | number
    referenceId?: StringNullableFilter<"Transactions"> | string | null
    createdAt?: DateTimeFilter<"Transactions"> | Date | string
    updatedAt?: DateTimeFilter<"Transactions"> | Date | string
    invoiceId?: StringNullableFilter<"Transactions"> | string | null
    lease?: XOR<LeaseScalarRelationFilter, LeaseWhereInput>
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
  }, "id">

  export type TransactionsOrderByWithAggregationInput = {
    id?: SortOrder
    leaseId?: SortOrder
    description?: SortOrder
    amountPaid?: SortOrder
    referenceId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invoiceId?: SortOrderInput | SortOrder
    _count?: TransactionsCountOrderByAggregateInput
    _avg?: TransactionsAvgOrderByAggregateInput
    _max?: TransactionsMaxOrderByAggregateInput
    _min?: TransactionsMinOrderByAggregateInput
    _sum?: TransactionsSumOrderByAggregateInput
  }

  export type TransactionsScalarWhereWithAggregatesInput = {
    AND?: TransactionsScalarWhereWithAggregatesInput | TransactionsScalarWhereWithAggregatesInput[]
    OR?: TransactionsScalarWhereWithAggregatesInput[]
    NOT?: TransactionsScalarWhereWithAggregatesInput | TransactionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transactions"> | string
    leaseId?: StringWithAggregatesFilter<"Transactions"> | string
    description?: StringWithAggregatesFilter<"Transactions"> | string
    amountPaid?: FloatWithAggregatesFilter<"Transactions"> | number
    referenceId?: StringNullableWithAggregatesFilter<"Transactions"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Transactions"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Transactions"> | Date | string
    invoiceId?: StringNullableWithAggregatesFilter<"Transactions"> | string | null
  }

  export type TenantLeaseWhereInput = {
    AND?: TenantLeaseWhereInput | TenantLeaseWhereInput[]
    OR?: TenantLeaseWhereInput[]
    NOT?: TenantLeaseWhereInput | TenantLeaseWhereInput[]
    id?: StringFilter<"TenantLease"> | string
    tenantId?: StringFilter<"TenantLease"> | string
    leaseId?: StringFilter<"TenantLease"> | string
    createdAt?: DateTimeFilter<"TenantLease"> | Date | string
    updatedAt?: DateTimeFilter<"TenantLease"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    lease?: XOR<LeaseScalarRelationFilter, LeaseWhereInput>
  }

  export type TenantLeaseOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    leaseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    lease?: LeaseOrderByWithRelationInput
  }

  export type TenantLeaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TenantLeaseWhereInput | TenantLeaseWhereInput[]
    OR?: TenantLeaseWhereInput[]
    NOT?: TenantLeaseWhereInput | TenantLeaseWhereInput[]
    tenantId?: StringFilter<"TenantLease"> | string
    leaseId?: StringFilter<"TenantLease"> | string
    createdAt?: DateTimeFilter<"TenantLease"> | Date | string
    updatedAt?: DateTimeFilter<"TenantLease"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    lease?: XOR<LeaseScalarRelationFilter, LeaseWhereInput>
  }, "id">

  export type TenantLeaseOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    leaseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TenantLeaseCountOrderByAggregateInput
    _max?: TenantLeaseMaxOrderByAggregateInput
    _min?: TenantLeaseMinOrderByAggregateInput
  }

  export type TenantLeaseScalarWhereWithAggregatesInput = {
    AND?: TenantLeaseScalarWhereWithAggregatesInput | TenantLeaseScalarWhereWithAggregatesInput[]
    OR?: TenantLeaseScalarWhereWithAggregatesInput[]
    NOT?: TenantLeaseScalarWhereWithAggregatesInput | TenantLeaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TenantLease"> | string
    tenantId?: StringWithAggregatesFilter<"TenantLease"> | string
    leaseId?: StringWithAggregatesFilter<"TenantLease"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TenantLease"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TenantLease"> | Date | string
  }

  export type MaintenanceRequestWhereInput = {
    AND?: MaintenanceRequestWhereInput | MaintenanceRequestWhereInput[]
    OR?: MaintenanceRequestWhereInput[]
    NOT?: MaintenanceRequestWhereInput | MaintenanceRequestWhereInput[]
    id?: StringFilter<"MaintenanceRequest"> | string
    leaseId?: StringFilter<"MaintenanceRequest"> | string
    description?: StringFilter<"MaintenanceRequest"> | string
    status?: EnumMaintenanceRequestStatusFilter<"MaintenanceRequest"> | $Enums.MaintenanceRequestStatus
    priority?: EnumMaintenanceRequestPriorityFilter<"MaintenanceRequest"> | $Enums.MaintenanceRequestPriority
    createdAt?: DateTimeFilter<"MaintenanceRequest"> | Date | string
    updatedAt?: DateTimeFilter<"MaintenanceRequest"> | Date | string
    lease?: XOR<LeaseScalarRelationFilter, LeaseWhereInput>
  }

  export type MaintenanceRequestOrderByWithRelationInput = {
    id?: SortOrder
    leaseId?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lease?: LeaseOrderByWithRelationInput
  }

  export type MaintenanceRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MaintenanceRequestWhereInput | MaintenanceRequestWhereInput[]
    OR?: MaintenanceRequestWhereInput[]
    NOT?: MaintenanceRequestWhereInput | MaintenanceRequestWhereInput[]
    leaseId?: StringFilter<"MaintenanceRequest"> | string
    description?: StringFilter<"MaintenanceRequest"> | string
    status?: EnumMaintenanceRequestStatusFilter<"MaintenanceRequest"> | $Enums.MaintenanceRequestStatus
    priority?: EnumMaintenanceRequestPriorityFilter<"MaintenanceRequest"> | $Enums.MaintenanceRequestPriority
    createdAt?: DateTimeFilter<"MaintenanceRequest"> | Date | string
    updatedAt?: DateTimeFilter<"MaintenanceRequest"> | Date | string
    lease?: XOR<LeaseScalarRelationFilter, LeaseWhereInput>
  }, "id">

  export type MaintenanceRequestOrderByWithAggregationInput = {
    id?: SortOrder
    leaseId?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MaintenanceRequestCountOrderByAggregateInput
    _max?: MaintenanceRequestMaxOrderByAggregateInput
    _min?: MaintenanceRequestMinOrderByAggregateInput
  }

  export type MaintenanceRequestScalarWhereWithAggregatesInput = {
    AND?: MaintenanceRequestScalarWhereWithAggregatesInput | MaintenanceRequestScalarWhereWithAggregatesInput[]
    OR?: MaintenanceRequestScalarWhereWithAggregatesInput[]
    NOT?: MaintenanceRequestScalarWhereWithAggregatesInput | MaintenanceRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MaintenanceRequest"> | string
    leaseId?: StringWithAggregatesFilter<"MaintenanceRequest"> | string
    description?: StringWithAggregatesFilter<"MaintenanceRequest"> | string
    status?: EnumMaintenanceRequestStatusWithAggregatesFilter<"MaintenanceRequest"> | $Enums.MaintenanceRequestStatus
    priority?: EnumMaintenanceRequestPriorityWithAggregatesFilter<"MaintenanceRequest"> | $Enums.MaintenanceRequestPriority
    createdAt?: DateTimeWithAggregatesFilter<"MaintenanceRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MaintenanceRequest"> | Date | string
  }

  export type TenantDocumentWhereInput = {
    AND?: TenantDocumentWhereInput | TenantDocumentWhereInput[]
    OR?: TenantDocumentWhereInput[]
    NOT?: TenantDocumentWhereInput | TenantDocumentWhereInput[]
    id?: StringFilter<"TenantDocument"> | string
    tenantId?: StringFilter<"TenantDocument"> | string
    documentType?: EnumTenantDocumentTypeFilter<"TenantDocument"> | $Enums.TenantDocumentType
    documentUrl?: StringFilter<"TenantDocument"> | string
    createdAt?: DateTimeFilter<"TenantDocument"> | Date | string
    updatedAt?: DateTimeFilter<"TenantDocument"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type TenantDocumentOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    documentType?: SortOrder
    documentUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type TenantDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TenantDocumentWhereInput | TenantDocumentWhereInput[]
    OR?: TenantDocumentWhereInput[]
    NOT?: TenantDocumentWhereInput | TenantDocumentWhereInput[]
    tenantId?: StringFilter<"TenantDocument"> | string
    documentType?: EnumTenantDocumentTypeFilter<"TenantDocument"> | $Enums.TenantDocumentType
    documentUrl?: StringFilter<"TenantDocument"> | string
    createdAt?: DateTimeFilter<"TenantDocument"> | Date | string
    updatedAt?: DateTimeFilter<"TenantDocument"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id">

  export type TenantDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    documentType?: SortOrder
    documentUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TenantDocumentCountOrderByAggregateInput
    _max?: TenantDocumentMaxOrderByAggregateInput
    _min?: TenantDocumentMinOrderByAggregateInput
  }

  export type TenantDocumentScalarWhereWithAggregatesInput = {
    AND?: TenantDocumentScalarWhereWithAggregatesInput | TenantDocumentScalarWhereWithAggregatesInput[]
    OR?: TenantDocumentScalarWhereWithAggregatesInput[]
    NOT?: TenantDocumentScalarWhereWithAggregatesInput | TenantDocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TenantDocument"> | string
    tenantId?: StringWithAggregatesFilter<"TenantDocument"> | string
    documentType?: EnumTenantDocumentTypeWithAggregatesFilter<"TenantDocument"> | $Enums.TenantDocumentType
    documentUrl?: StringWithAggregatesFilter<"TenantDocument"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TenantDocument"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TenantDocument"> | Date | string
  }

  export type LeaseDocumentWhereInput = {
    AND?: LeaseDocumentWhereInput | LeaseDocumentWhereInput[]
    OR?: LeaseDocumentWhereInput[]
    NOT?: LeaseDocumentWhereInput | LeaseDocumentWhereInput[]
    id?: StringFilter<"LeaseDocument"> | string
    leaseId?: StringFilter<"LeaseDocument"> | string
    documentType?: EnumDocumentTypeFilter<"LeaseDocument"> | $Enums.DocumentType
    documentUrl?: StringFilter<"LeaseDocument"> | string
    createdAt?: DateTimeFilter<"LeaseDocument"> | Date | string
    updatedAt?: DateTimeFilter<"LeaseDocument"> | Date | string
    lease?: XOR<LeaseScalarRelationFilter, LeaseWhereInput>
  }

  export type LeaseDocumentOrderByWithRelationInput = {
    id?: SortOrder
    leaseId?: SortOrder
    documentType?: SortOrder
    documentUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lease?: LeaseOrderByWithRelationInput
  }

  export type LeaseDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LeaseDocumentWhereInput | LeaseDocumentWhereInput[]
    OR?: LeaseDocumentWhereInput[]
    NOT?: LeaseDocumentWhereInput | LeaseDocumentWhereInput[]
    leaseId?: StringFilter<"LeaseDocument"> | string
    documentType?: EnumDocumentTypeFilter<"LeaseDocument"> | $Enums.DocumentType
    documentUrl?: StringFilter<"LeaseDocument"> | string
    createdAt?: DateTimeFilter<"LeaseDocument"> | Date | string
    updatedAt?: DateTimeFilter<"LeaseDocument"> | Date | string
    lease?: XOR<LeaseScalarRelationFilter, LeaseWhereInput>
  }, "id">

  export type LeaseDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    leaseId?: SortOrder
    documentType?: SortOrder
    documentUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LeaseDocumentCountOrderByAggregateInput
    _max?: LeaseDocumentMaxOrderByAggregateInput
    _min?: LeaseDocumentMinOrderByAggregateInput
  }

  export type LeaseDocumentScalarWhereWithAggregatesInput = {
    AND?: LeaseDocumentScalarWhereWithAggregatesInput | LeaseDocumentScalarWhereWithAggregatesInput[]
    OR?: LeaseDocumentScalarWhereWithAggregatesInput[]
    NOT?: LeaseDocumentScalarWhereWithAggregatesInput | LeaseDocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LeaseDocument"> | string
    leaseId?: StringWithAggregatesFilter<"LeaseDocument"> | string
    documentType?: EnumDocumentTypeWithAggregatesFilter<"LeaseDocument"> | $Enums.DocumentType
    documentUrl?: StringWithAggregatesFilter<"LeaseDocument"> | string
    createdAt?: DateTimeWithAggregatesFilter<"LeaseDocument"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LeaseDocument"> | Date | string
  }

  export type PropertyDocumentWhereInput = {
    AND?: PropertyDocumentWhereInput | PropertyDocumentWhereInput[]
    OR?: PropertyDocumentWhereInput[]
    NOT?: PropertyDocumentWhereInput | PropertyDocumentWhereInput[]
    id?: StringFilter<"PropertyDocument"> | string
    propertyId?: StringFilter<"PropertyDocument"> | string
    documentType?: EnumDocumentTypeFilter<"PropertyDocument"> | $Enums.DocumentType
    documentUrl?: StringFilter<"PropertyDocument"> | string
    createdAt?: DateTimeFilter<"PropertyDocument"> | Date | string
    updatedAt?: DateTimeFilter<"PropertyDocument"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }

  export type PropertyDocumentOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    documentType?: SortOrder
    documentUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    property?: PropertyOrderByWithRelationInput
  }

  export type PropertyDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PropertyDocumentWhereInput | PropertyDocumentWhereInput[]
    OR?: PropertyDocumentWhereInput[]
    NOT?: PropertyDocumentWhereInput | PropertyDocumentWhereInput[]
    propertyId?: StringFilter<"PropertyDocument"> | string
    documentType?: EnumDocumentTypeFilter<"PropertyDocument"> | $Enums.DocumentType
    documentUrl?: StringFilter<"PropertyDocument"> | string
    createdAt?: DateTimeFilter<"PropertyDocument"> | Date | string
    updatedAt?: DateTimeFilter<"PropertyDocument"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }, "id">

  export type PropertyDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    documentType?: SortOrder
    documentUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PropertyDocumentCountOrderByAggregateInput
    _max?: PropertyDocumentMaxOrderByAggregateInput
    _min?: PropertyDocumentMinOrderByAggregateInput
  }

  export type PropertyDocumentScalarWhereWithAggregatesInput = {
    AND?: PropertyDocumentScalarWhereWithAggregatesInput | PropertyDocumentScalarWhereWithAggregatesInput[]
    OR?: PropertyDocumentScalarWhereWithAggregatesInput[]
    NOT?: PropertyDocumentScalarWhereWithAggregatesInput | PropertyDocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PropertyDocument"> | string
    propertyId?: StringWithAggregatesFilter<"PropertyDocument"> | string
    documentType?: EnumDocumentTypeWithAggregatesFilter<"PropertyDocument"> | $Enums.DocumentType
    documentUrl?: StringWithAggregatesFilter<"PropertyDocument"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PropertyDocument"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PropertyDocument"> | Date | string
  }

  export type TenantCreateInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    altEmail?: string | null
    phone: string
    altPhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Lease?: LeaseCreateNestedManyWithoutTenantInput
    tenantLease?: TenantLeaseCreateNestedManyWithoutTenantInput
    tenantDocument?: TenantDocumentCreateNestedManyWithoutTenantInput
    tenantEmergencyContact?: TenantEmergencyContactCreateNestedManyWithoutTenantInput
    tenantIncome?: TenantIncomeCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    altEmail?: string | null
    phone: string
    altPhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Lease?: LeaseUncheckedCreateNestedManyWithoutTenantInput
    tenantLease?: TenantLeaseUncheckedCreateNestedManyWithoutTenantInput
    tenantDocument?: TenantDocumentUncheckedCreateNestedManyWithoutTenantInput
    tenantEmergencyContact?: TenantEmergencyContactUncheckedCreateNestedManyWithoutTenantInput
    tenantIncome?: TenantIncomeUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    altEmail?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    altPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Lease?: LeaseUpdateManyWithoutTenantNestedInput
    tenantLease?: TenantLeaseUpdateManyWithoutTenantNestedInput
    tenantDocument?: TenantDocumentUpdateManyWithoutTenantNestedInput
    tenantEmergencyContact?: TenantEmergencyContactUpdateManyWithoutTenantNestedInput
    tenantIncome?: TenantIncomeUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    altEmail?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    altPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Lease?: LeaseUncheckedUpdateManyWithoutTenantNestedInput
    tenantLease?: TenantLeaseUncheckedUpdateManyWithoutTenantNestedInput
    tenantDocument?: TenantDocumentUncheckedUpdateManyWithoutTenantNestedInput
    tenantEmergencyContact?: TenantEmergencyContactUncheckedUpdateManyWithoutTenantNestedInput
    tenantIncome?: TenantIncomeUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateManyInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    altEmail?: string | null
    phone: string
    altPhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    altEmail?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    altPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    altEmail?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    altPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantEmergencyContactCreateInput = {
    id?: string
    name: string
    phone: string
    email: string
    relationship: $Enums.TenantRelationship
    addressLine1: string
    addressLine2?: string | null
    city: string
    state: string
    zip: string
    countryCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutTenantEmergencyContactInput
  }

  export type TenantEmergencyContactUncheckedCreateInput = {
    id?: string
    tenantId: string
    name: string
    phone: string
    email: string
    relationship: $Enums.TenantRelationship
    addressLine1: string
    addressLine2?: string | null
    city: string
    state: string
    zip: string
    countryCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantEmergencyContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    relationship?: EnumTenantRelationshipFieldUpdateOperationsInput | $Enums.TenantRelationship
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutTenantEmergencyContactNestedInput
  }

  export type TenantEmergencyContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    relationship?: EnumTenantRelationshipFieldUpdateOperationsInput | $Enums.TenantRelationship
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantEmergencyContactCreateManyInput = {
    id?: string
    tenantId: string
    name: string
    phone: string
    email: string
    relationship: $Enums.TenantRelationship
    addressLine1: string
    addressLine2?: string | null
    city: string
    state: string
    zip: string
    countryCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantEmergencyContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    relationship?: EnumTenantRelationshipFieldUpdateOperationsInput | $Enums.TenantRelationship
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantEmergencyContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    relationship?: EnumTenantRelationshipFieldUpdateOperationsInput | $Enums.TenantRelationship
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantIncomeCreateInput = {
    id?: string
    income: number
    incomeType: $Enums.TenantIncomeType
    position?: string | null
    employer?: string | null
    employerAddressLine1?: string | null
    employerAddressLine2?: string | null
    employerCity?: string | null
    employerState?: string | null
    employerZip?: string | null
    employerCountryCode?: string | null
    startDate: Date | string
    endDate: Date | string
    currentIncome?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutTenantIncomeInput
  }

  export type TenantIncomeUncheckedCreateInput = {
    id?: string
    tenantId: string
    income: number
    incomeType: $Enums.TenantIncomeType
    position?: string | null
    employer?: string | null
    employerAddressLine1?: string | null
    employerAddressLine2?: string | null
    employerCity?: string | null
    employerState?: string | null
    employerZip?: string | null
    employerCountryCode?: string | null
    startDate: Date | string
    endDate: Date | string
    currentIncome?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantIncomeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    income?: FloatFieldUpdateOperationsInput | number
    incomeType?: EnumTenantIncomeTypeFieldUpdateOperationsInput | $Enums.TenantIncomeType
    position?: NullableStringFieldUpdateOperationsInput | string | null
    employer?: NullableStringFieldUpdateOperationsInput | string | null
    employerAddressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    employerAddressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    employerCity?: NullableStringFieldUpdateOperationsInput | string | null
    employerState?: NullableStringFieldUpdateOperationsInput | string | null
    employerZip?: NullableStringFieldUpdateOperationsInput | string | null
    employerCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currentIncome?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutTenantIncomeNestedInput
  }

  export type TenantIncomeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    income?: FloatFieldUpdateOperationsInput | number
    incomeType?: EnumTenantIncomeTypeFieldUpdateOperationsInput | $Enums.TenantIncomeType
    position?: NullableStringFieldUpdateOperationsInput | string | null
    employer?: NullableStringFieldUpdateOperationsInput | string | null
    employerAddressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    employerAddressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    employerCity?: NullableStringFieldUpdateOperationsInput | string | null
    employerState?: NullableStringFieldUpdateOperationsInput | string | null
    employerZip?: NullableStringFieldUpdateOperationsInput | string | null
    employerCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currentIncome?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantIncomeCreateManyInput = {
    id?: string
    tenantId: string
    income: number
    incomeType: $Enums.TenantIncomeType
    position?: string | null
    employer?: string | null
    employerAddressLine1?: string | null
    employerAddressLine2?: string | null
    employerCity?: string | null
    employerState?: string | null
    employerZip?: string | null
    employerCountryCode?: string | null
    startDate: Date | string
    endDate: Date | string
    currentIncome?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantIncomeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    income?: FloatFieldUpdateOperationsInput | number
    incomeType?: EnumTenantIncomeTypeFieldUpdateOperationsInput | $Enums.TenantIncomeType
    position?: NullableStringFieldUpdateOperationsInput | string | null
    employer?: NullableStringFieldUpdateOperationsInput | string | null
    employerAddressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    employerAddressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    employerCity?: NullableStringFieldUpdateOperationsInput | string | null
    employerState?: NullableStringFieldUpdateOperationsInput | string | null
    employerZip?: NullableStringFieldUpdateOperationsInput | string | null
    employerCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currentIncome?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantIncomeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    income?: FloatFieldUpdateOperationsInput | number
    incomeType?: EnumTenantIncomeTypeFieldUpdateOperationsInput | $Enums.TenantIncomeType
    position?: NullableStringFieldUpdateOperationsInput | string | null
    employer?: NullableStringFieldUpdateOperationsInput | string | null
    employerAddressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    employerAddressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    employerCity?: NullableStringFieldUpdateOperationsInput | string | null
    employerState?: NullableStringFieldUpdateOperationsInput | string | null
    employerZip?: NullableStringFieldUpdateOperationsInput | string | null
    employerCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currentIncome?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LandlordCreateInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone: string
    addressLine1: string
    addressLine2?: string | null
    city: string
    state: string
    zip: string
    createdAt?: Date | string
    updatedAt?: Date | string
    property?: PropertyCreateNestedManyWithoutOwnerInput
  }

  export type LandlordUncheckedCreateInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone: string
    addressLine1: string
    addressLine2?: string | null
    city: string
    state: string
    zip: string
    createdAt?: Date | string
    updatedAt?: Date | string
    property?: PropertyUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type LandlordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateManyWithoutOwnerNestedInput
  }

  export type LandlordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type LandlordCreateManyInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone: string
    addressLine1: string
    addressLine2?: string | null
    city: string
    state: string
    zip: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LandlordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LandlordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyCreateInput = {
    id?: string
    name: string
    addressLine1: string
    addressLine2?: string | null
    city: string
    state: string
    zip: string
    countryCode?: string
    imageUrl?: string | null
    propertyType?: $Enums.PropertyType
    propertyStatus?: $Enums.PropertyStatus
    bedrooms?: number
    bathrooms?: number
    squareMeters?: number
    marketRent?: number
    deposit?: number
    leaseTerm?: number
    leaseTermType?: $Enums.LeaseTermType
    createdAt?: Date | string
    updatedAt?: Date | string
    sqmt?: number
    features?: PropertyCreatefeaturesInput | string[]
    amenities?: PropertyCreateamenitiesInput | string[]
    test?: string | null
    owner: LandlordCreateNestedOneWithoutPropertyInput
    unit?: UnitCreateNestedManyWithoutPropertyInput
    propertyDocument?: PropertyDocumentCreateNestedManyWithoutPropertyInput
    Lease?: LeaseCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateInput = {
    id?: string
    name: string
    addressLine1: string
    addressLine2?: string | null
    city: string
    state: string
    zip: string
    countryCode?: string
    ownerId: string
    imageUrl?: string | null
    propertyType?: $Enums.PropertyType
    propertyStatus?: $Enums.PropertyStatus
    bedrooms?: number
    bathrooms?: number
    squareMeters?: number
    marketRent?: number
    deposit?: number
    leaseTerm?: number
    leaseTermType?: $Enums.LeaseTermType
    createdAt?: Date | string
    updatedAt?: Date | string
    sqmt?: number
    features?: PropertyCreatefeaturesInput | string[]
    amenities?: PropertyCreateamenitiesInput | string[]
    test?: string | null
    unit?: UnitUncheckedCreateNestedManyWithoutPropertyInput
    propertyDocument?: PropertyDocumentUncheckedCreateNestedManyWithoutPropertyInput
    Lease?: LeaseUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    propertyStatus?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: FloatFieldUpdateOperationsInput | number
    squareMeters?: FloatFieldUpdateOperationsInput | number
    marketRent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    leaseTerm?: IntFieldUpdateOperationsInput | number
    leaseTermType?: EnumLeaseTermTypeFieldUpdateOperationsInput | $Enums.LeaseTermType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sqmt?: FloatFieldUpdateOperationsInput | number
    features?: PropertyUpdatefeaturesInput | string[]
    amenities?: PropertyUpdateamenitiesInput | string[]
    test?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: LandlordUpdateOneRequiredWithoutPropertyNestedInput
    unit?: UnitUpdateManyWithoutPropertyNestedInput
    propertyDocument?: PropertyDocumentUpdateManyWithoutPropertyNestedInput
    Lease?: LeaseUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    propertyStatus?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: FloatFieldUpdateOperationsInput | number
    squareMeters?: FloatFieldUpdateOperationsInput | number
    marketRent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    leaseTerm?: IntFieldUpdateOperationsInput | number
    leaseTermType?: EnumLeaseTermTypeFieldUpdateOperationsInput | $Enums.LeaseTermType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sqmt?: FloatFieldUpdateOperationsInput | number
    features?: PropertyUpdatefeaturesInput | string[]
    amenities?: PropertyUpdateamenitiesInput | string[]
    test?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: UnitUncheckedUpdateManyWithoutPropertyNestedInput
    propertyDocument?: PropertyDocumentUncheckedUpdateManyWithoutPropertyNestedInput
    Lease?: LeaseUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyCreateManyInput = {
    id?: string
    name: string
    addressLine1: string
    addressLine2?: string | null
    city: string
    state: string
    zip: string
    countryCode?: string
    ownerId: string
    imageUrl?: string | null
    propertyType?: $Enums.PropertyType
    propertyStatus?: $Enums.PropertyStatus
    bedrooms?: number
    bathrooms?: number
    squareMeters?: number
    marketRent?: number
    deposit?: number
    leaseTerm?: number
    leaseTermType?: $Enums.LeaseTermType
    createdAt?: Date | string
    updatedAt?: Date | string
    sqmt?: number
    features?: PropertyCreatefeaturesInput | string[]
    amenities?: PropertyCreateamenitiesInput | string[]
    test?: string | null
  }

  export type PropertyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    propertyStatus?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: FloatFieldUpdateOperationsInput | number
    squareMeters?: FloatFieldUpdateOperationsInput | number
    marketRent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    leaseTerm?: IntFieldUpdateOperationsInput | number
    leaseTermType?: EnumLeaseTermTypeFieldUpdateOperationsInput | $Enums.LeaseTermType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sqmt?: FloatFieldUpdateOperationsInput | number
    features?: PropertyUpdatefeaturesInput | string[]
    amenities?: PropertyUpdateamenitiesInput | string[]
    test?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    propertyStatus?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: FloatFieldUpdateOperationsInput | number
    squareMeters?: FloatFieldUpdateOperationsInput | number
    marketRent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    leaseTerm?: IntFieldUpdateOperationsInput | number
    leaseTermType?: EnumLeaseTermTypeFieldUpdateOperationsInput | $Enums.LeaseTermType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sqmt?: FloatFieldUpdateOperationsInput | number
    features?: PropertyUpdatefeaturesInput | string[]
    amenities?: PropertyUpdateamenitiesInput | string[]
    test?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UnitCreateInput = {
    id?: string
    name: string
    bedrooms?: number
    bathrooms?: number
    sqmt?: number
    marketRent?: number
    deposit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Property: PropertyCreateNestedOneWithoutUnitInput
    lease?: LeaseCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateInput = {
    id?: string
    propertyId: string
    name: string
    bedrooms?: number
    bathrooms?: number
    sqmt?: number
    marketRent?: number
    deposit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lease?: LeaseUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: FloatFieldUpdateOperationsInput | number
    sqmt?: FloatFieldUpdateOperationsInput | number
    marketRent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Property?: PropertyUpdateOneRequiredWithoutUnitNestedInput
    lease?: LeaseUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: FloatFieldUpdateOperationsInput | number
    sqmt?: FloatFieldUpdateOperationsInput | number
    marketRent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lease?: LeaseUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitCreateManyInput = {
    id?: string
    propertyId: string
    name: string
    bedrooms?: number
    bathrooms?: number
    sqmt?: number
    marketRent?: number
    deposit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: FloatFieldUpdateOperationsInput | number
    sqmt?: FloatFieldUpdateOperationsInput | number
    marketRent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: FloatFieldUpdateOperationsInput | number
    sqmt?: FloatFieldUpdateOperationsInput | number
    marketRent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaseCreateInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    rent: number
    deposit: number
    rentDueCurrency: string
    status: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    unit: UnitCreateNestedOneWithoutLeaseInput
    tenant: TenantCreateNestedOneWithoutLeaseInput
    tenantLease?: TenantLeaseCreateNestedManyWithoutLeaseInput
    property?: PropertyCreateNestedOneWithoutLeaseInput
    invoice?: InvoiceCreateNestedManyWithoutLeaseInput
    transactions?: TransactionsCreateNestedManyWithoutLeaseInput
    maintenanceRequest?: MaintenanceRequestCreateNestedManyWithoutLeaseInput
    leaseDocument?: LeaseDocumentCreateNestedManyWithoutLeaseInput
  }

  export type LeaseUncheckedCreateInput = {
    id?: string
    unitId: string
    tenantId: string
    startDate: Date | string
    endDate: Date | string
    rent: number
    deposit: number
    rentDueCurrency: string
    status: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    propertyId?: string | null
    tenantLease?: TenantLeaseUncheckedCreateNestedManyWithoutLeaseInput
    invoice?: InvoiceUncheckedCreateNestedManyWithoutLeaseInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutLeaseInput
    maintenanceRequest?: MaintenanceRequestUncheckedCreateNestedManyWithoutLeaseInput
    leaseDocument?: LeaseDocumentUncheckedCreateNestedManyWithoutLeaseInput
  }

  export type LeaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    rentDueCurrency?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitUpdateOneRequiredWithoutLeaseNestedInput
    tenant?: TenantUpdateOneRequiredWithoutLeaseNestedInput
    tenantLease?: TenantLeaseUpdateManyWithoutLeaseNestedInput
    property?: PropertyUpdateOneWithoutLeaseNestedInput
    invoice?: InvoiceUpdateManyWithoutLeaseNestedInput
    transactions?: TransactionsUpdateManyWithoutLeaseNestedInput
    maintenanceRequest?: MaintenanceRequestUpdateManyWithoutLeaseNestedInput
    leaseDocument?: LeaseDocumentUpdateManyWithoutLeaseNestedInput
  }

  export type LeaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    rentDueCurrency?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    tenantLease?: TenantLeaseUncheckedUpdateManyWithoutLeaseNestedInput
    invoice?: InvoiceUncheckedUpdateManyWithoutLeaseNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutLeaseNestedInput
    maintenanceRequest?: MaintenanceRequestUncheckedUpdateManyWithoutLeaseNestedInput
    leaseDocument?: LeaseDocumentUncheckedUpdateManyWithoutLeaseNestedInput
  }

  export type LeaseCreateManyInput = {
    id?: string
    unitId: string
    tenantId: string
    startDate: Date | string
    endDate: Date | string
    rent: number
    deposit: number
    rentDueCurrency: string
    status: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    propertyId?: string | null
  }

  export type LeaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    rentDueCurrency?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    rentDueCurrency?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceCreateInput = {
    id?: string
    description: string
    dueAmount: number
    dueDate: Date | string
    category: $Enums.InvoiceCategory
    status: $Enums.InvoiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    lease: LeaseCreateNestedOneWithoutInvoiceInput
    transactions?: TransactionsCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    leaseId: string
    description: string
    dueAmount: number
    dueDate: Date | string
    category: $Enums.InvoiceCategory
    status: $Enums.InvoiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionsUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dueAmount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumInvoiceCategoryFieldUpdateOperationsInput | $Enums.InvoiceCategory
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lease?: LeaseUpdateOneRequiredWithoutInvoiceNestedInput
    transactions?: TransactionsUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaseId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dueAmount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumInvoiceCategoryFieldUpdateOperationsInput | $Enums.InvoiceCategory
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionsUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateManyInput = {
    id?: string
    leaseId: string
    description: string
    dueAmount: number
    dueDate: Date | string
    category: $Enums.InvoiceCategory
    status: $Enums.InvoiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dueAmount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumInvoiceCategoryFieldUpdateOperationsInput | $Enums.InvoiceCategory
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaseId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dueAmount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumInvoiceCategoryFieldUpdateOperationsInput | $Enums.InvoiceCategory
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionsCreateInput = {
    id?: string
    description: string
    amountPaid: number
    referenceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lease: LeaseCreateNestedOneWithoutTransactionsInput
    invoice?: InvoiceCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionsUncheckedCreateInput = {
    id?: string
    leaseId: string
    description: string
    amountPaid: number
    referenceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceId?: string | null
  }

  export type TransactionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lease?: LeaseUpdateOneRequiredWithoutTransactionsNestedInput
    invoice?: InvoiceUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaseId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionsCreateManyInput = {
    id?: string
    leaseId: string
    description: string
    amountPaid: number
    referenceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceId?: string | null
  }

  export type TransactionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaseId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TenantLeaseCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutTenantLeaseInput
    lease: LeaseCreateNestedOneWithoutTenantLeaseInput
  }

  export type TenantLeaseUncheckedCreateInput = {
    id?: string
    tenantId: string
    leaseId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantLeaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutTenantLeaseNestedInput
    lease?: LeaseUpdateOneRequiredWithoutTenantLeaseNestedInput
  }

  export type TenantLeaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    leaseId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantLeaseCreateManyInput = {
    id?: string
    tenantId: string
    leaseId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantLeaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantLeaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    leaseId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceRequestCreateInput = {
    id?: string
    description: string
    status: $Enums.MaintenanceRequestStatus
    priority: $Enums.MaintenanceRequestPriority
    createdAt?: Date | string
    updatedAt?: Date | string
    lease: LeaseCreateNestedOneWithoutMaintenanceRequestInput
  }

  export type MaintenanceRequestUncheckedCreateInput = {
    id?: string
    leaseId: string
    description: string
    status: $Enums.MaintenanceRequestStatus
    priority: $Enums.MaintenanceRequestPriority
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaintenanceRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumMaintenanceRequestStatusFieldUpdateOperationsInput | $Enums.MaintenanceRequestStatus
    priority?: EnumMaintenanceRequestPriorityFieldUpdateOperationsInput | $Enums.MaintenanceRequestPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lease?: LeaseUpdateOneRequiredWithoutMaintenanceRequestNestedInput
  }

  export type MaintenanceRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaseId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumMaintenanceRequestStatusFieldUpdateOperationsInput | $Enums.MaintenanceRequestStatus
    priority?: EnumMaintenanceRequestPriorityFieldUpdateOperationsInput | $Enums.MaintenanceRequestPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceRequestCreateManyInput = {
    id?: string
    leaseId: string
    description: string
    status: $Enums.MaintenanceRequestStatus
    priority: $Enums.MaintenanceRequestPriority
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaintenanceRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumMaintenanceRequestStatusFieldUpdateOperationsInput | $Enums.MaintenanceRequestStatus
    priority?: EnumMaintenanceRequestPriorityFieldUpdateOperationsInput | $Enums.MaintenanceRequestPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaseId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumMaintenanceRequestStatusFieldUpdateOperationsInput | $Enums.MaintenanceRequestStatus
    priority?: EnumMaintenanceRequestPriorityFieldUpdateOperationsInput | $Enums.MaintenanceRequestPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantDocumentCreateInput = {
    id?: string
    documentType: $Enums.TenantDocumentType
    documentUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutTenantDocumentInput
  }

  export type TenantDocumentUncheckedCreateInput = {
    id?: string
    tenantId: string
    documentType: $Enums.TenantDocumentType
    documentUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumTenantDocumentTypeFieldUpdateOperationsInput | $Enums.TenantDocumentType
    documentUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutTenantDocumentNestedInput
  }

  export type TenantDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    documentType?: EnumTenantDocumentTypeFieldUpdateOperationsInput | $Enums.TenantDocumentType
    documentUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantDocumentCreateManyInput = {
    id?: string
    tenantId: string
    documentType: $Enums.TenantDocumentType
    documentUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumTenantDocumentTypeFieldUpdateOperationsInput | $Enums.TenantDocumentType
    documentUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    documentType?: EnumTenantDocumentTypeFieldUpdateOperationsInput | $Enums.TenantDocumentType
    documentUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaseDocumentCreateInput = {
    id?: string
    documentType: $Enums.DocumentType
    documentUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lease: LeaseCreateNestedOneWithoutLeaseDocumentInput
  }

  export type LeaseDocumentUncheckedCreateInput = {
    id?: string
    leaseId: string
    documentType: $Enums.DocumentType
    documentUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaseDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    documentUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lease?: LeaseUpdateOneRequiredWithoutLeaseDocumentNestedInput
  }

  export type LeaseDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaseId?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    documentUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaseDocumentCreateManyInput = {
    id?: string
    leaseId: string
    documentType: $Enums.DocumentType
    documentUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaseDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    documentUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaseDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaseId?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    documentUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyDocumentCreateInput = {
    id?: string
    documentType: $Enums.DocumentType
    documentUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutPropertyDocumentInput
  }

  export type PropertyDocumentUncheckedCreateInput = {
    id?: string
    propertyId: string
    documentType: $Enums.DocumentType
    documentUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    documentUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutPropertyDocumentNestedInput
  }

  export type PropertyDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    documentUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyDocumentCreateManyInput = {
    id?: string
    propertyId: string
    documentType: $Enums.DocumentType
    documentUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    documentUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    documentUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type LeaseListRelationFilter = {
    every?: LeaseWhereInput
    some?: LeaseWhereInput
    none?: LeaseWhereInput
  }

  export type TenantLeaseListRelationFilter = {
    every?: TenantLeaseWhereInput
    some?: TenantLeaseWhereInput
    none?: TenantLeaseWhereInput
  }

  export type TenantDocumentListRelationFilter = {
    every?: TenantDocumentWhereInput
    some?: TenantDocumentWhereInput
    none?: TenantDocumentWhereInput
  }

  export type TenantEmergencyContactListRelationFilter = {
    every?: TenantEmergencyContactWhereInput
    some?: TenantEmergencyContactWhereInput
    none?: TenantEmergencyContactWhereInput
  }

  export type TenantIncomeListRelationFilter = {
    every?: TenantIncomeWhereInput
    some?: TenantIncomeWhereInput
    none?: TenantIncomeWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type LeaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantLeaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantEmergencyContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantIncomeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    altEmail?: SortOrder
    phone?: SortOrder
    altPhone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    altEmail?: SortOrder
    phone?: SortOrder
    altPhone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    altEmail?: SortOrder
    phone?: SortOrder
    altPhone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumTenantRelationshipFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantRelationship | EnumTenantRelationshipFieldRefInput<$PrismaModel>
    in?: $Enums.TenantRelationship[] | ListEnumTenantRelationshipFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantRelationship[] | ListEnumTenantRelationshipFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantRelationshipFilter<$PrismaModel> | $Enums.TenantRelationship
  }

  export type TenantScalarRelationFilter = {
    is?: TenantWhereInput
    isNot?: TenantWhereInput
  }

  export type TenantEmergencyContactCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    relationship?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    countryCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantEmergencyContactMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    relationship?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    countryCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantEmergencyContactMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    relationship?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    countryCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTenantRelationshipWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantRelationship | EnumTenantRelationshipFieldRefInput<$PrismaModel>
    in?: $Enums.TenantRelationship[] | ListEnumTenantRelationshipFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantRelationship[] | ListEnumTenantRelationshipFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantRelationshipWithAggregatesFilter<$PrismaModel> | $Enums.TenantRelationship
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTenantRelationshipFilter<$PrismaModel>
    _max?: NestedEnumTenantRelationshipFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumTenantIncomeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantIncomeType | EnumTenantIncomeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TenantIncomeType[] | ListEnumTenantIncomeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantIncomeType[] | ListEnumTenantIncomeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantIncomeTypeFilter<$PrismaModel> | $Enums.TenantIncomeType
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type TenantIncomeCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    income?: SortOrder
    incomeType?: SortOrder
    position?: SortOrder
    employer?: SortOrder
    employerAddressLine1?: SortOrder
    employerAddressLine2?: SortOrder
    employerCity?: SortOrder
    employerState?: SortOrder
    employerZip?: SortOrder
    employerCountryCode?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    currentIncome?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantIncomeAvgOrderByAggregateInput = {
    income?: SortOrder
  }

  export type TenantIncomeMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    income?: SortOrder
    incomeType?: SortOrder
    position?: SortOrder
    employer?: SortOrder
    employerAddressLine1?: SortOrder
    employerAddressLine2?: SortOrder
    employerCity?: SortOrder
    employerState?: SortOrder
    employerZip?: SortOrder
    employerCountryCode?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    currentIncome?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantIncomeMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    income?: SortOrder
    incomeType?: SortOrder
    position?: SortOrder
    employer?: SortOrder
    employerAddressLine1?: SortOrder
    employerAddressLine2?: SortOrder
    employerCity?: SortOrder
    employerState?: SortOrder
    employerZip?: SortOrder
    employerCountryCode?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    currentIncome?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantIncomeSumOrderByAggregateInput = {
    income?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumTenantIncomeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantIncomeType | EnumTenantIncomeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TenantIncomeType[] | ListEnumTenantIncomeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantIncomeType[] | ListEnumTenantIncomeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantIncomeTypeWithAggregatesFilter<$PrismaModel> | $Enums.TenantIncomeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTenantIncomeTypeFilter<$PrismaModel>
    _max?: NestedEnumTenantIncomeTypeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type PropertyListRelationFilter = {
    every?: PropertyWhereInput
    some?: PropertyWhereInput
    none?: PropertyWhereInput
  }

  export type PropertyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LandlordCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LandlordMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LandlordMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPropertyTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyType | EnumPropertyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyTypeFilter<$PrismaModel> | $Enums.PropertyType
  }

  export type EnumPropertyStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyStatus | EnumPropertyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyStatusFilter<$PrismaModel> | $Enums.PropertyStatus
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumLeaseTermTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaseTermType | EnumLeaseTermTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LeaseTermType[] | ListEnumLeaseTermTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaseTermType[] | ListEnumLeaseTermTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaseTermTypeFilter<$PrismaModel> | $Enums.LeaseTermType
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type LandlordScalarRelationFilter = {
    is?: LandlordWhereInput
    isNot?: LandlordWhereInput
  }

  export type UnitListRelationFilter = {
    every?: UnitWhereInput
    some?: UnitWhereInput
    none?: UnitWhereInput
  }

  export type PropertyDocumentListRelationFilter = {
    every?: PropertyDocumentWhereInput
    some?: PropertyDocumentWhereInput
    none?: PropertyDocumentWhereInput
  }

  export type UnitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    countryCode?: SortOrder
    ownerId?: SortOrder
    imageUrl?: SortOrder
    propertyType?: SortOrder
    propertyStatus?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    squareMeters?: SortOrder
    marketRent?: SortOrder
    deposit?: SortOrder
    leaseTerm?: SortOrder
    leaseTermType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sqmt?: SortOrder
    features?: SortOrder
    amenities?: SortOrder
    test?: SortOrder
  }

  export type PropertyAvgOrderByAggregateInput = {
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    squareMeters?: SortOrder
    marketRent?: SortOrder
    deposit?: SortOrder
    leaseTerm?: SortOrder
    sqmt?: SortOrder
  }

  export type PropertyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    countryCode?: SortOrder
    ownerId?: SortOrder
    imageUrl?: SortOrder
    propertyType?: SortOrder
    propertyStatus?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    squareMeters?: SortOrder
    marketRent?: SortOrder
    deposit?: SortOrder
    leaseTerm?: SortOrder
    leaseTermType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sqmt?: SortOrder
    test?: SortOrder
  }

  export type PropertyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    countryCode?: SortOrder
    ownerId?: SortOrder
    imageUrl?: SortOrder
    propertyType?: SortOrder
    propertyStatus?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    squareMeters?: SortOrder
    marketRent?: SortOrder
    deposit?: SortOrder
    leaseTerm?: SortOrder
    leaseTermType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sqmt?: SortOrder
    test?: SortOrder
  }

  export type PropertySumOrderByAggregateInput = {
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    squareMeters?: SortOrder
    marketRent?: SortOrder
    deposit?: SortOrder
    leaseTerm?: SortOrder
    sqmt?: SortOrder
  }

  export type EnumPropertyTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyType | EnumPropertyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyTypeWithAggregatesFilter<$PrismaModel> | $Enums.PropertyType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPropertyTypeFilter<$PrismaModel>
    _max?: NestedEnumPropertyTypeFilter<$PrismaModel>
  }

  export type EnumPropertyStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyStatus | EnumPropertyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyStatusWithAggregatesFilter<$PrismaModel> | $Enums.PropertyStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPropertyStatusFilter<$PrismaModel>
    _max?: NestedEnumPropertyStatusFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumLeaseTermTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaseTermType | EnumLeaseTermTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LeaseTermType[] | ListEnumLeaseTermTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaseTermType[] | ListEnumLeaseTermTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaseTermTypeWithAggregatesFilter<$PrismaModel> | $Enums.LeaseTermType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaseTermTypeFilter<$PrismaModel>
    _max?: NestedEnumLeaseTermTypeFilter<$PrismaModel>
  }

  export type PropertyScalarRelationFilter = {
    is?: PropertyWhereInput
    isNot?: PropertyWhereInput
  }

  export type UnitCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    name?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    sqmt?: SortOrder
    marketRent?: SortOrder
    deposit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitAvgOrderByAggregateInput = {
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    sqmt?: SortOrder
    marketRent?: SortOrder
    deposit?: SortOrder
  }

  export type UnitMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    name?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    sqmt?: SortOrder
    marketRent?: SortOrder
    deposit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    name?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    sqmt?: SortOrder
    marketRent?: SortOrder
    deposit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitSumOrderByAggregateInput = {
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    sqmt?: SortOrder
    marketRent?: SortOrder
    deposit?: SortOrder
  }

  export type EnumLeaseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaseStatus | EnumLeaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaseStatus[] | ListEnumLeaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaseStatus[] | ListEnumLeaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaseStatusFilter<$PrismaModel> | $Enums.LeaseStatus
  }

  export type UnitScalarRelationFilter = {
    is?: UnitWhereInput
    isNot?: UnitWhereInput
  }

  export type PropertyNullableScalarRelationFilter = {
    is?: PropertyWhereInput | null
    isNot?: PropertyWhereInput | null
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type TransactionsListRelationFilter = {
    every?: TransactionsWhereInput
    some?: TransactionsWhereInput
    none?: TransactionsWhereInput
  }

  export type MaintenanceRequestListRelationFilter = {
    every?: MaintenanceRequestWhereInput
    some?: MaintenanceRequestWhereInput
    none?: MaintenanceRequestWhereInput
  }

  export type LeaseDocumentListRelationFilter = {
    every?: LeaseDocumentWhereInput
    some?: LeaseDocumentWhereInput
    none?: LeaseDocumentWhereInput
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MaintenanceRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeaseDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeaseCountOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    tenantId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    rent?: SortOrder
    deposit?: SortOrder
    rentDueCurrency?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    propertyId?: SortOrder
  }

  export type LeaseAvgOrderByAggregateInput = {
    rent?: SortOrder
    deposit?: SortOrder
  }

  export type LeaseMaxOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    tenantId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    rent?: SortOrder
    deposit?: SortOrder
    rentDueCurrency?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    propertyId?: SortOrder
  }

  export type LeaseMinOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    tenantId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    rent?: SortOrder
    deposit?: SortOrder
    rentDueCurrency?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    propertyId?: SortOrder
  }

  export type LeaseSumOrderByAggregateInput = {
    rent?: SortOrder
    deposit?: SortOrder
  }

  export type EnumLeaseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaseStatus | EnumLeaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaseStatus[] | ListEnumLeaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaseStatus[] | ListEnumLeaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaseStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeaseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaseStatusFilter<$PrismaModel>
    _max?: NestedEnumLeaseStatusFilter<$PrismaModel>
  }

  export type EnumInvoiceCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceCategory | EnumInvoiceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceCategory[] | ListEnumInvoiceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceCategory[] | ListEnumInvoiceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceCategoryFilter<$PrismaModel> | $Enums.InvoiceCategory
  }

  export type EnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type LeaseScalarRelationFilter = {
    is?: LeaseWhereInput
    isNot?: LeaseWhereInput
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    leaseId?: SortOrder
    description?: SortOrder
    dueAmount?: SortOrder
    dueDate?: SortOrder
    category?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    dueAmount?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    leaseId?: SortOrder
    description?: SortOrder
    dueAmount?: SortOrder
    dueDate?: SortOrder
    category?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    leaseId?: SortOrder
    description?: SortOrder
    dueAmount?: SortOrder
    dueDate?: SortOrder
    category?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    dueAmount?: SortOrder
  }

  export type EnumInvoiceCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceCategory | EnumInvoiceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceCategory[] | ListEnumInvoiceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceCategory[] | ListEnumInvoiceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceCategoryWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceCategoryFilter<$PrismaModel>
    _max?: NestedEnumInvoiceCategoryFilter<$PrismaModel>
  }

  export type EnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type InvoiceNullableScalarRelationFilter = {
    is?: InvoiceWhereInput | null
    isNot?: InvoiceWhereInput | null
  }

  export type TransactionsCountOrderByAggregateInput = {
    id?: SortOrder
    leaseId?: SortOrder
    description?: SortOrder
    amountPaid?: SortOrder
    referenceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invoiceId?: SortOrder
  }

  export type TransactionsAvgOrderByAggregateInput = {
    amountPaid?: SortOrder
  }

  export type TransactionsMaxOrderByAggregateInput = {
    id?: SortOrder
    leaseId?: SortOrder
    description?: SortOrder
    amountPaid?: SortOrder
    referenceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invoiceId?: SortOrder
  }

  export type TransactionsMinOrderByAggregateInput = {
    id?: SortOrder
    leaseId?: SortOrder
    description?: SortOrder
    amountPaid?: SortOrder
    referenceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invoiceId?: SortOrder
  }

  export type TransactionsSumOrderByAggregateInput = {
    amountPaid?: SortOrder
  }

  export type TenantLeaseCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    leaseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantLeaseMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    leaseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantLeaseMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    leaseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumMaintenanceRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenanceRequestStatus | EnumMaintenanceRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MaintenanceRequestStatus[] | ListEnumMaintenanceRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaintenanceRequestStatus[] | ListEnumMaintenanceRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMaintenanceRequestStatusFilter<$PrismaModel> | $Enums.MaintenanceRequestStatus
  }

  export type EnumMaintenanceRequestPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenanceRequestPriority | EnumMaintenanceRequestPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.MaintenanceRequestPriority[] | ListEnumMaintenanceRequestPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaintenanceRequestPriority[] | ListEnumMaintenanceRequestPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumMaintenanceRequestPriorityFilter<$PrismaModel> | $Enums.MaintenanceRequestPriority
  }

  export type MaintenanceRequestCountOrderByAggregateInput = {
    id?: SortOrder
    leaseId?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaintenanceRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    leaseId?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaintenanceRequestMinOrderByAggregateInput = {
    id?: SortOrder
    leaseId?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumMaintenanceRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenanceRequestStatus | EnumMaintenanceRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MaintenanceRequestStatus[] | ListEnumMaintenanceRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaintenanceRequestStatus[] | ListEnumMaintenanceRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMaintenanceRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.MaintenanceRequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMaintenanceRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumMaintenanceRequestStatusFilter<$PrismaModel>
  }

  export type EnumMaintenanceRequestPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenanceRequestPriority | EnumMaintenanceRequestPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.MaintenanceRequestPriority[] | ListEnumMaintenanceRequestPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaintenanceRequestPriority[] | ListEnumMaintenanceRequestPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumMaintenanceRequestPriorityWithAggregatesFilter<$PrismaModel> | $Enums.MaintenanceRequestPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMaintenanceRequestPriorityFilter<$PrismaModel>
    _max?: NestedEnumMaintenanceRequestPriorityFilter<$PrismaModel>
  }

  export type EnumTenantDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantDocumentType | EnumTenantDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TenantDocumentType[] | ListEnumTenantDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantDocumentType[] | ListEnumTenantDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantDocumentTypeFilter<$PrismaModel> | $Enums.TenantDocumentType
  }

  export type TenantDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    documentType?: SortOrder
    documentUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    documentType?: SortOrder
    documentUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    documentType?: SortOrder
    documentUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTenantDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantDocumentType | EnumTenantDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TenantDocumentType[] | ListEnumTenantDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantDocumentType[] | ListEnumTenantDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.TenantDocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTenantDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumTenantDocumentTypeFilter<$PrismaModel>
  }

  export type EnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type LeaseDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    leaseId?: SortOrder
    documentType?: SortOrder
    documentUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaseDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    leaseId?: SortOrder
    documentType?: SortOrder
    documentUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaseDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    leaseId?: SortOrder
    documentType?: SortOrder
    documentUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type PropertyDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    documentType?: SortOrder
    documentUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    documentType?: SortOrder
    documentUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    documentType?: SortOrder
    documentUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaseCreateNestedManyWithoutTenantInput = {
    create?: XOR<LeaseCreateWithoutTenantInput, LeaseUncheckedCreateWithoutTenantInput> | LeaseCreateWithoutTenantInput[] | LeaseUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: LeaseCreateOrConnectWithoutTenantInput | LeaseCreateOrConnectWithoutTenantInput[]
    createMany?: LeaseCreateManyTenantInputEnvelope
    connect?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
  }

  export type TenantLeaseCreateNestedManyWithoutTenantInput = {
    create?: XOR<TenantLeaseCreateWithoutTenantInput, TenantLeaseUncheckedCreateWithoutTenantInput> | TenantLeaseCreateWithoutTenantInput[] | TenantLeaseUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantLeaseCreateOrConnectWithoutTenantInput | TenantLeaseCreateOrConnectWithoutTenantInput[]
    createMany?: TenantLeaseCreateManyTenantInputEnvelope
    connect?: TenantLeaseWhereUniqueInput | TenantLeaseWhereUniqueInput[]
  }

  export type TenantDocumentCreateNestedManyWithoutTenantInput = {
    create?: XOR<TenantDocumentCreateWithoutTenantInput, TenantDocumentUncheckedCreateWithoutTenantInput> | TenantDocumentCreateWithoutTenantInput[] | TenantDocumentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantDocumentCreateOrConnectWithoutTenantInput | TenantDocumentCreateOrConnectWithoutTenantInput[]
    createMany?: TenantDocumentCreateManyTenantInputEnvelope
    connect?: TenantDocumentWhereUniqueInput | TenantDocumentWhereUniqueInput[]
  }

  export type TenantEmergencyContactCreateNestedManyWithoutTenantInput = {
    create?: XOR<TenantEmergencyContactCreateWithoutTenantInput, TenantEmergencyContactUncheckedCreateWithoutTenantInput> | TenantEmergencyContactCreateWithoutTenantInput[] | TenantEmergencyContactUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantEmergencyContactCreateOrConnectWithoutTenantInput | TenantEmergencyContactCreateOrConnectWithoutTenantInput[]
    createMany?: TenantEmergencyContactCreateManyTenantInputEnvelope
    connect?: TenantEmergencyContactWhereUniqueInput | TenantEmergencyContactWhereUniqueInput[]
  }

  export type TenantIncomeCreateNestedManyWithoutTenantInput = {
    create?: XOR<TenantIncomeCreateWithoutTenantInput, TenantIncomeUncheckedCreateWithoutTenantInput> | TenantIncomeCreateWithoutTenantInput[] | TenantIncomeUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantIncomeCreateOrConnectWithoutTenantInput | TenantIncomeCreateOrConnectWithoutTenantInput[]
    createMany?: TenantIncomeCreateManyTenantInputEnvelope
    connect?: TenantIncomeWhereUniqueInput | TenantIncomeWhereUniqueInput[]
  }

  export type LeaseUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<LeaseCreateWithoutTenantInput, LeaseUncheckedCreateWithoutTenantInput> | LeaseCreateWithoutTenantInput[] | LeaseUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: LeaseCreateOrConnectWithoutTenantInput | LeaseCreateOrConnectWithoutTenantInput[]
    createMany?: LeaseCreateManyTenantInputEnvelope
    connect?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
  }

  export type TenantLeaseUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<TenantLeaseCreateWithoutTenantInput, TenantLeaseUncheckedCreateWithoutTenantInput> | TenantLeaseCreateWithoutTenantInput[] | TenantLeaseUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantLeaseCreateOrConnectWithoutTenantInput | TenantLeaseCreateOrConnectWithoutTenantInput[]
    createMany?: TenantLeaseCreateManyTenantInputEnvelope
    connect?: TenantLeaseWhereUniqueInput | TenantLeaseWhereUniqueInput[]
  }

  export type TenantDocumentUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<TenantDocumentCreateWithoutTenantInput, TenantDocumentUncheckedCreateWithoutTenantInput> | TenantDocumentCreateWithoutTenantInput[] | TenantDocumentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantDocumentCreateOrConnectWithoutTenantInput | TenantDocumentCreateOrConnectWithoutTenantInput[]
    createMany?: TenantDocumentCreateManyTenantInputEnvelope
    connect?: TenantDocumentWhereUniqueInput | TenantDocumentWhereUniqueInput[]
  }

  export type TenantEmergencyContactUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<TenantEmergencyContactCreateWithoutTenantInput, TenantEmergencyContactUncheckedCreateWithoutTenantInput> | TenantEmergencyContactCreateWithoutTenantInput[] | TenantEmergencyContactUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantEmergencyContactCreateOrConnectWithoutTenantInput | TenantEmergencyContactCreateOrConnectWithoutTenantInput[]
    createMany?: TenantEmergencyContactCreateManyTenantInputEnvelope
    connect?: TenantEmergencyContactWhereUniqueInput | TenantEmergencyContactWhereUniqueInput[]
  }

  export type TenantIncomeUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<TenantIncomeCreateWithoutTenantInput, TenantIncomeUncheckedCreateWithoutTenantInput> | TenantIncomeCreateWithoutTenantInput[] | TenantIncomeUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantIncomeCreateOrConnectWithoutTenantInput | TenantIncomeCreateOrConnectWithoutTenantInput[]
    createMany?: TenantIncomeCreateManyTenantInputEnvelope
    connect?: TenantIncomeWhereUniqueInput | TenantIncomeWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type LeaseUpdateManyWithoutTenantNestedInput = {
    create?: XOR<LeaseCreateWithoutTenantInput, LeaseUncheckedCreateWithoutTenantInput> | LeaseCreateWithoutTenantInput[] | LeaseUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: LeaseCreateOrConnectWithoutTenantInput | LeaseCreateOrConnectWithoutTenantInput[]
    upsert?: LeaseUpsertWithWhereUniqueWithoutTenantInput | LeaseUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: LeaseCreateManyTenantInputEnvelope
    set?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    disconnect?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    delete?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    connect?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    update?: LeaseUpdateWithWhereUniqueWithoutTenantInput | LeaseUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: LeaseUpdateManyWithWhereWithoutTenantInput | LeaseUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: LeaseScalarWhereInput | LeaseScalarWhereInput[]
  }

  export type TenantLeaseUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TenantLeaseCreateWithoutTenantInput, TenantLeaseUncheckedCreateWithoutTenantInput> | TenantLeaseCreateWithoutTenantInput[] | TenantLeaseUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantLeaseCreateOrConnectWithoutTenantInput | TenantLeaseCreateOrConnectWithoutTenantInput[]
    upsert?: TenantLeaseUpsertWithWhereUniqueWithoutTenantInput | TenantLeaseUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TenantLeaseCreateManyTenantInputEnvelope
    set?: TenantLeaseWhereUniqueInput | TenantLeaseWhereUniqueInput[]
    disconnect?: TenantLeaseWhereUniqueInput | TenantLeaseWhereUniqueInput[]
    delete?: TenantLeaseWhereUniqueInput | TenantLeaseWhereUniqueInput[]
    connect?: TenantLeaseWhereUniqueInput | TenantLeaseWhereUniqueInput[]
    update?: TenantLeaseUpdateWithWhereUniqueWithoutTenantInput | TenantLeaseUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TenantLeaseUpdateManyWithWhereWithoutTenantInput | TenantLeaseUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TenantLeaseScalarWhereInput | TenantLeaseScalarWhereInput[]
  }

  export type TenantDocumentUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TenantDocumentCreateWithoutTenantInput, TenantDocumentUncheckedCreateWithoutTenantInput> | TenantDocumentCreateWithoutTenantInput[] | TenantDocumentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantDocumentCreateOrConnectWithoutTenantInput | TenantDocumentCreateOrConnectWithoutTenantInput[]
    upsert?: TenantDocumentUpsertWithWhereUniqueWithoutTenantInput | TenantDocumentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TenantDocumentCreateManyTenantInputEnvelope
    set?: TenantDocumentWhereUniqueInput | TenantDocumentWhereUniqueInput[]
    disconnect?: TenantDocumentWhereUniqueInput | TenantDocumentWhereUniqueInput[]
    delete?: TenantDocumentWhereUniqueInput | TenantDocumentWhereUniqueInput[]
    connect?: TenantDocumentWhereUniqueInput | TenantDocumentWhereUniqueInput[]
    update?: TenantDocumentUpdateWithWhereUniqueWithoutTenantInput | TenantDocumentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TenantDocumentUpdateManyWithWhereWithoutTenantInput | TenantDocumentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TenantDocumentScalarWhereInput | TenantDocumentScalarWhereInput[]
  }

  export type TenantEmergencyContactUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TenantEmergencyContactCreateWithoutTenantInput, TenantEmergencyContactUncheckedCreateWithoutTenantInput> | TenantEmergencyContactCreateWithoutTenantInput[] | TenantEmergencyContactUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantEmergencyContactCreateOrConnectWithoutTenantInput | TenantEmergencyContactCreateOrConnectWithoutTenantInput[]
    upsert?: TenantEmergencyContactUpsertWithWhereUniqueWithoutTenantInput | TenantEmergencyContactUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TenantEmergencyContactCreateManyTenantInputEnvelope
    set?: TenantEmergencyContactWhereUniqueInput | TenantEmergencyContactWhereUniqueInput[]
    disconnect?: TenantEmergencyContactWhereUniqueInput | TenantEmergencyContactWhereUniqueInput[]
    delete?: TenantEmergencyContactWhereUniqueInput | TenantEmergencyContactWhereUniqueInput[]
    connect?: TenantEmergencyContactWhereUniqueInput | TenantEmergencyContactWhereUniqueInput[]
    update?: TenantEmergencyContactUpdateWithWhereUniqueWithoutTenantInput | TenantEmergencyContactUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TenantEmergencyContactUpdateManyWithWhereWithoutTenantInput | TenantEmergencyContactUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TenantEmergencyContactScalarWhereInput | TenantEmergencyContactScalarWhereInput[]
  }

  export type TenantIncomeUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TenantIncomeCreateWithoutTenantInput, TenantIncomeUncheckedCreateWithoutTenantInput> | TenantIncomeCreateWithoutTenantInput[] | TenantIncomeUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantIncomeCreateOrConnectWithoutTenantInput | TenantIncomeCreateOrConnectWithoutTenantInput[]
    upsert?: TenantIncomeUpsertWithWhereUniqueWithoutTenantInput | TenantIncomeUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TenantIncomeCreateManyTenantInputEnvelope
    set?: TenantIncomeWhereUniqueInput | TenantIncomeWhereUniqueInput[]
    disconnect?: TenantIncomeWhereUniqueInput | TenantIncomeWhereUniqueInput[]
    delete?: TenantIncomeWhereUniqueInput | TenantIncomeWhereUniqueInput[]
    connect?: TenantIncomeWhereUniqueInput | TenantIncomeWhereUniqueInput[]
    update?: TenantIncomeUpdateWithWhereUniqueWithoutTenantInput | TenantIncomeUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TenantIncomeUpdateManyWithWhereWithoutTenantInput | TenantIncomeUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TenantIncomeScalarWhereInput | TenantIncomeScalarWhereInput[]
  }

  export type LeaseUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<LeaseCreateWithoutTenantInput, LeaseUncheckedCreateWithoutTenantInput> | LeaseCreateWithoutTenantInput[] | LeaseUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: LeaseCreateOrConnectWithoutTenantInput | LeaseCreateOrConnectWithoutTenantInput[]
    upsert?: LeaseUpsertWithWhereUniqueWithoutTenantInput | LeaseUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: LeaseCreateManyTenantInputEnvelope
    set?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    disconnect?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    delete?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    connect?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    update?: LeaseUpdateWithWhereUniqueWithoutTenantInput | LeaseUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: LeaseUpdateManyWithWhereWithoutTenantInput | LeaseUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: LeaseScalarWhereInput | LeaseScalarWhereInput[]
  }

  export type TenantLeaseUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TenantLeaseCreateWithoutTenantInput, TenantLeaseUncheckedCreateWithoutTenantInput> | TenantLeaseCreateWithoutTenantInput[] | TenantLeaseUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantLeaseCreateOrConnectWithoutTenantInput | TenantLeaseCreateOrConnectWithoutTenantInput[]
    upsert?: TenantLeaseUpsertWithWhereUniqueWithoutTenantInput | TenantLeaseUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TenantLeaseCreateManyTenantInputEnvelope
    set?: TenantLeaseWhereUniqueInput | TenantLeaseWhereUniqueInput[]
    disconnect?: TenantLeaseWhereUniqueInput | TenantLeaseWhereUniqueInput[]
    delete?: TenantLeaseWhereUniqueInput | TenantLeaseWhereUniqueInput[]
    connect?: TenantLeaseWhereUniqueInput | TenantLeaseWhereUniqueInput[]
    update?: TenantLeaseUpdateWithWhereUniqueWithoutTenantInput | TenantLeaseUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TenantLeaseUpdateManyWithWhereWithoutTenantInput | TenantLeaseUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TenantLeaseScalarWhereInput | TenantLeaseScalarWhereInput[]
  }

  export type TenantDocumentUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TenantDocumentCreateWithoutTenantInput, TenantDocumentUncheckedCreateWithoutTenantInput> | TenantDocumentCreateWithoutTenantInput[] | TenantDocumentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantDocumentCreateOrConnectWithoutTenantInput | TenantDocumentCreateOrConnectWithoutTenantInput[]
    upsert?: TenantDocumentUpsertWithWhereUniqueWithoutTenantInput | TenantDocumentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TenantDocumentCreateManyTenantInputEnvelope
    set?: TenantDocumentWhereUniqueInput | TenantDocumentWhereUniqueInput[]
    disconnect?: TenantDocumentWhereUniqueInput | TenantDocumentWhereUniqueInput[]
    delete?: TenantDocumentWhereUniqueInput | TenantDocumentWhereUniqueInput[]
    connect?: TenantDocumentWhereUniqueInput | TenantDocumentWhereUniqueInput[]
    update?: TenantDocumentUpdateWithWhereUniqueWithoutTenantInput | TenantDocumentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TenantDocumentUpdateManyWithWhereWithoutTenantInput | TenantDocumentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TenantDocumentScalarWhereInput | TenantDocumentScalarWhereInput[]
  }

  export type TenantEmergencyContactUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TenantEmergencyContactCreateWithoutTenantInput, TenantEmergencyContactUncheckedCreateWithoutTenantInput> | TenantEmergencyContactCreateWithoutTenantInput[] | TenantEmergencyContactUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantEmergencyContactCreateOrConnectWithoutTenantInput | TenantEmergencyContactCreateOrConnectWithoutTenantInput[]
    upsert?: TenantEmergencyContactUpsertWithWhereUniqueWithoutTenantInput | TenantEmergencyContactUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TenantEmergencyContactCreateManyTenantInputEnvelope
    set?: TenantEmergencyContactWhereUniqueInput | TenantEmergencyContactWhereUniqueInput[]
    disconnect?: TenantEmergencyContactWhereUniqueInput | TenantEmergencyContactWhereUniqueInput[]
    delete?: TenantEmergencyContactWhereUniqueInput | TenantEmergencyContactWhereUniqueInput[]
    connect?: TenantEmergencyContactWhereUniqueInput | TenantEmergencyContactWhereUniqueInput[]
    update?: TenantEmergencyContactUpdateWithWhereUniqueWithoutTenantInput | TenantEmergencyContactUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TenantEmergencyContactUpdateManyWithWhereWithoutTenantInput | TenantEmergencyContactUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TenantEmergencyContactScalarWhereInput | TenantEmergencyContactScalarWhereInput[]
  }

  export type TenantIncomeUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TenantIncomeCreateWithoutTenantInput, TenantIncomeUncheckedCreateWithoutTenantInput> | TenantIncomeCreateWithoutTenantInput[] | TenantIncomeUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantIncomeCreateOrConnectWithoutTenantInput | TenantIncomeCreateOrConnectWithoutTenantInput[]
    upsert?: TenantIncomeUpsertWithWhereUniqueWithoutTenantInput | TenantIncomeUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TenantIncomeCreateManyTenantInputEnvelope
    set?: TenantIncomeWhereUniqueInput | TenantIncomeWhereUniqueInput[]
    disconnect?: TenantIncomeWhereUniqueInput | TenantIncomeWhereUniqueInput[]
    delete?: TenantIncomeWhereUniqueInput | TenantIncomeWhereUniqueInput[]
    connect?: TenantIncomeWhereUniqueInput | TenantIncomeWhereUniqueInput[]
    update?: TenantIncomeUpdateWithWhereUniqueWithoutTenantInput | TenantIncomeUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TenantIncomeUpdateManyWithWhereWithoutTenantInput | TenantIncomeUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TenantIncomeScalarWhereInput | TenantIncomeScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutTenantEmergencyContactInput = {
    create?: XOR<TenantCreateWithoutTenantEmergencyContactInput, TenantUncheckedCreateWithoutTenantEmergencyContactInput>
    connectOrCreate?: TenantCreateOrConnectWithoutTenantEmergencyContactInput
    connect?: TenantWhereUniqueInput
  }

  export type EnumTenantRelationshipFieldUpdateOperationsInput = {
    set?: $Enums.TenantRelationship
  }

  export type TenantUpdateOneRequiredWithoutTenantEmergencyContactNestedInput = {
    create?: XOR<TenantCreateWithoutTenantEmergencyContactInput, TenantUncheckedCreateWithoutTenantEmergencyContactInput>
    connectOrCreate?: TenantCreateOrConnectWithoutTenantEmergencyContactInput
    upsert?: TenantUpsertWithoutTenantEmergencyContactInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutTenantEmergencyContactInput, TenantUpdateWithoutTenantEmergencyContactInput>, TenantUncheckedUpdateWithoutTenantEmergencyContactInput>
  }

  export type TenantCreateNestedOneWithoutTenantIncomeInput = {
    create?: XOR<TenantCreateWithoutTenantIncomeInput, TenantUncheckedCreateWithoutTenantIncomeInput>
    connectOrCreate?: TenantCreateOrConnectWithoutTenantIncomeInput
    connect?: TenantWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumTenantIncomeTypeFieldUpdateOperationsInput = {
    set?: $Enums.TenantIncomeType
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type TenantUpdateOneRequiredWithoutTenantIncomeNestedInput = {
    create?: XOR<TenantCreateWithoutTenantIncomeInput, TenantUncheckedCreateWithoutTenantIncomeInput>
    connectOrCreate?: TenantCreateOrConnectWithoutTenantIncomeInput
    upsert?: TenantUpsertWithoutTenantIncomeInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutTenantIncomeInput, TenantUpdateWithoutTenantIncomeInput>, TenantUncheckedUpdateWithoutTenantIncomeInput>
  }

  export type PropertyCreateNestedManyWithoutOwnerInput = {
    create?: XOR<PropertyCreateWithoutOwnerInput, PropertyUncheckedCreateWithoutOwnerInput> | PropertyCreateWithoutOwnerInput[] | PropertyUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutOwnerInput | PropertyCreateOrConnectWithoutOwnerInput[]
    createMany?: PropertyCreateManyOwnerInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type PropertyUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<PropertyCreateWithoutOwnerInput, PropertyUncheckedCreateWithoutOwnerInput> | PropertyCreateWithoutOwnerInput[] | PropertyUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutOwnerInput | PropertyCreateOrConnectWithoutOwnerInput[]
    createMany?: PropertyCreateManyOwnerInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type PropertyUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<PropertyCreateWithoutOwnerInput, PropertyUncheckedCreateWithoutOwnerInput> | PropertyCreateWithoutOwnerInput[] | PropertyUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutOwnerInput | PropertyCreateOrConnectWithoutOwnerInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutOwnerInput | PropertyUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: PropertyCreateManyOwnerInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutOwnerInput | PropertyUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutOwnerInput | PropertyUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type PropertyUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<PropertyCreateWithoutOwnerInput, PropertyUncheckedCreateWithoutOwnerInput> | PropertyCreateWithoutOwnerInput[] | PropertyUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutOwnerInput | PropertyCreateOrConnectWithoutOwnerInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutOwnerInput | PropertyUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: PropertyCreateManyOwnerInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutOwnerInput | PropertyUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutOwnerInput | PropertyUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type PropertyCreatefeaturesInput = {
    set: string[]
  }

  export type PropertyCreateamenitiesInput = {
    set: string[]
  }

  export type LandlordCreateNestedOneWithoutPropertyInput = {
    create?: XOR<LandlordCreateWithoutPropertyInput, LandlordUncheckedCreateWithoutPropertyInput>
    connectOrCreate?: LandlordCreateOrConnectWithoutPropertyInput
    connect?: LandlordWhereUniqueInput
  }

  export type UnitCreateNestedManyWithoutPropertyInput = {
    create?: XOR<UnitCreateWithoutPropertyInput, UnitUncheckedCreateWithoutPropertyInput> | UnitCreateWithoutPropertyInput[] | UnitUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutPropertyInput | UnitCreateOrConnectWithoutPropertyInput[]
    createMany?: UnitCreateManyPropertyInputEnvelope
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
  }

  export type PropertyDocumentCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyDocumentCreateWithoutPropertyInput, PropertyDocumentUncheckedCreateWithoutPropertyInput> | PropertyDocumentCreateWithoutPropertyInput[] | PropertyDocumentUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyDocumentCreateOrConnectWithoutPropertyInput | PropertyDocumentCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyDocumentCreateManyPropertyInputEnvelope
    connect?: PropertyDocumentWhereUniqueInput | PropertyDocumentWhereUniqueInput[]
  }

  export type LeaseCreateNestedManyWithoutPropertyInput = {
    create?: XOR<LeaseCreateWithoutPropertyInput, LeaseUncheckedCreateWithoutPropertyInput> | LeaseCreateWithoutPropertyInput[] | LeaseUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: LeaseCreateOrConnectWithoutPropertyInput | LeaseCreateOrConnectWithoutPropertyInput[]
    createMany?: LeaseCreateManyPropertyInputEnvelope
    connect?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
  }

  export type UnitUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<UnitCreateWithoutPropertyInput, UnitUncheckedCreateWithoutPropertyInput> | UnitCreateWithoutPropertyInput[] | UnitUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutPropertyInput | UnitCreateOrConnectWithoutPropertyInput[]
    createMany?: UnitCreateManyPropertyInputEnvelope
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
  }

  export type PropertyDocumentUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyDocumentCreateWithoutPropertyInput, PropertyDocumentUncheckedCreateWithoutPropertyInput> | PropertyDocumentCreateWithoutPropertyInput[] | PropertyDocumentUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyDocumentCreateOrConnectWithoutPropertyInput | PropertyDocumentCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyDocumentCreateManyPropertyInputEnvelope
    connect?: PropertyDocumentWhereUniqueInput | PropertyDocumentWhereUniqueInput[]
  }

  export type LeaseUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<LeaseCreateWithoutPropertyInput, LeaseUncheckedCreateWithoutPropertyInput> | LeaseCreateWithoutPropertyInput[] | LeaseUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: LeaseCreateOrConnectWithoutPropertyInput | LeaseCreateOrConnectWithoutPropertyInput[]
    createMany?: LeaseCreateManyPropertyInputEnvelope
    connect?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
  }

  export type EnumPropertyTypeFieldUpdateOperationsInput = {
    set?: $Enums.PropertyType
  }

  export type EnumPropertyStatusFieldUpdateOperationsInput = {
    set?: $Enums.PropertyStatus
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumLeaseTermTypeFieldUpdateOperationsInput = {
    set?: $Enums.LeaseTermType
  }

  export type PropertyUpdatefeaturesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PropertyUpdateamenitiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type LandlordUpdateOneRequiredWithoutPropertyNestedInput = {
    create?: XOR<LandlordCreateWithoutPropertyInput, LandlordUncheckedCreateWithoutPropertyInput>
    connectOrCreate?: LandlordCreateOrConnectWithoutPropertyInput
    upsert?: LandlordUpsertWithoutPropertyInput
    connect?: LandlordWhereUniqueInput
    update?: XOR<XOR<LandlordUpdateToOneWithWhereWithoutPropertyInput, LandlordUpdateWithoutPropertyInput>, LandlordUncheckedUpdateWithoutPropertyInput>
  }

  export type UnitUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<UnitCreateWithoutPropertyInput, UnitUncheckedCreateWithoutPropertyInput> | UnitCreateWithoutPropertyInput[] | UnitUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutPropertyInput | UnitCreateOrConnectWithoutPropertyInput[]
    upsert?: UnitUpsertWithWhereUniqueWithoutPropertyInput | UnitUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: UnitCreateManyPropertyInputEnvelope
    set?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    disconnect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    delete?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    update?: UnitUpdateWithWhereUniqueWithoutPropertyInput | UnitUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: UnitUpdateManyWithWhereWithoutPropertyInput | UnitUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: UnitScalarWhereInput | UnitScalarWhereInput[]
  }

  export type PropertyDocumentUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyDocumentCreateWithoutPropertyInput, PropertyDocumentUncheckedCreateWithoutPropertyInput> | PropertyDocumentCreateWithoutPropertyInput[] | PropertyDocumentUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyDocumentCreateOrConnectWithoutPropertyInput | PropertyDocumentCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyDocumentUpsertWithWhereUniqueWithoutPropertyInput | PropertyDocumentUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyDocumentCreateManyPropertyInputEnvelope
    set?: PropertyDocumentWhereUniqueInput | PropertyDocumentWhereUniqueInput[]
    disconnect?: PropertyDocumentWhereUniqueInput | PropertyDocumentWhereUniqueInput[]
    delete?: PropertyDocumentWhereUniqueInput | PropertyDocumentWhereUniqueInput[]
    connect?: PropertyDocumentWhereUniqueInput | PropertyDocumentWhereUniqueInput[]
    update?: PropertyDocumentUpdateWithWhereUniqueWithoutPropertyInput | PropertyDocumentUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyDocumentUpdateManyWithWhereWithoutPropertyInput | PropertyDocumentUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyDocumentScalarWhereInput | PropertyDocumentScalarWhereInput[]
  }

  export type LeaseUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<LeaseCreateWithoutPropertyInput, LeaseUncheckedCreateWithoutPropertyInput> | LeaseCreateWithoutPropertyInput[] | LeaseUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: LeaseCreateOrConnectWithoutPropertyInput | LeaseCreateOrConnectWithoutPropertyInput[]
    upsert?: LeaseUpsertWithWhereUniqueWithoutPropertyInput | LeaseUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: LeaseCreateManyPropertyInputEnvelope
    set?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    disconnect?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    delete?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    connect?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    update?: LeaseUpdateWithWhereUniqueWithoutPropertyInput | LeaseUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: LeaseUpdateManyWithWhereWithoutPropertyInput | LeaseUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: LeaseScalarWhereInput | LeaseScalarWhereInput[]
  }

  export type UnitUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<UnitCreateWithoutPropertyInput, UnitUncheckedCreateWithoutPropertyInput> | UnitCreateWithoutPropertyInput[] | UnitUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutPropertyInput | UnitCreateOrConnectWithoutPropertyInput[]
    upsert?: UnitUpsertWithWhereUniqueWithoutPropertyInput | UnitUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: UnitCreateManyPropertyInputEnvelope
    set?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    disconnect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    delete?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    update?: UnitUpdateWithWhereUniqueWithoutPropertyInput | UnitUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: UnitUpdateManyWithWhereWithoutPropertyInput | UnitUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: UnitScalarWhereInput | UnitScalarWhereInput[]
  }

  export type PropertyDocumentUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyDocumentCreateWithoutPropertyInput, PropertyDocumentUncheckedCreateWithoutPropertyInput> | PropertyDocumentCreateWithoutPropertyInput[] | PropertyDocumentUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyDocumentCreateOrConnectWithoutPropertyInput | PropertyDocumentCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyDocumentUpsertWithWhereUniqueWithoutPropertyInput | PropertyDocumentUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyDocumentCreateManyPropertyInputEnvelope
    set?: PropertyDocumentWhereUniqueInput | PropertyDocumentWhereUniqueInput[]
    disconnect?: PropertyDocumentWhereUniqueInput | PropertyDocumentWhereUniqueInput[]
    delete?: PropertyDocumentWhereUniqueInput | PropertyDocumentWhereUniqueInput[]
    connect?: PropertyDocumentWhereUniqueInput | PropertyDocumentWhereUniqueInput[]
    update?: PropertyDocumentUpdateWithWhereUniqueWithoutPropertyInput | PropertyDocumentUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyDocumentUpdateManyWithWhereWithoutPropertyInput | PropertyDocumentUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyDocumentScalarWhereInput | PropertyDocumentScalarWhereInput[]
  }

  export type LeaseUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<LeaseCreateWithoutPropertyInput, LeaseUncheckedCreateWithoutPropertyInput> | LeaseCreateWithoutPropertyInput[] | LeaseUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: LeaseCreateOrConnectWithoutPropertyInput | LeaseCreateOrConnectWithoutPropertyInput[]
    upsert?: LeaseUpsertWithWhereUniqueWithoutPropertyInput | LeaseUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: LeaseCreateManyPropertyInputEnvelope
    set?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    disconnect?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    delete?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    connect?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    update?: LeaseUpdateWithWhereUniqueWithoutPropertyInput | LeaseUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: LeaseUpdateManyWithWhereWithoutPropertyInput | LeaseUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: LeaseScalarWhereInput | LeaseScalarWhereInput[]
  }

  export type PropertyCreateNestedOneWithoutUnitInput = {
    create?: XOR<PropertyCreateWithoutUnitInput, PropertyUncheckedCreateWithoutUnitInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutUnitInput
    connect?: PropertyWhereUniqueInput
  }

  export type LeaseCreateNestedManyWithoutUnitInput = {
    create?: XOR<LeaseCreateWithoutUnitInput, LeaseUncheckedCreateWithoutUnitInput> | LeaseCreateWithoutUnitInput[] | LeaseUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: LeaseCreateOrConnectWithoutUnitInput | LeaseCreateOrConnectWithoutUnitInput[]
    createMany?: LeaseCreateManyUnitInputEnvelope
    connect?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
  }

  export type LeaseUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<LeaseCreateWithoutUnitInput, LeaseUncheckedCreateWithoutUnitInput> | LeaseCreateWithoutUnitInput[] | LeaseUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: LeaseCreateOrConnectWithoutUnitInput | LeaseCreateOrConnectWithoutUnitInput[]
    createMany?: LeaseCreateManyUnitInputEnvelope
    connect?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
  }

  export type PropertyUpdateOneRequiredWithoutUnitNestedInput = {
    create?: XOR<PropertyCreateWithoutUnitInput, PropertyUncheckedCreateWithoutUnitInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutUnitInput
    upsert?: PropertyUpsertWithoutUnitInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutUnitInput, PropertyUpdateWithoutUnitInput>, PropertyUncheckedUpdateWithoutUnitInput>
  }

  export type LeaseUpdateManyWithoutUnitNestedInput = {
    create?: XOR<LeaseCreateWithoutUnitInput, LeaseUncheckedCreateWithoutUnitInput> | LeaseCreateWithoutUnitInput[] | LeaseUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: LeaseCreateOrConnectWithoutUnitInput | LeaseCreateOrConnectWithoutUnitInput[]
    upsert?: LeaseUpsertWithWhereUniqueWithoutUnitInput | LeaseUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: LeaseCreateManyUnitInputEnvelope
    set?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    disconnect?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    delete?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    connect?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    update?: LeaseUpdateWithWhereUniqueWithoutUnitInput | LeaseUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: LeaseUpdateManyWithWhereWithoutUnitInput | LeaseUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: LeaseScalarWhereInput | LeaseScalarWhereInput[]
  }

  export type LeaseUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<LeaseCreateWithoutUnitInput, LeaseUncheckedCreateWithoutUnitInput> | LeaseCreateWithoutUnitInput[] | LeaseUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: LeaseCreateOrConnectWithoutUnitInput | LeaseCreateOrConnectWithoutUnitInput[]
    upsert?: LeaseUpsertWithWhereUniqueWithoutUnitInput | LeaseUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: LeaseCreateManyUnitInputEnvelope
    set?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    disconnect?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    delete?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    connect?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    update?: LeaseUpdateWithWhereUniqueWithoutUnitInput | LeaseUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: LeaseUpdateManyWithWhereWithoutUnitInput | LeaseUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: LeaseScalarWhereInput | LeaseScalarWhereInput[]
  }

  export type UnitCreateNestedOneWithoutLeaseInput = {
    create?: XOR<UnitCreateWithoutLeaseInput, UnitUncheckedCreateWithoutLeaseInput>
    connectOrCreate?: UnitCreateOrConnectWithoutLeaseInput
    connect?: UnitWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutLeaseInput = {
    create?: XOR<TenantCreateWithoutLeaseInput, TenantUncheckedCreateWithoutLeaseInput>
    connectOrCreate?: TenantCreateOrConnectWithoutLeaseInput
    connect?: TenantWhereUniqueInput
  }

  export type TenantLeaseCreateNestedManyWithoutLeaseInput = {
    create?: XOR<TenantLeaseCreateWithoutLeaseInput, TenantLeaseUncheckedCreateWithoutLeaseInput> | TenantLeaseCreateWithoutLeaseInput[] | TenantLeaseUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: TenantLeaseCreateOrConnectWithoutLeaseInput | TenantLeaseCreateOrConnectWithoutLeaseInput[]
    createMany?: TenantLeaseCreateManyLeaseInputEnvelope
    connect?: TenantLeaseWhereUniqueInput | TenantLeaseWhereUniqueInput[]
  }

  export type PropertyCreateNestedOneWithoutLeaseInput = {
    create?: XOR<PropertyCreateWithoutLeaseInput, PropertyUncheckedCreateWithoutLeaseInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutLeaseInput
    connect?: PropertyWhereUniqueInput
  }

  export type InvoiceCreateNestedManyWithoutLeaseInput = {
    create?: XOR<InvoiceCreateWithoutLeaseInput, InvoiceUncheckedCreateWithoutLeaseInput> | InvoiceCreateWithoutLeaseInput[] | InvoiceUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutLeaseInput | InvoiceCreateOrConnectWithoutLeaseInput[]
    createMany?: InvoiceCreateManyLeaseInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type TransactionsCreateNestedManyWithoutLeaseInput = {
    create?: XOR<TransactionsCreateWithoutLeaseInput, TransactionsUncheckedCreateWithoutLeaseInput> | TransactionsCreateWithoutLeaseInput[] | TransactionsUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutLeaseInput | TransactionsCreateOrConnectWithoutLeaseInput[]
    createMany?: TransactionsCreateManyLeaseInputEnvelope
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
  }

  export type MaintenanceRequestCreateNestedManyWithoutLeaseInput = {
    create?: XOR<MaintenanceRequestCreateWithoutLeaseInput, MaintenanceRequestUncheckedCreateWithoutLeaseInput> | MaintenanceRequestCreateWithoutLeaseInput[] | MaintenanceRequestUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: MaintenanceRequestCreateOrConnectWithoutLeaseInput | MaintenanceRequestCreateOrConnectWithoutLeaseInput[]
    createMany?: MaintenanceRequestCreateManyLeaseInputEnvelope
    connect?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
  }

  export type LeaseDocumentCreateNestedManyWithoutLeaseInput = {
    create?: XOR<LeaseDocumentCreateWithoutLeaseInput, LeaseDocumentUncheckedCreateWithoutLeaseInput> | LeaseDocumentCreateWithoutLeaseInput[] | LeaseDocumentUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: LeaseDocumentCreateOrConnectWithoutLeaseInput | LeaseDocumentCreateOrConnectWithoutLeaseInput[]
    createMany?: LeaseDocumentCreateManyLeaseInputEnvelope
    connect?: LeaseDocumentWhereUniqueInput | LeaseDocumentWhereUniqueInput[]
  }

  export type TenantLeaseUncheckedCreateNestedManyWithoutLeaseInput = {
    create?: XOR<TenantLeaseCreateWithoutLeaseInput, TenantLeaseUncheckedCreateWithoutLeaseInput> | TenantLeaseCreateWithoutLeaseInput[] | TenantLeaseUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: TenantLeaseCreateOrConnectWithoutLeaseInput | TenantLeaseCreateOrConnectWithoutLeaseInput[]
    createMany?: TenantLeaseCreateManyLeaseInputEnvelope
    connect?: TenantLeaseWhereUniqueInput | TenantLeaseWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutLeaseInput = {
    create?: XOR<InvoiceCreateWithoutLeaseInput, InvoiceUncheckedCreateWithoutLeaseInput> | InvoiceCreateWithoutLeaseInput[] | InvoiceUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutLeaseInput | InvoiceCreateOrConnectWithoutLeaseInput[]
    createMany?: InvoiceCreateManyLeaseInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type TransactionsUncheckedCreateNestedManyWithoutLeaseInput = {
    create?: XOR<TransactionsCreateWithoutLeaseInput, TransactionsUncheckedCreateWithoutLeaseInput> | TransactionsCreateWithoutLeaseInput[] | TransactionsUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutLeaseInput | TransactionsCreateOrConnectWithoutLeaseInput[]
    createMany?: TransactionsCreateManyLeaseInputEnvelope
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
  }

  export type MaintenanceRequestUncheckedCreateNestedManyWithoutLeaseInput = {
    create?: XOR<MaintenanceRequestCreateWithoutLeaseInput, MaintenanceRequestUncheckedCreateWithoutLeaseInput> | MaintenanceRequestCreateWithoutLeaseInput[] | MaintenanceRequestUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: MaintenanceRequestCreateOrConnectWithoutLeaseInput | MaintenanceRequestCreateOrConnectWithoutLeaseInput[]
    createMany?: MaintenanceRequestCreateManyLeaseInputEnvelope
    connect?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
  }

  export type LeaseDocumentUncheckedCreateNestedManyWithoutLeaseInput = {
    create?: XOR<LeaseDocumentCreateWithoutLeaseInput, LeaseDocumentUncheckedCreateWithoutLeaseInput> | LeaseDocumentCreateWithoutLeaseInput[] | LeaseDocumentUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: LeaseDocumentCreateOrConnectWithoutLeaseInput | LeaseDocumentCreateOrConnectWithoutLeaseInput[]
    createMany?: LeaseDocumentCreateManyLeaseInputEnvelope
    connect?: LeaseDocumentWhereUniqueInput | LeaseDocumentWhereUniqueInput[]
  }

  export type EnumLeaseStatusFieldUpdateOperationsInput = {
    set?: $Enums.LeaseStatus
  }

  export type UnitUpdateOneRequiredWithoutLeaseNestedInput = {
    create?: XOR<UnitCreateWithoutLeaseInput, UnitUncheckedCreateWithoutLeaseInput>
    connectOrCreate?: UnitCreateOrConnectWithoutLeaseInput
    upsert?: UnitUpsertWithoutLeaseInput
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutLeaseInput, UnitUpdateWithoutLeaseInput>, UnitUncheckedUpdateWithoutLeaseInput>
  }

  export type TenantUpdateOneRequiredWithoutLeaseNestedInput = {
    create?: XOR<TenantCreateWithoutLeaseInput, TenantUncheckedCreateWithoutLeaseInput>
    connectOrCreate?: TenantCreateOrConnectWithoutLeaseInput
    upsert?: TenantUpsertWithoutLeaseInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutLeaseInput, TenantUpdateWithoutLeaseInput>, TenantUncheckedUpdateWithoutLeaseInput>
  }

  export type TenantLeaseUpdateManyWithoutLeaseNestedInput = {
    create?: XOR<TenantLeaseCreateWithoutLeaseInput, TenantLeaseUncheckedCreateWithoutLeaseInput> | TenantLeaseCreateWithoutLeaseInput[] | TenantLeaseUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: TenantLeaseCreateOrConnectWithoutLeaseInput | TenantLeaseCreateOrConnectWithoutLeaseInput[]
    upsert?: TenantLeaseUpsertWithWhereUniqueWithoutLeaseInput | TenantLeaseUpsertWithWhereUniqueWithoutLeaseInput[]
    createMany?: TenantLeaseCreateManyLeaseInputEnvelope
    set?: TenantLeaseWhereUniqueInput | TenantLeaseWhereUniqueInput[]
    disconnect?: TenantLeaseWhereUniqueInput | TenantLeaseWhereUniqueInput[]
    delete?: TenantLeaseWhereUniqueInput | TenantLeaseWhereUniqueInput[]
    connect?: TenantLeaseWhereUniqueInput | TenantLeaseWhereUniqueInput[]
    update?: TenantLeaseUpdateWithWhereUniqueWithoutLeaseInput | TenantLeaseUpdateWithWhereUniqueWithoutLeaseInput[]
    updateMany?: TenantLeaseUpdateManyWithWhereWithoutLeaseInput | TenantLeaseUpdateManyWithWhereWithoutLeaseInput[]
    deleteMany?: TenantLeaseScalarWhereInput | TenantLeaseScalarWhereInput[]
  }

  export type PropertyUpdateOneWithoutLeaseNestedInput = {
    create?: XOR<PropertyCreateWithoutLeaseInput, PropertyUncheckedCreateWithoutLeaseInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutLeaseInput
    upsert?: PropertyUpsertWithoutLeaseInput
    disconnect?: PropertyWhereInput | boolean
    delete?: PropertyWhereInput | boolean
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutLeaseInput, PropertyUpdateWithoutLeaseInput>, PropertyUncheckedUpdateWithoutLeaseInput>
  }

  export type InvoiceUpdateManyWithoutLeaseNestedInput = {
    create?: XOR<InvoiceCreateWithoutLeaseInput, InvoiceUncheckedCreateWithoutLeaseInput> | InvoiceCreateWithoutLeaseInput[] | InvoiceUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutLeaseInput | InvoiceCreateOrConnectWithoutLeaseInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutLeaseInput | InvoiceUpsertWithWhereUniqueWithoutLeaseInput[]
    createMany?: InvoiceCreateManyLeaseInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutLeaseInput | InvoiceUpdateWithWhereUniqueWithoutLeaseInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutLeaseInput | InvoiceUpdateManyWithWhereWithoutLeaseInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type TransactionsUpdateManyWithoutLeaseNestedInput = {
    create?: XOR<TransactionsCreateWithoutLeaseInput, TransactionsUncheckedCreateWithoutLeaseInput> | TransactionsCreateWithoutLeaseInput[] | TransactionsUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutLeaseInput | TransactionsCreateOrConnectWithoutLeaseInput[]
    upsert?: TransactionsUpsertWithWhereUniqueWithoutLeaseInput | TransactionsUpsertWithWhereUniqueWithoutLeaseInput[]
    createMany?: TransactionsCreateManyLeaseInputEnvelope
    set?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    disconnect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    delete?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    update?: TransactionsUpdateWithWhereUniqueWithoutLeaseInput | TransactionsUpdateWithWhereUniqueWithoutLeaseInput[]
    updateMany?: TransactionsUpdateManyWithWhereWithoutLeaseInput | TransactionsUpdateManyWithWhereWithoutLeaseInput[]
    deleteMany?: TransactionsScalarWhereInput | TransactionsScalarWhereInput[]
  }

  export type MaintenanceRequestUpdateManyWithoutLeaseNestedInput = {
    create?: XOR<MaintenanceRequestCreateWithoutLeaseInput, MaintenanceRequestUncheckedCreateWithoutLeaseInput> | MaintenanceRequestCreateWithoutLeaseInput[] | MaintenanceRequestUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: MaintenanceRequestCreateOrConnectWithoutLeaseInput | MaintenanceRequestCreateOrConnectWithoutLeaseInput[]
    upsert?: MaintenanceRequestUpsertWithWhereUniqueWithoutLeaseInput | MaintenanceRequestUpsertWithWhereUniqueWithoutLeaseInput[]
    createMany?: MaintenanceRequestCreateManyLeaseInputEnvelope
    set?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    disconnect?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    delete?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    connect?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    update?: MaintenanceRequestUpdateWithWhereUniqueWithoutLeaseInput | MaintenanceRequestUpdateWithWhereUniqueWithoutLeaseInput[]
    updateMany?: MaintenanceRequestUpdateManyWithWhereWithoutLeaseInput | MaintenanceRequestUpdateManyWithWhereWithoutLeaseInput[]
    deleteMany?: MaintenanceRequestScalarWhereInput | MaintenanceRequestScalarWhereInput[]
  }

  export type LeaseDocumentUpdateManyWithoutLeaseNestedInput = {
    create?: XOR<LeaseDocumentCreateWithoutLeaseInput, LeaseDocumentUncheckedCreateWithoutLeaseInput> | LeaseDocumentCreateWithoutLeaseInput[] | LeaseDocumentUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: LeaseDocumentCreateOrConnectWithoutLeaseInput | LeaseDocumentCreateOrConnectWithoutLeaseInput[]
    upsert?: LeaseDocumentUpsertWithWhereUniqueWithoutLeaseInput | LeaseDocumentUpsertWithWhereUniqueWithoutLeaseInput[]
    createMany?: LeaseDocumentCreateManyLeaseInputEnvelope
    set?: LeaseDocumentWhereUniqueInput | LeaseDocumentWhereUniqueInput[]
    disconnect?: LeaseDocumentWhereUniqueInput | LeaseDocumentWhereUniqueInput[]
    delete?: LeaseDocumentWhereUniqueInput | LeaseDocumentWhereUniqueInput[]
    connect?: LeaseDocumentWhereUniqueInput | LeaseDocumentWhereUniqueInput[]
    update?: LeaseDocumentUpdateWithWhereUniqueWithoutLeaseInput | LeaseDocumentUpdateWithWhereUniqueWithoutLeaseInput[]
    updateMany?: LeaseDocumentUpdateManyWithWhereWithoutLeaseInput | LeaseDocumentUpdateManyWithWhereWithoutLeaseInput[]
    deleteMany?: LeaseDocumentScalarWhereInput | LeaseDocumentScalarWhereInput[]
  }

  export type TenantLeaseUncheckedUpdateManyWithoutLeaseNestedInput = {
    create?: XOR<TenantLeaseCreateWithoutLeaseInput, TenantLeaseUncheckedCreateWithoutLeaseInput> | TenantLeaseCreateWithoutLeaseInput[] | TenantLeaseUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: TenantLeaseCreateOrConnectWithoutLeaseInput | TenantLeaseCreateOrConnectWithoutLeaseInput[]
    upsert?: TenantLeaseUpsertWithWhereUniqueWithoutLeaseInput | TenantLeaseUpsertWithWhereUniqueWithoutLeaseInput[]
    createMany?: TenantLeaseCreateManyLeaseInputEnvelope
    set?: TenantLeaseWhereUniqueInput | TenantLeaseWhereUniqueInput[]
    disconnect?: TenantLeaseWhereUniqueInput | TenantLeaseWhereUniqueInput[]
    delete?: TenantLeaseWhereUniqueInput | TenantLeaseWhereUniqueInput[]
    connect?: TenantLeaseWhereUniqueInput | TenantLeaseWhereUniqueInput[]
    update?: TenantLeaseUpdateWithWhereUniqueWithoutLeaseInput | TenantLeaseUpdateWithWhereUniqueWithoutLeaseInput[]
    updateMany?: TenantLeaseUpdateManyWithWhereWithoutLeaseInput | TenantLeaseUpdateManyWithWhereWithoutLeaseInput[]
    deleteMany?: TenantLeaseScalarWhereInput | TenantLeaseScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutLeaseNestedInput = {
    create?: XOR<InvoiceCreateWithoutLeaseInput, InvoiceUncheckedCreateWithoutLeaseInput> | InvoiceCreateWithoutLeaseInput[] | InvoiceUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutLeaseInput | InvoiceCreateOrConnectWithoutLeaseInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutLeaseInput | InvoiceUpsertWithWhereUniqueWithoutLeaseInput[]
    createMany?: InvoiceCreateManyLeaseInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutLeaseInput | InvoiceUpdateWithWhereUniqueWithoutLeaseInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutLeaseInput | InvoiceUpdateManyWithWhereWithoutLeaseInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type TransactionsUncheckedUpdateManyWithoutLeaseNestedInput = {
    create?: XOR<TransactionsCreateWithoutLeaseInput, TransactionsUncheckedCreateWithoutLeaseInput> | TransactionsCreateWithoutLeaseInput[] | TransactionsUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutLeaseInput | TransactionsCreateOrConnectWithoutLeaseInput[]
    upsert?: TransactionsUpsertWithWhereUniqueWithoutLeaseInput | TransactionsUpsertWithWhereUniqueWithoutLeaseInput[]
    createMany?: TransactionsCreateManyLeaseInputEnvelope
    set?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    disconnect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    delete?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    update?: TransactionsUpdateWithWhereUniqueWithoutLeaseInput | TransactionsUpdateWithWhereUniqueWithoutLeaseInput[]
    updateMany?: TransactionsUpdateManyWithWhereWithoutLeaseInput | TransactionsUpdateManyWithWhereWithoutLeaseInput[]
    deleteMany?: TransactionsScalarWhereInput | TransactionsScalarWhereInput[]
  }

  export type MaintenanceRequestUncheckedUpdateManyWithoutLeaseNestedInput = {
    create?: XOR<MaintenanceRequestCreateWithoutLeaseInput, MaintenanceRequestUncheckedCreateWithoutLeaseInput> | MaintenanceRequestCreateWithoutLeaseInput[] | MaintenanceRequestUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: MaintenanceRequestCreateOrConnectWithoutLeaseInput | MaintenanceRequestCreateOrConnectWithoutLeaseInput[]
    upsert?: MaintenanceRequestUpsertWithWhereUniqueWithoutLeaseInput | MaintenanceRequestUpsertWithWhereUniqueWithoutLeaseInput[]
    createMany?: MaintenanceRequestCreateManyLeaseInputEnvelope
    set?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    disconnect?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    delete?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    connect?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    update?: MaintenanceRequestUpdateWithWhereUniqueWithoutLeaseInput | MaintenanceRequestUpdateWithWhereUniqueWithoutLeaseInput[]
    updateMany?: MaintenanceRequestUpdateManyWithWhereWithoutLeaseInput | MaintenanceRequestUpdateManyWithWhereWithoutLeaseInput[]
    deleteMany?: MaintenanceRequestScalarWhereInput | MaintenanceRequestScalarWhereInput[]
  }

  export type LeaseDocumentUncheckedUpdateManyWithoutLeaseNestedInput = {
    create?: XOR<LeaseDocumentCreateWithoutLeaseInput, LeaseDocumentUncheckedCreateWithoutLeaseInput> | LeaseDocumentCreateWithoutLeaseInput[] | LeaseDocumentUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: LeaseDocumentCreateOrConnectWithoutLeaseInput | LeaseDocumentCreateOrConnectWithoutLeaseInput[]
    upsert?: LeaseDocumentUpsertWithWhereUniqueWithoutLeaseInput | LeaseDocumentUpsertWithWhereUniqueWithoutLeaseInput[]
    createMany?: LeaseDocumentCreateManyLeaseInputEnvelope
    set?: LeaseDocumentWhereUniqueInput | LeaseDocumentWhereUniqueInput[]
    disconnect?: LeaseDocumentWhereUniqueInput | LeaseDocumentWhereUniqueInput[]
    delete?: LeaseDocumentWhereUniqueInput | LeaseDocumentWhereUniqueInput[]
    connect?: LeaseDocumentWhereUniqueInput | LeaseDocumentWhereUniqueInput[]
    update?: LeaseDocumentUpdateWithWhereUniqueWithoutLeaseInput | LeaseDocumentUpdateWithWhereUniqueWithoutLeaseInput[]
    updateMany?: LeaseDocumentUpdateManyWithWhereWithoutLeaseInput | LeaseDocumentUpdateManyWithWhereWithoutLeaseInput[]
    deleteMany?: LeaseDocumentScalarWhereInput | LeaseDocumentScalarWhereInput[]
  }

  export type LeaseCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<LeaseCreateWithoutInvoiceInput, LeaseUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: LeaseCreateOrConnectWithoutInvoiceInput
    connect?: LeaseWhereUniqueInput
  }

  export type TransactionsCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<TransactionsCreateWithoutInvoiceInput, TransactionsUncheckedCreateWithoutInvoiceInput> | TransactionsCreateWithoutInvoiceInput[] | TransactionsUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutInvoiceInput | TransactionsCreateOrConnectWithoutInvoiceInput[]
    createMany?: TransactionsCreateManyInvoiceInputEnvelope
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
  }

  export type TransactionsUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<TransactionsCreateWithoutInvoiceInput, TransactionsUncheckedCreateWithoutInvoiceInput> | TransactionsCreateWithoutInvoiceInput[] | TransactionsUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutInvoiceInput | TransactionsCreateOrConnectWithoutInvoiceInput[]
    createMany?: TransactionsCreateManyInvoiceInputEnvelope
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
  }

  export type EnumInvoiceCategoryFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceCategory
  }

  export type EnumInvoiceStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceStatus
  }

  export type LeaseUpdateOneRequiredWithoutInvoiceNestedInput = {
    create?: XOR<LeaseCreateWithoutInvoiceInput, LeaseUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: LeaseCreateOrConnectWithoutInvoiceInput
    upsert?: LeaseUpsertWithoutInvoiceInput
    connect?: LeaseWhereUniqueInput
    update?: XOR<XOR<LeaseUpdateToOneWithWhereWithoutInvoiceInput, LeaseUpdateWithoutInvoiceInput>, LeaseUncheckedUpdateWithoutInvoiceInput>
  }

  export type TransactionsUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<TransactionsCreateWithoutInvoiceInput, TransactionsUncheckedCreateWithoutInvoiceInput> | TransactionsCreateWithoutInvoiceInput[] | TransactionsUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutInvoiceInput | TransactionsCreateOrConnectWithoutInvoiceInput[]
    upsert?: TransactionsUpsertWithWhereUniqueWithoutInvoiceInput | TransactionsUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: TransactionsCreateManyInvoiceInputEnvelope
    set?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    disconnect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    delete?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    update?: TransactionsUpdateWithWhereUniqueWithoutInvoiceInput | TransactionsUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: TransactionsUpdateManyWithWhereWithoutInvoiceInput | TransactionsUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: TransactionsScalarWhereInput | TransactionsScalarWhereInput[]
  }

  export type TransactionsUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<TransactionsCreateWithoutInvoiceInput, TransactionsUncheckedCreateWithoutInvoiceInput> | TransactionsCreateWithoutInvoiceInput[] | TransactionsUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutInvoiceInput | TransactionsCreateOrConnectWithoutInvoiceInput[]
    upsert?: TransactionsUpsertWithWhereUniqueWithoutInvoiceInput | TransactionsUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: TransactionsCreateManyInvoiceInputEnvelope
    set?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    disconnect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    delete?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    update?: TransactionsUpdateWithWhereUniqueWithoutInvoiceInput | TransactionsUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: TransactionsUpdateManyWithWhereWithoutInvoiceInput | TransactionsUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: TransactionsScalarWhereInput | TransactionsScalarWhereInput[]
  }

  export type LeaseCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<LeaseCreateWithoutTransactionsInput, LeaseUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: LeaseCreateOrConnectWithoutTransactionsInput
    connect?: LeaseWhereUniqueInput
  }

  export type InvoiceCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<InvoiceCreateWithoutTransactionsInput, InvoiceUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutTransactionsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type LeaseUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<LeaseCreateWithoutTransactionsInput, LeaseUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: LeaseCreateOrConnectWithoutTransactionsInput
    upsert?: LeaseUpsertWithoutTransactionsInput
    connect?: LeaseWhereUniqueInput
    update?: XOR<XOR<LeaseUpdateToOneWithWhereWithoutTransactionsInput, LeaseUpdateWithoutTransactionsInput>, LeaseUncheckedUpdateWithoutTransactionsInput>
  }

  export type InvoiceUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<InvoiceCreateWithoutTransactionsInput, InvoiceUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutTransactionsInput
    upsert?: InvoiceUpsertWithoutTransactionsInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutTransactionsInput, InvoiceUpdateWithoutTransactionsInput>, InvoiceUncheckedUpdateWithoutTransactionsInput>
  }

  export type TenantCreateNestedOneWithoutTenantLeaseInput = {
    create?: XOR<TenantCreateWithoutTenantLeaseInput, TenantUncheckedCreateWithoutTenantLeaseInput>
    connectOrCreate?: TenantCreateOrConnectWithoutTenantLeaseInput
    connect?: TenantWhereUniqueInput
  }

  export type LeaseCreateNestedOneWithoutTenantLeaseInput = {
    create?: XOR<LeaseCreateWithoutTenantLeaseInput, LeaseUncheckedCreateWithoutTenantLeaseInput>
    connectOrCreate?: LeaseCreateOrConnectWithoutTenantLeaseInput
    connect?: LeaseWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutTenantLeaseNestedInput = {
    create?: XOR<TenantCreateWithoutTenantLeaseInput, TenantUncheckedCreateWithoutTenantLeaseInput>
    connectOrCreate?: TenantCreateOrConnectWithoutTenantLeaseInput
    upsert?: TenantUpsertWithoutTenantLeaseInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutTenantLeaseInput, TenantUpdateWithoutTenantLeaseInput>, TenantUncheckedUpdateWithoutTenantLeaseInput>
  }

  export type LeaseUpdateOneRequiredWithoutTenantLeaseNestedInput = {
    create?: XOR<LeaseCreateWithoutTenantLeaseInput, LeaseUncheckedCreateWithoutTenantLeaseInput>
    connectOrCreate?: LeaseCreateOrConnectWithoutTenantLeaseInput
    upsert?: LeaseUpsertWithoutTenantLeaseInput
    connect?: LeaseWhereUniqueInput
    update?: XOR<XOR<LeaseUpdateToOneWithWhereWithoutTenantLeaseInput, LeaseUpdateWithoutTenantLeaseInput>, LeaseUncheckedUpdateWithoutTenantLeaseInput>
  }

  export type LeaseCreateNestedOneWithoutMaintenanceRequestInput = {
    create?: XOR<LeaseCreateWithoutMaintenanceRequestInput, LeaseUncheckedCreateWithoutMaintenanceRequestInput>
    connectOrCreate?: LeaseCreateOrConnectWithoutMaintenanceRequestInput
    connect?: LeaseWhereUniqueInput
  }

  export type EnumMaintenanceRequestStatusFieldUpdateOperationsInput = {
    set?: $Enums.MaintenanceRequestStatus
  }

  export type EnumMaintenanceRequestPriorityFieldUpdateOperationsInput = {
    set?: $Enums.MaintenanceRequestPriority
  }

  export type LeaseUpdateOneRequiredWithoutMaintenanceRequestNestedInput = {
    create?: XOR<LeaseCreateWithoutMaintenanceRequestInput, LeaseUncheckedCreateWithoutMaintenanceRequestInput>
    connectOrCreate?: LeaseCreateOrConnectWithoutMaintenanceRequestInput
    upsert?: LeaseUpsertWithoutMaintenanceRequestInput
    connect?: LeaseWhereUniqueInput
    update?: XOR<XOR<LeaseUpdateToOneWithWhereWithoutMaintenanceRequestInput, LeaseUpdateWithoutMaintenanceRequestInput>, LeaseUncheckedUpdateWithoutMaintenanceRequestInput>
  }

  export type TenantCreateNestedOneWithoutTenantDocumentInput = {
    create?: XOR<TenantCreateWithoutTenantDocumentInput, TenantUncheckedCreateWithoutTenantDocumentInput>
    connectOrCreate?: TenantCreateOrConnectWithoutTenantDocumentInput
    connect?: TenantWhereUniqueInput
  }

  export type EnumTenantDocumentTypeFieldUpdateOperationsInput = {
    set?: $Enums.TenantDocumentType
  }

  export type TenantUpdateOneRequiredWithoutTenantDocumentNestedInput = {
    create?: XOR<TenantCreateWithoutTenantDocumentInput, TenantUncheckedCreateWithoutTenantDocumentInput>
    connectOrCreate?: TenantCreateOrConnectWithoutTenantDocumentInput
    upsert?: TenantUpsertWithoutTenantDocumentInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutTenantDocumentInput, TenantUpdateWithoutTenantDocumentInput>, TenantUncheckedUpdateWithoutTenantDocumentInput>
  }

  export type LeaseCreateNestedOneWithoutLeaseDocumentInput = {
    create?: XOR<LeaseCreateWithoutLeaseDocumentInput, LeaseUncheckedCreateWithoutLeaseDocumentInput>
    connectOrCreate?: LeaseCreateOrConnectWithoutLeaseDocumentInput
    connect?: LeaseWhereUniqueInput
  }

  export type EnumDocumentTypeFieldUpdateOperationsInput = {
    set?: $Enums.DocumentType
  }

  export type LeaseUpdateOneRequiredWithoutLeaseDocumentNestedInput = {
    create?: XOR<LeaseCreateWithoutLeaseDocumentInput, LeaseUncheckedCreateWithoutLeaseDocumentInput>
    connectOrCreate?: LeaseCreateOrConnectWithoutLeaseDocumentInput
    upsert?: LeaseUpsertWithoutLeaseDocumentInput
    connect?: LeaseWhereUniqueInput
    update?: XOR<XOR<LeaseUpdateToOneWithWhereWithoutLeaseDocumentInput, LeaseUpdateWithoutLeaseDocumentInput>, LeaseUncheckedUpdateWithoutLeaseDocumentInput>
  }

  export type PropertyCreateNestedOneWithoutPropertyDocumentInput = {
    create?: XOR<PropertyCreateWithoutPropertyDocumentInput, PropertyUncheckedCreateWithoutPropertyDocumentInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutPropertyDocumentInput
    connect?: PropertyWhereUniqueInput
  }

  export type PropertyUpdateOneRequiredWithoutPropertyDocumentNestedInput = {
    create?: XOR<PropertyCreateWithoutPropertyDocumentInput, PropertyUncheckedCreateWithoutPropertyDocumentInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutPropertyDocumentInput
    upsert?: PropertyUpsertWithoutPropertyDocumentInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutPropertyDocumentInput, PropertyUpdateWithoutPropertyDocumentInput>, PropertyUncheckedUpdateWithoutPropertyDocumentInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumTenantRelationshipFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantRelationship | EnumTenantRelationshipFieldRefInput<$PrismaModel>
    in?: $Enums.TenantRelationship[] | ListEnumTenantRelationshipFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantRelationship[] | ListEnumTenantRelationshipFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantRelationshipFilter<$PrismaModel> | $Enums.TenantRelationship
  }

  export type NestedEnumTenantRelationshipWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantRelationship | EnumTenantRelationshipFieldRefInput<$PrismaModel>
    in?: $Enums.TenantRelationship[] | ListEnumTenantRelationshipFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantRelationship[] | ListEnumTenantRelationshipFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantRelationshipWithAggregatesFilter<$PrismaModel> | $Enums.TenantRelationship
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTenantRelationshipFilter<$PrismaModel>
    _max?: NestedEnumTenantRelationshipFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumTenantIncomeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantIncomeType | EnumTenantIncomeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TenantIncomeType[] | ListEnumTenantIncomeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantIncomeType[] | ListEnumTenantIncomeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantIncomeTypeFilter<$PrismaModel> | $Enums.TenantIncomeType
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumTenantIncomeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantIncomeType | EnumTenantIncomeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TenantIncomeType[] | ListEnumTenantIncomeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantIncomeType[] | ListEnumTenantIncomeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantIncomeTypeWithAggregatesFilter<$PrismaModel> | $Enums.TenantIncomeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTenantIncomeTypeFilter<$PrismaModel>
    _max?: NestedEnumTenantIncomeTypeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumPropertyTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyType | EnumPropertyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyTypeFilter<$PrismaModel> | $Enums.PropertyType
  }

  export type NestedEnumPropertyStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyStatus | EnumPropertyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyStatusFilter<$PrismaModel> | $Enums.PropertyStatus
  }

  export type NestedEnumLeaseTermTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaseTermType | EnumLeaseTermTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LeaseTermType[] | ListEnumLeaseTermTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaseTermType[] | ListEnumLeaseTermTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaseTermTypeFilter<$PrismaModel> | $Enums.LeaseTermType
  }

  export type NestedEnumPropertyTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyType | EnumPropertyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyTypeWithAggregatesFilter<$PrismaModel> | $Enums.PropertyType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPropertyTypeFilter<$PrismaModel>
    _max?: NestedEnumPropertyTypeFilter<$PrismaModel>
  }

  export type NestedEnumPropertyStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyStatus | EnumPropertyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyStatusWithAggregatesFilter<$PrismaModel> | $Enums.PropertyStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPropertyStatusFilter<$PrismaModel>
    _max?: NestedEnumPropertyStatusFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumLeaseTermTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaseTermType | EnumLeaseTermTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LeaseTermType[] | ListEnumLeaseTermTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaseTermType[] | ListEnumLeaseTermTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaseTermTypeWithAggregatesFilter<$PrismaModel> | $Enums.LeaseTermType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaseTermTypeFilter<$PrismaModel>
    _max?: NestedEnumLeaseTermTypeFilter<$PrismaModel>
  }

  export type NestedEnumLeaseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaseStatus | EnumLeaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaseStatus[] | ListEnumLeaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaseStatus[] | ListEnumLeaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaseStatusFilter<$PrismaModel> | $Enums.LeaseStatus
  }

  export type NestedEnumLeaseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaseStatus | EnumLeaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaseStatus[] | ListEnumLeaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaseStatus[] | ListEnumLeaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaseStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeaseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaseStatusFilter<$PrismaModel>
    _max?: NestedEnumLeaseStatusFilter<$PrismaModel>
  }

  export type NestedEnumInvoiceCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceCategory | EnumInvoiceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceCategory[] | ListEnumInvoiceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceCategory[] | ListEnumInvoiceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceCategoryFilter<$PrismaModel> | $Enums.InvoiceCategory
  }

  export type NestedEnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type NestedEnumInvoiceCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceCategory | EnumInvoiceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceCategory[] | ListEnumInvoiceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceCategory[] | ListEnumInvoiceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceCategoryWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceCategoryFilter<$PrismaModel>
    _max?: NestedEnumInvoiceCategoryFilter<$PrismaModel>
  }

  export type NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type NestedEnumMaintenanceRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenanceRequestStatus | EnumMaintenanceRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MaintenanceRequestStatus[] | ListEnumMaintenanceRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaintenanceRequestStatus[] | ListEnumMaintenanceRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMaintenanceRequestStatusFilter<$PrismaModel> | $Enums.MaintenanceRequestStatus
  }

  export type NestedEnumMaintenanceRequestPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenanceRequestPriority | EnumMaintenanceRequestPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.MaintenanceRequestPriority[] | ListEnumMaintenanceRequestPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaintenanceRequestPriority[] | ListEnumMaintenanceRequestPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumMaintenanceRequestPriorityFilter<$PrismaModel> | $Enums.MaintenanceRequestPriority
  }

  export type NestedEnumMaintenanceRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenanceRequestStatus | EnumMaintenanceRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MaintenanceRequestStatus[] | ListEnumMaintenanceRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaintenanceRequestStatus[] | ListEnumMaintenanceRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMaintenanceRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.MaintenanceRequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMaintenanceRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumMaintenanceRequestStatusFilter<$PrismaModel>
  }

  export type NestedEnumMaintenanceRequestPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenanceRequestPriority | EnumMaintenanceRequestPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.MaintenanceRequestPriority[] | ListEnumMaintenanceRequestPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaintenanceRequestPriority[] | ListEnumMaintenanceRequestPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumMaintenanceRequestPriorityWithAggregatesFilter<$PrismaModel> | $Enums.MaintenanceRequestPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMaintenanceRequestPriorityFilter<$PrismaModel>
    _max?: NestedEnumMaintenanceRequestPriorityFilter<$PrismaModel>
  }

  export type NestedEnumTenantDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantDocumentType | EnumTenantDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TenantDocumentType[] | ListEnumTenantDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantDocumentType[] | ListEnumTenantDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantDocumentTypeFilter<$PrismaModel> | $Enums.TenantDocumentType
  }

  export type NestedEnumTenantDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantDocumentType | EnumTenantDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TenantDocumentType[] | ListEnumTenantDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantDocumentType[] | ListEnumTenantDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.TenantDocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTenantDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumTenantDocumentTypeFilter<$PrismaModel>
  }

  export type NestedEnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type LeaseCreateWithoutTenantInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    rent: number
    deposit: number
    rentDueCurrency: string
    status: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    unit: UnitCreateNestedOneWithoutLeaseInput
    tenantLease?: TenantLeaseCreateNestedManyWithoutLeaseInput
    property?: PropertyCreateNestedOneWithoutLeaseInput
    invoice?: InvoiceCreateNestedManyWithoutLeaseInput
    transactions?: TransactionsCreateNestedManyWithoutLeaseInput
    maintenanceRequest?: MaintenanceRequestCreateNestedManyWithoutLeaseInput
    leaseDocument?: LeaseDocumentCreateNestedManyWithoutLeaseInput
  }

  export type LeaseUncheckedCreateWithoutTenantInput = {
    id?: string
    unitId: string
    startDate: Date | string
    endDate: Date | string
    rent: number
    deposit: number
    rentDueCurrency: string
    status: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    propertyId?: string | null
    tenantLease?: TenantLeaseUncheckedCreateNestedManyWithoutLeaseInput
    invoice?: InvoiceUncheckedCreateNestedManyWithoutLeaseInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutLeaseInput
    maintenanceRequest?: MaintenanceRequestUncheckedCreateNestedManyWithoutLeaseInput
    leaseDocument?: LeaseDocumentUncheckedCreateNestedManyWithoutLeaseInput
  }

  export type LeaseCreateOrConnectWithoutTenantInput = {
    where: LeaseWhereUniqueInput
    create: XOR<LeaseCreateWithoutTenantInput, LeaseUncheckedCreateWithoutTenantInput>
  }

  export type LeaseCreateManyTenantInputEnvelope = {
    data: LeaseCreateManyTenantInput | LeaseCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type TenantLeaseCreateWithoutTenantInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lease: LeaseCreateNestedOneWithoutTenantLeaseInput
  }

  export type TenantLeaseUncheckedCreateWithoutTenantInput = {
    id?: string
    leaseId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantLeaseCreateOrConnectWithoutTenantInput = {
    where: TenantLeaseWhereUniqueInput
    create: XOR<TenantLeaseCreateWithoutTenantInput, TenantLeaseUncheckedCreateWithoutTenantInput>
  }

  export type TenantLeaseCreateManyTenantInputEnvelope = {
    data: TenantLeaseCreateManyTenantInput | TenantLeaseCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type TenantDocumentCreateWithoutTenantInput = {
    id?: string
    documentType: $Enums.TenantDocumentType
    documentUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantDocumentUncheckedCreateWithoutTenantInput = {
    id?: string
    documentType: $Enums.TenantDocumentType
    documentUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantDocumentCreateOrConnectWithoutTenantInput = {
    where: TenantDocumentWhereUniqueInput
    create: XOR<TenantDocumentCreateWithoutTenantInput, TenantDocumentUncheckedCreateWithoutTenantInput>
  }

  export type TenantDocumentCreateManyTenantInputEnvelope = {
    data: TenantDocumentCreateManyTenantInput | TenantDocumentCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type TenantEmergencyContactCreateWithoutTenantInput = {
    id?: string
    name: string
    phone: string
    email: string
    relationship: $Enums.TenantRelationship
    addressLine1: string
    addressLine2?: string | null
    city: string
    state: string
    zip: string
    countryCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantEmergencyContactUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    phone: string
    email: string
    relationship: $Enums.TenantRelationship
    addressLine1: string
    addressLine2?: string | null
    city: string
    state: string
    zip: string
    countryCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantEmergencyContactCreateOrConnectWithoutTenantInput = {
    where: TenantEmergencyContactWhereUniqueInput
    create: XOR<TenantEmergencyContactCreateWithoutTenantInput, TenantEmergencyContactUncheckedCreateWithoutTenantInput>
  }

  export type TenantEmergencyContactCreateManyTenantInputEnvelope = {
    data: TenantEmergencyContactCreateManyTenantInput | TenantEmergencyContactCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type TenantIncomeCreateWithoutTenantInput = {
    id?: string
    income: number
    incomeType: $Enums.TenantIncomeType
    position?: string | null
    employer?: string | null
    employerAddressLine1?: string | null
    employerAddressLine2?: string | null
    employerCity?: string | null
    employerState?: string | null
    employerZip?: string | null
    employerCountryCode?: string | null
    startDate: Date | string
    endDate: Date | string
    currentIncome?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantIncomeUncheckedCreateWithoutTenantInput = {
    id?: string
    income: number
    incomeType: $Enums.TenantIncomeType
    position?: string | null
    employer?: string | null
    employerAddressLine1?: string | null
    employerAddressLine2?: string | null
    employerCity?: string | null
    employerState?: string | null
    employerZip?: string | null
    employerCountryCode?: string | null
    startDate: Date | string
    endDate: Date | string
    currentIncome?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantIncomeCreateOrConnectWithoutTenantInput = {
    where: TenantIncomeWhereUniqueInput
    create: XOR<TenantIncomeCreateWithoutTenantInput, TenantIncomeUncheckedCreateWithoutTenantInput>
  }

  export type TenantIncomeCreateManyTenantInputEnvelope = {
    data: TenantIncomeCreateManyTenantInput | TenantIncomeCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type LeaseUpsertWithWhereUniqueWithoutTenantInput = {
    where: LeaseWhereUniqueInput
    update: XOR<LeaseUpdateWithoutTenantInput, LeaseUncheckedUpdateWithoutTenantInput>
    create: XOR<LeaseCreateWithoutTenantInput, LeaseUncheckedCreateWithoutTenantInput>
  }

  export type LeaseUpdateWithWhereUniqueWithoutTenantInput = {
    where: LeaseWhereUniqueInput
    data: XOR<LeaseUpdateWithoutTenantInput, LeaseUncheckedUpdateWithoutTenantInput>
  }

  export type LeaseUpdateManyWithWhereWithoutTenantInput = {
    where: LeaseScalarWhereInput
    data: XOR<LeaseUpdateManyMutationInput, LeaseUncheckedUpdateManyWithoutTenantInput>
  }

  export type LeaseScalarWhereInput = {
    AND?: LeaseScalarWhereInput | LeaseScalarWhereInput[]
    OR?: LeaseScalarWhereInput[]
    NOT?: LeaseScalarWhereInput | LeaseScalarWhereInput[]
    id?: StringFilter<"Lease"> | string
    unitId?: StringFilter<"Lease"> | string
    tenantId?: StringFilter<"Lease"> | string
    startDate?: DateTimeFilter<"Lease"> | Date | string
    endDate?: DateTimeFilter<"Lease"> | Date | string
    rent?: FloatFilter<"Lease"> | number
    deposit?: FloatFilter<"Lease"> | number
    rentDueCurrency?: StringFilter<"Lease"> | string
    status?: EnumLeaseStatusFilter<"Lease"> | $Enums.LeaseStatus
    createdAt?: DateTimeFilter<"Lease"> | Date | string
    updatedAt?: DateTimeFilter<"Lease"> | Date | string
    propertyId?: StringNullableFilter<"Lease"> | string | null
  }

  export type TenantLeaseUpsertWithWhereUniqueWithoutTenantInput = {
    where: TenantLeaseWhereUniqueInput
    update: XOR<TenantLeaseUpdateWithoutTenantInput, TenantLeaseUncheckedUpdateWithoutTenantInput>
    create: XOR<TenantLeaseCreateWithoutTenantInput, TenantLeaseUncheckedCreateWithoutTenantInput>
  }

  export type TenantLeaseUpdateWithWhereUniqueWithoutTenantInput = {
    where: TenantLeaseWhereUniqueInput
    data: XOR<TenantLeaseUpdateWithoutTenantInput, TenantLeaseUncheckedUpdateWithoutTenantInput>
  }

  export type TenantLeaseUpdateManyWithWhereWithoutTenantInput = {
    where: TenantLeaseScalarWhereInput
    data: XOR<TenantLeaseUpdateManyMutationInput, TenantLeaseUncheckedUpdateManyWithoutTenantInput>
  }

  export type TenantLeaseScalarWhereInput = {
    AND?: TenantLeaseScalarWhereInput | TenantLeaseScalarWhereInput[]
    OR?: TenantLeaseScalarWhereInput[]
    NOT?: TenantLeaseScalarWhereInput | TenantLeaseScalarWhereInput[]
    id?: StringFilter<"TenantLease"> | string
    tenantId?: StringFilter<"TenantLease"> | string
    leaseId?: StringFilter<"TenantLease"> | string
    createdAt?: DateTimeFilter<"TenantLease"> | Date | string
    updatedAt?: DateTimeFilter<"TenantLease"> | Date | string
  }

  export type TenantDocumentUpsertWithWhereUniqueWithoutTenantInput = {
    where: TenantDocumentWhereUniqueInput
    update: XOR<TenantDocumentUpdateWithoutTenantInput, TenantDocumentUncheckedUpdateWithoutTenantInput>
    create: XOR<TenantDocumentCreateWithoutTenantInput, TenantDocumentUncheckedCreateWithoutTenantInput>
  }

  export type TenantDocumentUpdateWithWhereUniqueWithoutTenantInput = {
    where: TenantDocumentWhereUniqueInput
    data: XOR<TenantDocumentUpdateWithoutTenantInput, TenantDocumentUncheckedUpdateWithoutTenantInput>
  }

  export type TenantDocumentUpdateManyWithWhereWithoutTenantInput = {
    where: TenantDocumentScalarWhereInput
    data: XOR<TenantDocumentUpdateManyMutationInput, TenantDocumentUncheckedUpdateManyWithoutTenantInput>
  }

  export type TenantDocumentScalarWhereInput = {
    AND?: TenantDocumentScalarWhereInput | TenantDocumentScalarWhereInput[]
    OR?: TenantDocumentScalarWhereInput[]
    NOT?: TenantDocumentScalarWhereInput | TenantDocumentScalarWhereInput[]
    id?: StringFilter<"TenantDocument"> | string
    tenantId?: StringFilter<"TenantDocument"> | string
    documentType?: EnumTenantDocumentTypeFilter<"TenantDocument"> | $Enums.TenantDocumentType
    documentUrl?: StringFilter<"TenantDocument"> | string
    createdAt?: DateTimeFilter<"TenantDocument"> | Date | string
    updatedAt?: DateTimeFilter<"TenantDocument"> | Date | string
  }

  export type TenantEmergencyContactUpsertWithWhereUniqueWithoutTenantInput = {
    where: TenantEmergencyContactWhereUniqueInput
    update: XOR<TenantEmergencyContactUpdateWithoutTenantInput, TenantEmergencyContactUncheckedUpdateWithoutTenantInput>
    create: XOR<TenantEmergencyContactCreateWithoutTenantInput, TenantEmergencyContactUncheckedCreateWithoutTenantInput>
  }

  export type TenantEmergencyContactUpdateWithWhereUniqueWithoutTenantInput = {
    where: TenantEmergencyContactWhereUniqueInput
    data: XOR<TenantEmergencyContactUpdateWithoutTenantInput, TenantEmergencyContactUncheckedUpdateWithoutTenantInput>
  }

  export type TenantEmergencyContactUpdateManyWithWhereWithoutTenantInput = {
    where: TenantEmergencyContactScalarWhereInput
    data: XOR<TenantEmergencyContactUpdateManyMutationInput, TenantEmergencyContactUncheckedUpdateManyWithoutTenantInput>
  }

  export type TenantEmergencyContactScalarWhereInput = {
    AND?: TenantEmergencyContactScalarWhereInput | TenantEmergencyContactScalarWhereInput[]
    OR?: TenantEmergencyContactScalarWhereInput[]
    NOT?: TenantEmergencyContactScalarWhereInput | TenantEmergencyContactScalarWhereInput[]
    id?: StringFilter<"TenantEmergencyContact"> | string
    tenantId?: StringFilter<"TenantEmergencyContact"> | string
    name?: StringFilter<"TenantEmergencyContact"> | string
    phone?: StringFilter<"TenantEmergencyContact"> | string
    email?: StringFilter<"TenantEmergencyContact"> | string
    relationship?: EnumTenantRelationshipFilter<"TenantEmergencyContact"> | $Enums.TenantRelationship
    addressLine1?: StringFilter<"TenantEmergencyContact"> | string
    addressLine2?: StringNullableFilter<"TenantEmergencyContact"> | string | null
    city?: StringFilter<"TenantEmergencyContact"> | string
    state?: StringFilter<"TenantEmergencyContact"> | string
    zip?: StringFilter<"TenantEmergencyContact"> | string
    countryCode?: StringFilter<"TenantEmergencyContact"> | string
    createdAt?: DateTimeFilter<"TenantEmergencyContact"> | Date | string
    updatedAt?: DateTimeFilter<"TenantEmergencyContact"> | Date | string
  }

  export type TenantIncomeUpsertWithWhereUniqueWithoutTenantInput = {
    where: TenantIncomeWhereUniqueInput
    update: XOR<TenantIncomeUpdateWithoutTenantInput, TenantIncomeUncheckedUpdateWithoutTenantInput>
    create: XOR<TenantIncomeCreateWithoutTenantInput, TenantIncomeUncheckedCreateWithoutTenantInput>
  }

  export type TenantIncomeUpdateWithWhereUniqueWithoutTenantInput = {
    where: TenantIncomeWhereUniqueInput
    data: XOR<TenantIncomeUpdateWithoutTenantInput, TenantIncomeUncheckedUpdateWithoutTenantInput>
  }

  export type TenantIncomeUpdateManyWithWhereWithoutTenantInput = {
    where: TenantIncomeScalarWhereInput
    data: XOR<TenantIncomeUpdateManyMutationInput, TenantIncomeUncheckedUpdateManyWithoutTenantInput>
  }

  export type TenantIncomeScalarWhereInput = {
    AND?: TenantIncomeScalarWhereInput | TenantIncomeScalarWhereInput[]
    OR?: TenantIncomeScalarWhereInput[]
    NOT?: TenantIncomeScalarWhereInput | TenantIncomeScalarWhereInput[]
    id?: StringFilter<"TenantIncome"> | string
    tenantId?: StringFilter<"TenantIncome"> | string
    income?: FloatFilter<"TenantIncome"> | number
    incomeType?: EnumTenantIncomeTypeFilter<"TenantIncome"> | $Enums.TenantIncomeType
    position?: StringNullableFilter<"TenantIncome"> | string | null
    employer?: StringNullableFilter<"TenantIncome"> | string | null
    employerAddressLine1?: StringNullableFilter<"TenantIncome"> | string | null
    employerAddressLine2?: StringNullableFilter<"TenantIncome"> | string | null
    employerCity?: StringNullableFilter<"TenantIncome"> | string | null
    employerState?: StringNullableFilter<"TenantIncome"> | string | null
    employerZip?: StringNullableFilter<"TenantIncome"> | string | null
    employerCountryCode?: StringNullableFilter<"TenantIncome"> | string | null
    startDate?: DateTimeFilter<"TenantIncome"> | Date | string
    endDate?: DateTimeFilter<"TenantIncome"> | Date | string
    currentIncome?: BoolFilter<"TenantIncome"> | boolean
    createdAt?: DateTimeFilter<"TenantIncome"> | Date | string
    updatedAt?: DateTimeFilter<"TenantIncome"> | Date | string
  }

  export type TenantCreateWithoutTenantEmergencyContactInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    altEmail?: string | null
    phone: string
    altPhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Lease?: LeaseCreateNestedManyWithoutTenantInput
    tenantLease?: TenantLeaseCreateNestedManyWithoutTenantInput
    tenantDocument?: TenantDocumentCreateNestedManyWithoutTenantInput
    tenantIncome?: TenantIncomeCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutTenantEmergencyContactInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    altEmail?: string | null
    phone: string
    altPhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Lease?: LeaseUncheckedCreateNestedManyWithoutTenantInput
    tenantLease?: TenantLeaseUncheckedCreateNestedManyWithoutTenantInput
    tenantDocument?: TenantDocumentUncheckedCreateNestedManyWithoutTenantInput
    tenantIncome?: TenantIncomeUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutTenantEmergencyContactInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutTenantEmergencyContactInput, TenantUncheckedCreateWithoutTenantEmergencyContactInput>
  }

  export type TenantUpsertWithoutTenantEmergencyContactInput = {
    update: XOR<TenantUpdateWithoutTenantEmergencyContactInput, TenantUncheckedUpdateWithoutTenantEmergencyContactInput>
    create: XOR<TenantCreateWithoutTenantEmergencyContactInput, TenantUncheckedCreateWithoutTenantEmergencyContactInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutTenantEmergencyContactInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutTenantEmergencyContactInput, TenantUncheckedUpdateWithoutTenantEmergencyContactInput>
  }

  export type TenantUpdateWithoutTenantEmergencyContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    altEmail?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    altPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Lease?: LeaseUpdateManyWithoutTenantNestedInput
    tenantLease?: TenantLeaseUpdateManyWithoutTenantNestedInput
    tenantDocument?: TenantDocumentUpdateManyWithoutTenantNestedInput
    tenantIncome?: TenantIncomeUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutTenantEmergencyContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    altEmail?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    altPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Lease?: LeaseUncheckedUpdateManyWithoutTenantNestedInput
    tenantLease?: TenantLeaseUncheckedUpdateManyWithoutTenantNestedInput
    tenantDocument?: TenantDocumentUncheckedUpdateManyWithoutTenantNestedInput
    tenantIncome?: TenantIncomeUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutTenantIncomeInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    altEmail?: string | null
    phone: string
    altPhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Lease?: LeaseCreateNestedManyWithoutTenantInput
    tenantLease?: TenantLeaseCreateNestedManyWithoutTenantInput
    tenantDocument?: TenantDocumentCreateNestedManyWithoutTenantInput
    tenantEmergencyContact?: TenantEmergencyContactCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutTenantIncomeInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    altEmail?: string | null
    phone: string
    altPhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Lease?: LeaseUncheckedCreateNestedManyWithoutTenantInput
    tenantLease?: TenantLeaseUncheckedCreateNestedManyWithoutTenantInput
    tenantDocument?: TenantDocumentUncheckedCreateNestedManyWithoutTenantInput
    tenantEmergencyContact?: TenantEmergencyContactUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutTenantIncomeInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutTenantIncomeInput, TenantUncheckedCreateWithoutTenantIncomeInput>
  }

  export type TenantUpsertWithoutTenantIncomeInput = {
    update: XOR<TenantUpdateWithoutTenantIncomeInput, TenantUncheckedUpdateWithoutTenantIncomeInput>
    create: XOR<TenantCreateWithoutTenantIncomeInput, TenantUncheckedCreateWithoutTenantIncomeInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutTenantIncomeInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutTenantIncomeInput, TenantUncheckedUpdateWithoutTenantIncomeInput>
  }

  export type TenantUpdateWithoutTenantIncomeInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    altEmail?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    altPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Lease?: LeaseUpdateManyWithoutTenantNestedInput
    tenantLease?: TenantLeaseUpdateManyWithoutTenantNestedInput
    tenantDocument?: TenantDocumentUpdateManyWithoutTenantNestedInput
    tenantEmergencyContact?: TenantEmergencyContactUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutTenantIncomeInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    altEmail?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    altPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Lease?: LeaseUncheckedUpdateManyWithoutTenantNestedInput
    tenantLease?: TenantLeaseUncheckedUpdateManyWithoutTenantNestedInput
    tenantDocument?: TenantDocumentUncheckedUpdateManyWithoutTenantNestedInput
    tenantEmergencyContact?: TenantEmergencyContactUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type PropertyCreateWithoutOwnerInput = {
    id?: string
    name: string
    addressLine1: string
    addressLine2?: string | null
    city: string
    state: string
    zip: string
    countryCode?: string
    imageUrl?: string | null
    propertyType?: $Enums.PropertyType
    propertyStatus?: $Enums.PropertyStatus
    bedrooms?: number
    bathrooms?: number
    squareMeters?: number
    marketRent?: number
    deposit?: number
    leaseTerm?: number
    leaseTermType?: $Enums.LeaseTermType
    createdAt?: Date | string
    updatedAt?: Date | string
    sqmt?: number
    features?: PropertyCreatefeaturesInput | string[]
    amenities?: PropertyCreateamenitiesInput | string[]
    test?: string | null
    unit?: UnitCreateNestedManyWithoutPropertyInput
    propertyDocument?: PropertyDocumentCreateNestedManyWithoutPropertyInput
    Lease?: LeaseCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutOwnerInput = {
    id?: string
    name: string
    addressLine1: string
    addressLine2?: string | null
    city: string
    state: string
    zip: string
    countryCode?: string
    imageUrl?: string | null
    propertyType?: $Enums.PropertyType
    propertyStatus?: $Enums.PropertyStatus
    bedrooms?: number
    bathrooms?: number
    squareMeters?: number
    marketRent?: number
    deposit?: number
    leaseTerm?: number
    leaseTermType?: $Enums.LeaseTermType
    createdAt?: Date | string
    updatedAt?: Date | string
    sqmt?: number
    features?: PropertyCreatefeaturesInput | string[]
    amenities?: PropertyCreateamenitiesInput | string[]
    test?: string | null
    unit?: UnitUncheckedCreateNestedManyWithoutPropertyInput
    propertyDocument?: PropertyDocumentUncheckedCreateNestedManyWithoutPropertyInput
    Lease?: LeaseUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutOwnerInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutOwnerInput, PropertyUncheckedCreateWithoutOwnerInput>
  }

  export type PropertyCreateManyOwnerInputEnvelope = {
    data: PropertyCreateManyOwnerInput | PropertyCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type PropertyUpsertWithWhereUniqueWithoutOwnerInput = {
    where: PropertyWhereUniqueInput
    update: XOR<PropertyUpdateWithoutOwnerInput, PropertyUncheckedUpdateWithoutOwnerInput>
    create: XOR<PropertyCreateWithoutOwnerInput, PropertyUncheckedCreateWithoutOwnerInput>
  }

  export type PropertyUpdateWithWhereUniqueWithoutOwnerInput = {
    where: PropertyWhereUniqueInput
    data: XOR<PropertyUpdateWithoutOwnerInput, PropertyUncheckedUpdateWithoutOwnerInput>
  }

  export type PropertyUpdateManyWithWhereWithoutOwnerInput = {
    where: PropertyScalarWhereInput
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyWithoutOwnerInput>
  }

  export type PropertyScalarWhereInput = {
    AND?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
    OR?: PropertyScalarWhereInput[]
    NOT?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
    id?: StringFilter<"Property"> | string
    name?: StringFilter<"Property"> | string
    addressLine1?: StringFilter<"Property"> | string
    addressLine2?: StringNullableFilter<"Property"> | string | null
    city?: StringFilter<"Property"> | string
    state?: StringFilter<"Property"> | string
    zip?: StringFilter<"Property"> | string
    countryCode?: StringFilter<"Property"> | string
    ownerId?: StringFilter<"Property"> | string
    imageUrl?: StringNullableFilter<"Property"> | string | null
    propertyType?: EnumPropertyTypeFilter<"Property"> | $Enums.PropertyType
    propertyStatus?: EnumPropertyStatusFilter<"Property"> | $Enums.PropertyStatus
    bedrooms?: IntFilter<"Property"> | number
    bathrooms?: FloatFilter<"Property"> | number
    squareMeters?: FloatFilter<"Property"> | number
    marketRent?: FloatFilter<"Property"> | number
    deposit?: FloatFilter<"Property"> | number
    leaseTerm?: IntFilter<"Property"> | number
    leaseTermType?: EnumLeaseTermTypeFilter<"Property"> | $Enums.LeaseTermType
    createdAt?: DateTimeFilter<"Property"> | Date | string
    updatedAt?: DateTimeFilter<"Property"> | Date | string
    sqmt?: FloatFilter<"Property"> | number
    features?: StringNullableListFilter<"Property">
    amenities?: StringNullableListFilter<"Property">
    test?: StringNullableFilter<"Property"> | string | null
  }

  export type LandlordCreateWithoutPropertyInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone: string
    addressLine1: string
    addressLine2?: string | null
    city: string
    state: string
    zip: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LandlordUncheckedCreateWithoutPropertyInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone: string
    addressLine1: string
    addressLine2?: string | null
    city: string
    state: string
    zip: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LandlordCreateOrConnectWithoutPropertyInput = {
    where: LandlordWhereUniqueInput
    create: XOR<LandlordCreateWithoutPropertyInput, LandlordUncheckedCreateWithoutPropertyInput>
  }

  export type UnitCreateWithoutPropertyInput = {
    id?: string
    name: string
    bedrooms?: number
    bathrooms?: number
    sqmt?: number
    marketRent?: number
    deposit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lease?: LeaseCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutPropertyInput = {
    id?: string
    name: string
    bedrooms?: number
    bathrooms?: number
    sqmt?: number
    marketRent?: number
    deposit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lease?: LeaseUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutPropertyInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutPropertyInput, UnitUncheckedCreateWithoutPropertyInput>
  }

  export type UnitCreateManyPropertyInputEnvelope = {
    data: UnitCreateManyPropertyInput | UnitCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type PropertyDocumentCreateWithoutPropertyInput = {
    id?: string
    documentType: $Enums.DocumentType
    documentUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyDocumentUncheckedCreateWithoutPropertyInput = {
    id?: string
    documentType: $Enums.DocumentType
    documentUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyDocumentCreateOrConnectWithoutPropertyInput = {
    where: PropertyDocumentWhereUniqueInput
    create: XOR<PropertyDocumentCreateWithoutPropertyInput, PropertyDocumentUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyDocumentCreateManyPropertyInputEnvelope = {
    data: PropertyDocumentCreateManyPropertyInput | PropertyDocumentCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type LeaseCreateWithoutPropertyInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    rent: number
    deposit: number
    rentDueCurrency: string
    status: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    unit: UnitCreateNestedOneWithoutLeaseInput
    tenant: TenantCreateNestedOneWithoutLeaseInput
    tenantLease?: TenantLeaseCreateNestedManyWithoutLeaseInput
    invoice?: InvoiceCreateNestedManyWithoutLeaseInput
    transactions?: TransactionsCreateNestedManyWithoutLeaseInput
    maintenanceRequest?: MaintenanceRequestCreateNestedManyWithoutLeaseInput
    leaseDocument?: LeaseDocumentCreateNestedManyWithoutLeaseInput
  }

  export type LeaseUncheckedCreateWithoutPropertyInput = {
    id?: string
    unitId: string
    tenantId: string
    startDate: Date | string
    endDate: Date | string
    rent: number
    deposit: number
    rentDueCurrency: string
    status: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenantLease?: TenantLeaseUncheckedCreateNestedManyWithoutLeaseInput
    invoice?: InvoiceUncheckedCreateNestedManyWithoutLeaseInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutLeaseInput
    maintenanceRequest?: MaintenanceRequestUncheckedCreateNestedManyWithoutLeaseInput
    leaseDocument?: LeaseDocumentUncheckedCreateNestedManyWithoutLeaseInput
  }

  export type LeaseCreateOrConnectWithoutPropertyInput = {
    where: LeaseWhereUniqueInput
    create: XOR<LeaseCreateWithoutPropertyInput, LeaseUncheckedCreateWithoutPropertyInput>
  }

  export type LeaseCreateManyPropertyInputEnvelope = {
    data: LeaseCreateManyPropertyInput | LeaseCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type LandlordUpsertWithoutPropertyInput = {
    update: XOR<LandlordUpdateWithoutPropertyInput, LandlordUncheckedUpdateWithoutPropertyInput>
    create: XOR<LandlordCreateWithoutPropertyInput, LandlordUncheckedCreateWithoutPropertyInput>
    where?: LandlordWhereInput
  }

  export type LandlordUpdateToOneWithWhereWithoutPropertyInput = {
    where?: LandlordWhereInput
    data: XOR<LandlordUpdateWithoutPropertyInput, LandlordUncheckedUpdateWithoutPropertyInput>
  }

  export type LandlordUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LandlordUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitUpsertWithWhereUniqueWithoutPropertyInput = {
    where: UnitWhereUniqueInput
    update: XOR<UnitUpdateWithoutPropertyInput, UnitUncheckedUpdateWithoutPropertyInput>
    create: XOR<UnitCreateWithoutPropertyInput, UnitUncheckedCreateWithoutPropertyInput>
  }

  export type UnitUpdateWithWhereUniqueWithoutPropertyInput = {
    where: UnitWhereUniqueInput
    data: XOR<UnitUpdateWithoutPropertyInput, UnitUncheckedUpdateWithoutPropertyInput>
  }

  export type UnitUpdateManyWithWhereWithoutPropertyInput = {
    where: UnitScalarWhereInput
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyWithoutPropertyInput>
  }

  export type UnitScalarWhereInput = {
    AND?: UnitScalarWhereInput | UnitScalarWhereInput[]
    OR?: UnitScalarWhereInput[]
    NOT?: UnitScalarWhereInput | UnitScalarWhereInput[]
    id?: StringFilter<"Unit"> | string
    propertyId?: StringFilter<"Unit"> | string
    name?: StringFilter<"Unit"> | string
    bedrooms?: IntFilter<"Unit"> | number
    bathrooms?: FloatFilter<"Unit"> | number
    sqmt?: FloatFilter<"Unit"> | number
    marketRent?: FloatFilter<"Unit"> | number
    deposit?: FloatFilter<"Unit"> | number
    createdAt?: DateTimeFilter<"Unit"> | Date | string
    updatedAt?: DateTimeFilter<"Unit"> | Date | string
  }

  export type PropertyDocumentUpsertWithWhereUniqueWithoutPropertyInput = {
    where: PropertyDocumentWhereUniqueInput
    update: XOR<PropertyDocumentUpdateWithoutPropertyInput, PropertyDocumentUncheckedUpdateWithoutPropertyInput>
    create: XOR<PropertyDocumentCreateWithoutPropertyInput, PropertyDocumentUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyDocumentUpdateWithWhereUniqueWithoutPropertyInput = {
    where: PropertyDocumentWhereUniqueInput
    data: XOR<PropertyDocumentUpdateWithoutPropertyInput, PropertyDocumentUncheckedUpdateWithoutPropertyInput>
  }

  export type PropertyDocumentUpdateManyWithWhereWithoutPropertyInput = {
    where: PropertyDocumentScalarWhereInput
    data: XOR<PropertyDocumentUpdateManyMutationInput, PropertyDocumentUncheckedUpdateManyWithoutPropertyInput>
  }

  export type PropertyDocumentScalarWhereInput = {
    AND?: PropertyDocumentScalarWhereInput | PropertyDocumentScalarWhereInput[]
    OR?: PropertyDocumentScalarWhereInput[]
    NOT?: PropertyDocumentScalarWhereInput | PropertyDocumentScalarWhereInput[]
    id?: StringFilter<"PropertyDocument"> | string
    propertyId?: StringFilter<"PropertyDocument"> | string
    documentType?: EnumDocumentTypeFilter<"PropertyDocument"> | $Enums.DocumentType
    documentUrl?: StringFilter<"PropertyDocument"> | string
    createdAt?: DateTimeFilter<"PropertyDocument"> | Date | string
    updatedAt?: DateTimeFilter<"PropertyDocument"> | Date | string
  }

  export type LeaseUpsertWithWhereUniqueWithoutPropertyInput = {
    where: LeaseWhereUniqueInput
    update: XOR<LeaseUpdateWithoutPropertyInput, LeaseUncheckedUpdateWithoutPropertyInput>
    create: XOR<LeaseCreateWithoutPropertyInput, LeaseUncheckedCreateWithoutPropertyInput>
  }

  export type LeaseUpdateWithWhereUniqueWithoutPropertyInput = {
    where: LeaseWhereUniqueInput
    data: XOR<LeaseUpdateWithoutPropertyInput, LeaseUncheckedUpdateWithoutPropertyInput>
  }

  export type LeaseUpdateManyWithWhereWithoutPropertyInput = {
    where: LeaseScalarWhereInput
    data: XOR<LeaseUpdateManyMutationInput, LeaseUncheckedUpdateManyWithoutPropertyInput>
  }

  export type PropertyCreateWithoutUnitInput = {
    id?: string
    name: string
    addressLine1: string
    addressLine2?: string | null
    city: string
    state: string
    zip: string
    countryCode?: string
    imageUrl?: string | null
    propertyType?: $Enums.PropertyType
    propertyStatus?: $Enums.PropertyStatus
    bedrooms?: number
    bathrooms?: number
    squareMeters?: number
    marketRent?: number
    deposit?: number
    leaseTerm?: number
    leaseTermType?: $Enums.LeaseTermType
    createdAt?: Date | string
    updatedAt?: Date | string
    sqmt?: number
    features?: PropertyCreatefeaturesInput | string[]
    amenities?: PropertyCreateamenitiesInput | string[]
    test?: string | null
    owner: LandlordCreateNestedOneWithoutPropertyInput
    propertyDocument?: PropertyDocumentCreateNestedManyWithoutPropertyInput
    Lease?: LeaseCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutUnitInput = {
    id?: string
    name: string
    addressLine1: string
    addressLine2?: string | null
    city: string
    state: string
    zip: string
    countryCode?: string
    ownerId: string
    imageUrl?: string | null
    propertyType?: $Enums.PropertyType
    propertyStatus?: $Enums.PropertyStatus
    bedrooms?: number
    bathrooms?: number
    squareMeters?: number
    marketRent?: number
    deposit?: number
    leaseTerm?: number
    leaseTermType?: $Enums.LeaseTermType
    createdAt?: Date | string
    updatedAt?: Date | string
    sqmt?: number
    features?: PropertyCreatefeaturesInput | string[]
    amenities?: PropertyCreateamenitiesInput | string[]
    test?: string | null
    propertyDocument?: PropertyDocumentUncheckedCreateNestedManyWithoutPropertyInput
    Lease?: LeaseUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutUnitInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutUnitInput, PropertyUncheckedCreateWithoutUnitInput>
  }

  export type LeaseCreateWithoutUnitInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    rent: number
    deposit: number
    rentDueCurrency: string
    status: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutLeaseInput
    tenantLease?: TenantLeaseCreateNestedManyWithoutLeaseInput
    property?: PropertyCreateNestedOneWithoutLeaseInput
    invoice?: InvoiceCreateNestedManyWithoutLeaseInput
    transactions?: TransactionsCreateNestedManyWithoutLeaseInput
    maintenanceRequest?: MaintenanceRequestCreateNestedManyWithoutLeaseInput
    leaseDocument?: LeaseDocumentCreateNestedManyWithoutLeaseInput
  }

  export type LeaseUncheckedCreateWithoutUnitInput = {
    id?: string
    tenantId: string
    startDate: Date | string
    endDate: Date | string
    rent: number
    deposit: number
    rentDueCurrency: string
    status: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    propertyId?: string | null
    tenantLease?: TenantLeaseUncheckedCreateNestedManyWithoutLeaseInput
    invoice?: InvoiceUncheckedCreateNestedManyWithoutLeaseInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutLeaseInput
    maintenanceRequest?: MaintenanceRequestUncheckedCreateNestedManyWithoutLeaseInput
    leaseDocument?: LeaseDocumentUncheckedCreateNestedManyWithoutLeaseInput
  }

  export type LeaseCreateOrConnectWithoutUnitInput = {
    where: LeaseWhereUniqueInput
    create: XOR<LeaseCreateWithoutUnitInput, LeaseUncheckedCreateWithoutUnitInput>
  }

  export type LeaseCreateManyUnitInputEnvelope = {
    data: LeaseCreateManyUnitInput | LeaseCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type PropertyUpsertWithoutUnitInput = {
    update: XOR<PropertyUpdateWithoutUnitInput, PropertyUncheckedUpdateWithoutUnitInput>
    create: XOR<PropertyCreateWithoutUnitInput, PropertyUncheckedCreateWithoutUnitInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutUnitInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutUnitInput, PropertyUncheckedUpdateWithoutUnitInput>
  }

  export type PropertyUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    propertyStatus?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: FloatFieldUpdateOperationsInput | number
    squareMeters?: FloatFieldUpdateOperationsInput | number
    marketRent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    leaseTerm?: IntFieldUpdateOperationsInput | number
    leaseTermType?: EnumLeaseTermTypeFieldUpdateOperationsInput | $Enums.LeaseTermType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sqmt?: FloatFieldUpdateOperationsInput | number
    features?: PropertyUpdatefeaturesInput | string[]
    amenities?: PropertyUpdateamenitiesInput | string[]
    test?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: LandlordUpdateOneRequiredWithoutPropertyNestedInput
    propertyDocument?: PropertyDocumentUpdateManyWithoutPropertyNestedInput
    Lease?: LeaseUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    propertyStatus?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: FloatFieldUpdateOperationsInput | number
    squareMeters?: FloatFieldUpdateOperationsInput | number
    marketRent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    leaseTerm?: IntFieldUpdateOperationsInput | number
    leaseTermType?: EnumLeaseTermTypeFieldUpdateOperationsInput | $Enums.LeaseTermType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sqmt?: FloatFieldUpdateOperationsInput | number
    features?: PropertyUpdatefeaturesInput | string[]
    amenities?: PropertyUpdateamenitiesInput | string[]
    test?: NullableStringFieldUpdateOperationsInput | string | null
    propertyDocument?: PropertyDocumentUncheckedUpdateManyWithoutPropertyNestedInput
    Lease?: LeaseUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type LeaseUpsertWithWhereUniqueWithoutUnitInput = {
    where: LeaseWhereUniqueInput
    update: XOR<LeaseUpdateWithoutUnitInput, LeaseUncheckedUpdateWithoutUnitInput>
    create: XOR<LeaseCreateWithoutUnitInput, LeaseUncheckedCreateWithoutUnitInput>
  }

  export type LeaseUpdateWithWhereUniqueWithoutUnitInput = {
    where: LeaseWhereUniqueInput
    data: XOR<LeaseUpdateWithoutUnitInput, LeaseUncheckedUpdateWithoutUnitInput>
  }

  export type LeaseUpdateManyWithWhereWithoutUnitInput = {
    where: LeaseScalarWhereInput
    data: XOR<LeaseUpdateManyMutationInput, LeaseUncheckedUpdateManyWithoutUnitInput>
  }

  export type UnitCreateWithoutLeaseInput = {
    id?: string
    name: string
    bedrooms?: number
    bathrooms?: number
    sqmt?: number
    marketRent?: number
    deposit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Property: PropertyCreateNestedOneWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutLeaseInput = {
    id?: string
    propertyId: string
    name: string
    bedrooms?: number
    bathrooms?: number
    sqmt?: number
    marketRent?: number
    deposit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitCreateOrConnectWithoutLeaseInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutLeaseInput, UnitUncheckedCreateWithoutLeaseInput>
  }

  export type TenantCreateWithoutLeaseInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    altEmail?: string | null
    phone: string
    altPhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenantLease?: TenantLeaseCreateNestedManyWithoutTenantInput
    tenantDocument?: TenantDocumentCreateNestedManyWithoutTenantInput
    tenantEmergencyContact?: TenantEmergencyContactCreateNestedManyWithoutTenantInput
    tenantIncome?: TenantIncomeCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutLeaseInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    altEmail?: string | null
    phone: string
    altPhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenantLease?: TenantLeaseUncheckedCreateNestedManyWithoutTenantInput
    tenantDocument?: TenantDocumentUncheckedCreateNestedManyWithoutTenantInput
    tenantEmergencyContact?: TenantEmergencyContactUncheckedCreateNestedManyWithoutTenantInput
    tenantIncome?: TenantIncomeUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutLeaseInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutLeaseInput, TenantUncheckedCreateWithoutLeaseInput>
  }

  export type TenantLeaseCreateWithoutLeaseInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutTenantLeaseInput
  }

  export type TenantLeaseUncheckedCreateWithoutLeaseInput = {
    id?: string
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantLeaseCreateOrConnectWithoutLeaseInput = {
    where: TenantLeaseWhereUniqueInput
    create: XOR<TenantLeaseCreateWithoutLeaseInput, TenantLeaseUncheckedCreateWithoutLeaseInput>
  }

  export type TenantLeaseCreateManyLeaseInputEnvelope = {
    data: TenantLeaseCreateManyLeaseInput | TenantLeaseCreateManyLeaseInput[]
    skipDuplicates?: boolean
  }

  export type PropertyCreateWithoutLeaseInput = {
    id?: string
    name: string
    addressLine1: string
    addressLine2?: string | null
    city: string
    state: string
    zip: string
    countryCode?: string
    imageUrl?: string | null
    propertyType?: $Enums.PropertyType
    propertyStatus?: $Enums.PropertyStatus
    bedrooms?: number
    bathrooms?: number
    squareMeters?: number
    marketRent?: number
    deposit?: number
    leaseTerm?: number
    leaseTermType?: $Enums.LeaseTermType
    createdAt?: Date | string
    updatedAt?: Date | string
    sqmt?: number
    features?: PropertyCreatefeaturesInput | string[]
    amenities?: PropertyCreateamenitiesInput | string[]
    test?: string | null
    owner: LandlordCreateNestedOneWithoutPropertyInput
    unit?: UnitCreateNestedManyWithoutPropertyInput
    propertyDocument?: PropertyDocumentCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutLeaseInput = {
    id?: string
    name: string
    addressLine1: string
    addressLine2?: string | null
    city: string
    state: string
    zip: string
    countryCode?: string
    ownerId: string
    imageUrl?: string | null
    propertyType?: $Enums.PropertyType
    propertyStatus?: $Enums.PropertyStatus
    bedrooms?: number
    bathrooms?: number
    squareMeters?: number
    marketRent?: number
    deposit?: number
    leaseTerm?: number
    leaseTermType?: $Enums.LeaseTermType
    createdAt?: Date | string
    updatedAt?: Date | string
    sqmt?: number
    features?: PropertyCreatefeaturesInput | string[]
    amenities?: PropertyCreateamenitiesInput | string[]
    test?: string | null
    unit?: UnitUncheckedCreateNestedManyWithoutPropertyInput
    propertyDocument?: PropertyDocumentUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutLeaseInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutLeaseInput, PropertyUncheckedCreateWithoutLeaseInput>
  }

  export type InvoiceCreateWithoutLeaseInput = {
    id?: string
    description: string
    dueAmount: number
    dueDate: Date | string
    category: $Enums.InvoiceCategory
    status: $Enums.InvoiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionsCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutLeaseInput = {
    id?: string
    description: string
    dueAmount: number
    dueDate: Date | string
    category: $Enums.InvoiceCategory
    status: $Enums.InvoiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionsUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutLeaseInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutLeaseInput, InvoiceUncheckedCreateWithoutLeaseInput>
  }

  export type InvoiceCreateManyLeaseInputEnvelope = {
    data: InvoiceCreateManyLeaseInput | InvoiceCreateManyLeaseInput[]
    skipDuplicates?: boolean
  }

  export type TransactionsCreateWithoutLeaseInput = {
    id?: string
    description: string
    amountPaid: number
    referenceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice?: InvoiceCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionsUncheckedCreateWithoutLeaseInput = {
    id?: string
    description: string
    amountPaid: number
    referenceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceId?: string | null
  }

  export type TransactionsCreateOrConnectWithoutLeaseInput = {
    where: TransactionsWhereUniqueInput
    create: XOR<TransactionsCreateWithoutLeaseInput, TransactionsUncheckedCreateWithoutLeaseInput>
  }

  export type TransactionsCreateManyLeaseInputEnvelope = {
    data: TransactionsCreateManyLeaseInput | TransactionsCreateManyLeaseInput[]
    skipDuplicates?: boolean
  }

  export type MaintenanceRequestCreateWithoutLeaseInput = {
    id?: string
    description: string
    status: $Enums.MaintenanceRequestStatus
    priority: $Enums.MaintenanceRequestPriority
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaintenanceRequestUncheckedCreateWithoutLeaseInput = {
    id?: string
    description: string
    status: $Enums.MaintenanceRequestStatus
    priority: $Enums.MaintenanceRequestPriority
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaintenanceRequestCreateOrConnectWithoutLeaseInput = {
    where: MaintenanceRequestWhereUniqueInput
    create: XOR<MaintenanceRequestCreateWithoutLeaseInput, MaintenanceRequestUncheckedCreateWithoutLeaseInput>
  }

  export type MaintenanceRequestCreateManyLeaseInputEnvelope = {
    data: MaintenanceRequestCreateManyLeaseInput | MaintenanceRequestCreateManyLeaseInput[]
    skipDuplicates?: boolean
  }

  export type LeaseDocumentCreateWithoutLeaseInput = {
    id?: string
    documentType: $Enums.DocumentType
    documentUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaseDocumentUncheckedCreateWithoutLeaseInput = {
    id?: string
    documentType: $Enums.DocumentType
    documentUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaseDocumentCreateOrConnectWithoutLeaseInput = {
    where: LeaseDocumentWhereUniqueInput
    create: XOR<LeaseDocumentCreateWithoutLeaseInput, LeaseDocumentUncheckedCreateWithoutLeaseInput>
  }

  export type LeaseDocumentCreateManyLeaseInputEnvelope = {
    data: LeaseDocumentCreateManyLeaseInput | LeaseDocumentCreateManyLeaseInput[]
    skipDuplicates?: boolean
  }

  export type UnitUpsertWithoutLeaseInput = {
    update: XOR<UnitUpdateWithoutLeaseInput, UnitUncheckedUpdateWithoutLeaseInput>
    create: XOR<UnitCreateWithoutLeaseInput, UnitUncheckedCreateWithoutLeaseInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutLeaseInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutLeaseInput, UnitUncheckedUpdateWithoutLeaseInput>
  }

  export type UnitUpdateWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: FloatFieldUpdateOperationsInput | number
    sqmt?: FloatFieldUpdateOperationsInput | number
    marketRent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Property?: PropertyUpdateOneRequiredWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: FloatFieldUpdateOperationsInput | number
    sqmt?: FloatFieldUpdateOperationsInput | number
    marketRent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantUpsertWithoutLeaseInput = {
    update: XOR<TenantUpdateWithoutLeaseInput, TenantUncheckedUpdateWithoutLeaseInput>
    create: XOR<TenantCreateWithoutLeaseInput, TenantUncheckedCreateWithoutLeaseInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutLeaseInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutLeaseInput, TenantUncheckedUpdateWithoutLeaseInput>
  }

  export type TenantUpdateWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    altEmail?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    altPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantLease?: TenantLeaseUpdateManyWithoutTenantNestedInput
    tenantDocument?: TenantDocumentUpdateManyWithoutTenantNestedInput
    tenantEmergencyContact?: TenantEmergencyContactUpdateManyWithoutTenantNestedInput
    tenantIncome?: TenantIncomeUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    altEmail?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    altPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantLease?: TenantLeaseUncheckedUpdateManyWithoutTenantNestedInput
    tenantDocument?: TenantDocumentUncheckedUpdateManyWithoutTenantNestedInput
    tenantEmergencyContact?: TenantEmergencyContactUncheckedUpdateManyWithoutTenantNestedInput
    tenantIncome?: TenantIncomeUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantLeaseUpsertWithWhereUniqueWithoutLeaseInput = {
    where: TenantLeaseWhereUniqueInput
    update: XOR<TenantLeaseUpdateWithoutLeaseInput, TenantLeaseUncheckedUpdateWithoutLeaseInput>
    create: XOR<TenantLeaseCreateWithoutLeaseInput, TenantLeaseUncheckedCreateWithoutLeaseInput>
  }

  export type TenantLeaseUpdateWithWhereUniqueWithoutLeaseInput = {
    where: TenantLeaseWhereUniqueInput
    data: XOR<TenantLeaseUpdateWithoutLeaseInput, TenantLeaseUncheckedUpdateWithoutLeaseInput>
  }

  export type TenantLeaseUpdateManyWithWhereWithoutLeaseInput = {
    where: TenantLeaseScalarWhereInput
    data: XOR<TenantLeaseUpdateManyMutationInput, TenantLeaseUncheckedUpdateManyWithoutLeaseInput>
  }

  export type PropertyUpsertWithoutLeaseInput = {
    update: XOR<PropertyUpdateWithoutLeaseInput, PropertyUncheckedUpdateWithoutLeaseInput>
    create: XOR<PropertyCreateWithoutLeaseInput, PropertyUncheckedCreateWithoutLeaseInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutLeaseInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutLeaseInput, PropertyUncheckedUpdateWithoutLeaseInput>
  }

  export type PropertyUpdateWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    propertyStatus?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: FloatFieldUpdateOperationsInput | number
    squareMeters?: FloatFieldUpdateOperationsInput | number
    marketRent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    leaseTerm?: IntFieldUpdateOperationsInput | number
    leaseTermType?: EnumLeaseTermTypeFieldUpdateOperationsInput | $Enums.LeaseTermType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sqmt?: FloatFieldUpdateOperationsInput | number
    features?: PropertyUpdatefeaturesInput | string[]
    amenities?: PropertyUpdateamenitiesInput | string[]
    test?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: LandlordUpdateOneRequiredWithoutPropertyNestedInput
    unit?: UnitUpdateManyWithoutPropertyNestedInput
    propertyDocument?: PropertyDocumentUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    propertyStatus?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: FloatFieldUpdateOperationsInput | number
    squareMeters?: FloatFieldUpdateOperationsInput | number
    marketRent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    leaseTerm?: IntFieldUpdateOperationsInput | number
    leaseTermType?: EnumLeaseTermTypeFieldUpdateOperationsInput | $Enums.LeaseTermType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sqmt?: FloatFieldUpdateOperationsInput | number
    features?: PropertyUpdatefeaturesInput | string[]
    amenities?: PropertyUpdateamenitiesInput | string[]
    test?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: UnitUncheckedUpdateManyWithoutPropertyNestedInput
    propertyDocument?: PropertyDocumentUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type InvoiceUpsertWithWhereUniqueWithoutLeaseInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutLeaseInput, InvoiceUncheckedUpdateWithoutLeaseInput>
    create: XOR<InvoiceCreateWithoutLeaseInput, InvoiceUncheckedCreateWithoutLeaseInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutLeaseInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutLeaseInput, InvoiceUncheckedUpdateWithoutLeaseInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutLeaseInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutLeaseInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: StringFilter<"Invoice"> | string
    leaseId?: StringFilter<"Invoice"> | string
    description?: StringFilter<"Invoice"> | string
    dueAmount?: FloatFilter<"Invoice"> | number
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    category?: EnumInvoiceCategoryFilter<"Invoice"> | $Enums.InvoiceCategory
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
  }

  export type TransactionsUpsertWithWhereUniqueWithoutLeaseInput = {
    where: TransactionsWhereUniqueInput
    update: XOR<TransactionsUpdateWithoutLeaseInput, TransactionsUncheckedUpdateWithoutLeaseInput>
    create: XOR<TransactionsCreateWithoutLeaseInput, TransactionsUncheckedCreateWithoutLeaseInput>
  }

  export type TransactionsUpdateWithWhereUniqueWithoutLeaseInput = {
    where: TransactionsWhereUniqueInput
    data: XOR<TransactionsUpdateWithoutLeaseInput, TransactionsUncheckedUpdateWithoutLeaseInput>
  }

  export type TransactionsUpdateManyWithWhereWithoutLeaseInput = {
    where: TransactionsScalarWhereInput
    data: XOR<TransactionsUpdateManyMutationInput, TransactionsUncheckedUpdateManyWithoutLeaseInput>
  }

  export type TransactionsScalarWhereInput = {
    AND?: TransactionsScalarWhereInput | TransactionsScalarWhereInput[]
    OR?: TransactionsScalarWhereInput[]
    NOT?: TransactionsScalarWhereInput | TransactionsScalarWhereInput[]
    id?: StringFilter<"Transactions"> | string
    leaseId?: StringFilter<"Transactions"> | string
    description?: StringFilter<"Transactions"> | string
    amountPaid?: FloatFilter<"Transactions"> | number
    referenceId?: StringNullableFilter<"Transactions"> | string | null
    createdAt?: DateTimeFilter<"Transactions"> | Date | string
    updatedAt?: DateTimeFilter<"Transactions"> | Date | string
    invoiceId?: StringNullableFilter<"Transactions"> | string | null
  }

  export type MaintenanceRequestUpsertWithWhereUniqueWithoutLeaseInput = {
    where: MaintenanceRequestWhereUniqueInput
    update: XOR<MaintenanceRequestUpdateWithoutLeaseInput, MaintenanceRequestUncheckedUpdateWithoutLeaseInput>
    create: XOR<MaintenanceRequestCreateWithoutLeaseInput, MaintenanceRequestUncheckedCreateWithoutLeaseInput>
  }

  export type MaintenanceRequestUpdateWithWhereUniqueWithoutLeaseInput = {
    where: MaintenanceRequestWhereUniqueInput
    data: XOR<MaintenanceRequestUpdateWithoutLeaseInput, MaintenanceRequestUncheckedUpdateWithoutLeaseInput>
  }

  export type MaintenanceRequestUpdateManyWithWhereWithoutLeaseInput = {
    where: MaintenanceRequestScalarWhereInput
    data: XOR<MaintenanceRequestUpdateManyMutationInput, MaintenanceRequestUncheckedUpdateManyWithoutLeaseInput>
  }

  export type MaintenanceRequestScalarWhereInput = {
    AND?: MaintenanceRequestScalarWhereInput | MaintenanceRequestScalarWhereInput[]
    OR?: MaintenanceRequestScalarWhereInput[]
    NOT?: MaintenanceRequestScalarWhereInput | MaintenanceRequestScalarWhereInput[]
    id?: StringFilter<"MaintenanceRequest"> | string
    leaseId?: StringFilter<"MaintenanceRequest"> | string
    description?: StringFilter<"MaintenanceRequest"> | string
    status?: EnumMaintenanceRequestStatusFilter<"MaintenanceRequest"> | $Enums.MaintenanceRequestStatus
    priority?: EnumMaintenanceRequestPriorityFilter<"MaintenanceRequest"> | $Enums.MaintenanceRequestPriority
    createdAt?: DateTimeFilter<"MaintenanceRequest"> | Date | string
    updatedAt?: DateTimeFilter<"MaintenanceRequest"> | Date | string
  }

  export type LeaseDocumentUpsertWithWhereUniqueWithoutLeaseInput = {
    where: LeaseDocumentWhereUniqueInput
    update: XOR<LeaseDocumentUpdateWithoutLeaseInput, LeaseDocumentUncheckedUpdateWithoutLeaseInput>
    create: XOR<LeaseDocumentCreateWithoutLeaseInput, LeaseDocumentUncheckedCreateWithoutLeaseInput>
  }

  export type LeaseDocumentUpdateWithWhereUniqueWithoutLeaseInput = {
    where: LeaseDocumentWhereUniqueInput
    data: XOR<LeaseDocumentUpdateWithoutLeaseInput, LeaseDocumentUncheckedUpdateWithoutLeaseInput>
  }

  export type LeaseDocumentUpdateManyWithWhereWithoutLeaseInput = {
    where: LeaseDocumentScalarWhereInput
    data: XOR<LeaseDocumentUpdateManyMutationInput, LeaseDocumentUncheckedUpdateManyWithoutLeaseInput>
  }

  export type LeaseDocumentScalarWhereInput = {
    AND?: LeaseDocumentScalarWhereInput | LeaseDocumentScalarWhereInput[]
    OR?: LeaseDocumentScalarWhereInput[]
    NOT?: LeaseDocumentScalarWhereInput | LeaseDocumentScalarWhereInput[]
    id?: StringFilter<"LeaseDocument"> | string
    leaseId?: StringFilter<"LeaseDocument"> | string
    documentType?: EnumDocumentTypeFilter<"LeaseDocument"> | $Enums.DocumentType
    documentUrl?: StringFilter<"LeaseDocument"> | string
    createdAt?: DateTimeFilter<"LeaseDocument"> | Date | string
    updatedAt?: DateTimeFilter<"LeaseDocument"> | Date | string
  }

  export type LeaseCreateWithoutInvoiceInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    rent: number
    deposit: number
    rentDueCurrency: string
    status: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    unit: UnitCreateNestedOneWithoutLeaseInput
    tenant: TenantCreateNestedOneWithoutLeaseInput
    tenantLease?: TenantLeaseCreateNestedManyWithoutLeaseInput
    property?: PropertyCreateNestedOneWithoutLeaseInput
    transactions?: TransactionsCreateNestedManyWithoutLeaseInput
    maintenanceRequest?: MaintenanceRequestCreateNestedManyWithoutLeaseInput
    leaseDocument?: LeaseDocumentCreateNestedManyWithoutLeaseInput
  }

  export type LeaseUncheckedCreateWithoutInvoiceInput = {
    id?: string
    unitId: string
    tenantId: string
    startDate: Date | string
    endDate: Date | string
    rent: number
    deposit: number
    rentDueCurrency: string
    status: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    propertyId?: string | null
    tenantLease?: TenantLeaseUncheckedCreateNestedManyWithoutLeaseInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutLeaseInput
    maintenanceRequest?: MaintenanceRequestUncheckedCreateNestedManyWithoutLeaseInput
    leaseDocument?: LeaseDocumentUncheckedCreateNestedManyWithoutLeaseInput
  }

  export type LeaseCreateOrConnectWithoutInvoiceInput = {
    where: LeaseWhereUniqueInput
    create: XOR<LeaseCreateWithoutInvoiceInput, LeaseUncheckedCreateWithoutInvoiceInput>
  }

  export type TransactionsCreateWithoutInvoiceInput = {
    id?: string
    description: string
    amountPaid: number
    referenceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lease: LeaseCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionsUncheckedCreateWithoutInvoiceInput = {
    id?: string
    leaseId: string
    description: string
    amountPaid: number
    referenceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionsCreateOrConnectWithoutInvoiceInput = {
    where: TransactionsWhereUniqueInput
    create: XOR<TransactionsCreateWithoutInvoiceInput, TransactionsUncheckedCreateWithoutInvoiceInput>
  }

  export type TransactionsCreateManyInvoiceInputEnvelope = {
    data: TransactionsCreateManyInvoiceInput | TransactionsCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type LeaseUpsertWithoutInvoiceInput = {
    update: XOR<LeaseUpdateWithoutInvoiceInput, LeaseUncheckedUpdateWithoutInvoiceInput>
    create: XOR<LeaseCreateWithoutInvoiceInput, LeaseUncheckedCreateWithoutInvoiceInput>
    where?: LeaseWhereInput
  }

  export type LeaseUpdateToOneWithWhereWithoutInvoiceInput = {
    where?: LeaseWhereInput
    data: XOR<LeaseUpdateWithoutInvoiceInput, LeaseUncheckedUpdateWithoutInvoiceInput>
  }

  export type LeaseUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    rentDueCurrency?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitUpdateOneRequiredWithoutLeaseNestedInput
    tenant?: TenantUpdateOneRequiredWithoutLeaseNestedInput
    tenantLease?: TenantLeaseUpdateManyWithoutLeaseNestedInput
    property?: PropertyUpdateOneWithoutLeaseNestedInput
    transactions?: TransactionsUpdateManyWithoutLeaseNestedInput
    maintenanceRequest?: MaintenanceRequestUpdateManyWithoutLeaseNestedInput
    leaseDocument?: LeaseDocumentUpdateManyWithoutLeaseNestedInput
  }

  export type LeaseUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    rentDueCurrency?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    tenantLease?: TenantLeaseUncheckedUpdateManyWithoutLeaseNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutLeaseNestedInput
    maintenanceRequest?: MaintenanceRequestUncheckedUpdateManyWithoutLeaseNestedInput
    leaseDocument?: LeaseDocumentUncheckedUpdateManyWithoutLeaseNestedInput
  }

  export type TransactionsUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: TransactionsWhereUniqueInput
    update: XOR<TransactionsUpdateWithoutInvoiceInput, TransactionsUncheckedUpdateWithoutInvoiceInput>
    create: XOR<TransactionsCreateWithoutInvoiceInput, TransactionsUncheckedCreateWithoutInvoiceInput>
  }

  export type TransactionsUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: TransactionsWhereUniqueInput
    data: XOR<TransactionsUpdateWithoutInvoiceInput, TransactionsUncheckedUpdateWithoutInvoiceInput>
  }

  export type TransactionsUpdateManyWithWhereWithoutInvoiceInput = {
    where: TransactionsScalarWhereInput
    data: XOR<TransactionsUpdateManyMutationInput, TransactionsUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type LeaseCreateWithoutTransactionsInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    rent: number
    deposit: number
    rentDueCurrency: string
    status: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    unit: UnitCreateNestedOneWithoutLeaseInput
    tenant: TenantCreateNestedOneWithoutLeaseInput
    tenantLease?: TenantLeaseCreateNestedManyWithoutLeaseInput
    property?: PropertyCreateNestedOneWithoutLeaseInput
    invoice?: InvoiceCreateNestedManyWithoutLeaseInput
    maintenanceRequest?: MaintenanceRequestCreateNestedManyWithoutLeaseInput
    leaseDocument?: LeaseDocumentCreateNestedManyWithoutLeaseInput
  }

  export type LeaseUncheckedCreateWithoutTransactionsInput = {
    id?: string
    unitId: string
    tenantId: string
    startDate: Date | string
    endDate: Date | string
    rent: number
    deposit: number
    rentDueCurrency: string
    status: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    propertyId?: string | null
    tenantLease?: TenantLeaseUncheckedCreateNestedManyWithoutLeaseInput
    invoice?: InvoiceUncheckedCreateNestedManyWithoutLeaseInput
    maintenanceRequest?: MaintenanceRequestUncheckedCreateNestedManyWithoutLeaseInput
    leaseDocument?: LeaseDocumentUncheckedCreateNestedManyWithoutLeaseInput
  }

  export type LeaseCreateOrConnectWithoutTransactionsInput = {
    where: LeaseWhereUniqueInput
    create: XOR<LeaseCreateWithoutTransactionsInput, LeaseUncheckedCreateWithoutTransactionsInput>
  }

  export type InvoiceCreateWithoutTransactionsInput = {
    id?: string
    description: string
    dueAmount: number
    dueDate: Date | string
    category: $Enums.InvoiceCategory
    status: $Enums.InvoiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    lease: LeaseCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutTransactionsInput = {
    id?: string
    leaseId: string
    description: string
    dueAmount: number
    dueDate: Date | string
    category: $Enums.InvoiceCategory
    status: $Enums.InvoiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateOrConnectWithoutTransactionsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutTransactionsInput, InvoiceUncheckedCreateWithoutTransactionsInput>
  }

  export type LeaseUpsertWithoutTransactionsInput = {
    update: XOR<LeaseUpdateWithoutTransactionsInput, LeaseUncheckedUpdateWithoutTransactionsInput>
    create: XOR<LeaseCreateWithoutTransactionsInput, LeaseUncheckedCreateWithoutTransactionsInput>
    where?: LeaseWhereInput
  }

  export type LeaseUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: LeaseWhereInput
    data: XOR<LeaseUpdateWithoutTransactionsInput, LeaseUncheckedUpdateWithoutTransactionsInput>
  }

  export type LeaseUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    rentDueCurrency?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitUpdateOneRequiredWithoutLeaseNestedInput
    tenant?: TenantUpdateOneRequiredWithoutLeaseNestedInput
    tenantLease?: TenantLeaseUpdateManyWithoutLeaseNestedInput
    property?: PropertyUpdateOneWithoutLeaseNestedInput
    invoice?: InvoiceUpdateManyWithoutLeaseNestedInput
    maintenanceRequest?: MaintenanceRequestUpdateManyWithoutLeaseNestedInput
    leaseDocument?: LeaseDocumentUpdateManyWithoutLeaseNestedInput
  }

  export type LeaseUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    rentDueCurrency?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    tenantLease?: TenantLeaseUncheckedUpdateManyWithoutLeaseNestedInput
    invoice?: InvoiceUncheckedUpdateManyWithoutLeaseNestedInput
    maintenanceRequest?: MaintenanceRequestUncheckedUpdateManyWithoutLeaseNestedInput
    leaseDocument?: LeaseDocumentUncheckedUpdateManyWithoutLeaseNestedInput
  }

  export type InvoiceUpsertWithoutTransactionsInput = {
    update: XOR<InvoiceUpdateWithoutTransactionsInput, InvoiceUncheckedUpdateWithoutTransactionsInput>
    create: XOR<InvoiceCreateWithoutTransactionsInput, InvoiceUncheckedCreateWithoutTransactionsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutTransactionsInput, InvoiceUncheckedUpdateWithoutTransactionsInput>
  }

  export type InvoiceUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dueAmount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumInvoiceCategoryFieldUpdateOperationsInput | $Enums.InvoiceCategory
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lease?: LeaseUpdateOneRequiredWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaseId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dueAmount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumInvoiceCategoryFieldUpdateOperationsInput | $Enums.InvoiceCategory
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantCreateWithoutTenantLeaseInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    altEmail?: string | null
    phone: string
    altPhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Lease?: LeaseCreateNestedManyWithoutTenantInput
    tenantDocument?: TenantDocumentCreateNestedManyWithoutTenantInput
    tenantEmergencyContact?: TenantEmergencyContactCreateNestedManyWithoutTenantInput
    tenantIncome?: TenantIncomeCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutTenantLeaseInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    altEmail?: string | null
    phone: string
    altPhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Lease?: LeaseUncheckedCreateNestedManyWithoutTenantInput
    tenantDocument?: TenantDocumentUncheckedCreateNestedManyWithoutTenantInput
    tenantEmergencyContact?: TenantEmergencyContactUncheckedCreateNestedManyWithoutTenantInput
    tenantIncome?: TenantIncomeUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutTenantLeaseInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutTenantLeaseInput, TenantUncheckedCreateWithoutTenantLeaseInput>
  }

  export type LeaseCreateWithoutTenantLeaseInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    rent: number
    deposit: number
    rentDueCurrency: string
    status: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    unit: UnitCreateNestedOneWithoutLeaseInput
    tenant: TenantCreateNestedOneWithoutLeaseInput
    property?: PropertyCreateNestedOneWithoutLeaseInput
    invoice?: InvoiceCreateNestedManyWithoutLeaseInput
    transactions?: TransactionsCreateNestedManyWithoutLeaseInput
    maintenanceRequest?: MaintenanceRequestCreateNestedManyWithoutLeaseInput
    leaseDocument?: LeaseDocumentCreateNestedManyWithoutLeaseInput
  }

  export type LeaseUncheckedCreateWithoutTenantLeaseInput = {
    id?: string
    unitId: string
    tenantId: string
    startDate: Date | string
    endDate: Date | string
    rent: number
    deposit: number
    rentDueCurrency: string
    status: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    propertyId?: string | null
    invoice?: InvoiceUncheckedCreateNestedManyWithoutLeaseInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutLeaseInput
    maintenanceRequest?: MaintenanceRequestUncheckedCreateNestedManyWithoutLeaseInput
    leaseDocument?: LeaseDocumentUncheckedCreateNestedManyWithoutLeaseInput
  }

  export type LeaseCreateOrConnectWithoutTenantLeaseInput = {
    where: LeaseWhereUniqueInput
    create: XOR<LeaseCreateWithoutTenantLeaseInput, LeaseUncheckedCreateWithoutTenantLeaseInput>
  }

  export type TenantUpsertWithoutTenantLeaseInput = {
    update: XOR<TenantUpdateWithoutTenantLeaseInput, TenantUncheckedUpdateWithoutTenantLeaseInput>
    create: XOR<TenantCreateWithoutTenantLeaseInput, TenantUncheckedCreateWithoutTenantLeaseInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutTenantLeaseInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutTenantLeaseInput, TenantUncheckedUpdateWithoutTenantLeaseInput>
  }

  export type TenantUpdateWithoutTenantLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    altEmail?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    altPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Lease?: LeaseUpdateManyWithoutTenantNestedInput
    tenantDocument?: TenantDocumentUpdateManyWithoutTenantNestedInput
    tenantEmergencyContact?: TenantEmergencyContactUpdateManyWithoutTenantNestedInput
    tenantIncome?: TenantIncomeUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutTenantLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    altEmail?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    altPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Lease?: LeaseUncheckedUpdateManyWithoutTenantNestedInput
    tenantDocument?: TenantDocumentUncheckedUpdateManyWithoutTenantNestedInput
    tenantEmergencyContact?: TenantEmergencyContactUncheckedUpdateManyWithoutTenantNestedInput
    tenantIncome?: TenantIncomeUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type LeaseUpsertWithoutTenantLeaseInput = {
    update: XOR<LeaseUpdateWithoutTenantLeaseInput, LeaseUncheckedUpdateWithoutTenantLeaseInput>
    create: XOR<LeaseCreateWithoutTenantLeaseInput, LeaseUncheckedCreateWithoutTenantLeaseInput>
    where?: LeaseWhereInput
  }

  export type LeaseUpdateToOneWithWhereWithoutTenantLeaseInput = {
    where?: LeaseWhereInput
    data: XOR<LeaseUpdateWithoutTenantLeaseInput, LeaseUncheckedUpdateWithoutTenantLeaseInput>
  }

  export type LeaseUpdateWithoutTenantLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    rentDueCurrency?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitUpdateOneRequiredWithoutLeaseNestedInput
    tenant?: TenantUpdateOneRequiredWithoutLeaseNestedInput
    property?: PropertyUpdateOneWithoutLeaseNestedInput
    invoice?: InvoiceUpdateManyWithoutLeaseNestedInput
    transactions?: TransactionsUpdateManyWithoutLeaseNestedInput
    maintenanceRequest?: MaintenanceRequestUpdateManyWithoutLeaseNestedInput
    leaseDocument?: LeaseDocumentUpdateManyWithoutLeaseNestedInput
  }

  export type LeaseUncheckedUpdateWithoutTenantLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    rentDueCurrency?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: InvoiceUncheckedUpdateManyWithoutLeaseNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutLeaseNestedInput
    maintenanceRequest?: MaintenanceRequestUncheckedUpdateManyWithoutLeaseNestedInput
    leaseDocument?: LeaseDocumentUncheckedUpdateManyWithoutLeaseNestedInput
  }

  export type LeaseCreateWithoutMaintenanceRequestInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    rent: number
    deposit: number
    rentDueCurrency: string
    status: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    unit: UnitCreateNestedOneWithoutLeaseInput
    tenant: TenantCreateNestedOneWithoutLeaseInput
    tenantLease?: TenantLeaseCreateNestedManyWithoutLeaseInput
    property?: PropertyCreateNestedOneWithoutLeaseInput
    invoice?: InvoiceCreateNestedManyWithoutLeaseInput
    transactions?: TransactionsCreateNestedManyWithoutLeaseInput
    leaseDocument?: LeaseDocumentCreateNestedManyWithoutLeaseInput
  }

  export type LeaseUncheckedCreateWithoutMaintenanceRequestInput = {
    id?: string
    unitId: string
    tenantId: string
    startDate: Date | string
    endDate: Date | string
    rent: number
    deposit: number
    rentDueCurrency: string
    status: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    propertyId?: string | null
    tenantLease?: TenantLeaseUncheckedCreateNestedManyWithoutLeaseInput
    invoice?: InvoiceUncheckedCreateNestedManyWithoutLeaseInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutLeaseInput
    leaseDocument?: LeaseDocumentUncheckedCreateNestedManyWithoutLeaseInput
  }

  export type LeaseCreateOrConnectWithoutMaintenanceRequestInput = {
    where: LeaseWhereUniqueInput
    create: XOR<LeaseCreateWithoutMaintenanceRequestInput, LeaseUncheckedCreateWithoutMaintenanceRequestInput>
  }

  export type LeaseUpsertWithoutMaintenanceRequestInput = {
    update: XOR<LeaseUpdateWithoutMaintenanceRequestInput, LeaseUncheckedUpdateWithoutMaintenanceRequestInput>
    create: XOR<LeaseCreateWithoutMaintenanceRequestInput, LeaseUncheckedCreateWithoutMaintenanceRequestInput>
    where?: LeaseWhereInput
  }

  export type LeaseUpdateToOneWithWhereWithoutMaintenanceRequestInput = {
    where?: LeaseWhereInput
    data: XOR<LeaseUpdateWithoutMaintenanceRequestInput, LeaseUncheckedUpdateWithoutMaintenanceRequestInput>
  }

  export type LeaseUpdateWithoutMaintenanceRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    rentDueCurrency?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitUpdateOneRequiredWithoutLeaseNestedInput
    tenant?: TenantUpdateOneRequiredWithoutLeaseNestedInput
    tenantLease?: TenantLeaseUpdateManyWithoutLeaseNestedInput
    property?: PropertyUpdateOneWithoutLeaseNestedInput
    invoice?: InvoiceUpdateManyWithoutLeaseNestedInput
    transactions?: TransactionsUpdateManyWithoutLeaseNestedInput
    leaseDocument?: LeaseDocumentUpdateManyWithoutLeaseNestedInput
  }

  export type LeaseUncheckedUpdateWithoutMaintenanceRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    rentDueCurrency?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    tenantLease?: TenantLeaseUncheckedUpdateManyWithoutLeaseNestedInput
    invoice?: InvoiceUncheckedUpdateManyWithoutLeaseNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutLeaseNestedInput
    leaseDocument?: LeaseDocumentUncheckedUpdateManyWithoutLeaseNestedInput
  }

  export type TenantCreateWithoutTenantDocumentInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    altEmail?: string | null
    phone: string
    altPhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Lease?: LeaseCreateNestedManyWithoutTenantInput
    tenantLease?: TenantLeaseCreateNestedManyWithoutTenantInput
    tenantEmergencyContact?: TenantEmergencyContactCreateNestedManyWithoutTenantInput
    tenantIncome?: TenantIncomeCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutTenantDocumentInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    altEmail?: string | null
    phone: string
    altPhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Lease?: LeaseUncheckedCreateNestedManyWithoutTenantInput
    tenantLease?: TenantLeaseUncheckedCreateNestedManyWithoutTenantInput
    tenantEmergencyContact?: TenantEmergencyContactUncheckedCreateNestedManyWithoutTenantInput
    tenantIncome?: TenantIncomeUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutTenantDocumentInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutTenantDocumentInput, TenantUncheckedCreateWithoutTenantDocumentInput>
  }

  export type TenantUpsertWithoutTenantDocumentInput = {
    update: XOR<TenantUpdateWithoutTenantDocumentInput, TenantUncheckedUpdateWithoutTenantDocumentInput>
    create: XOR<TenantCreateWithoutTenantDocumentInput, TenantUncheckedCreateWithoutTenantDocumentInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutTenantDocumentInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutTenantDocumentInput, TenantUncheckedUpdateWithoutTenantDocumentInput>
  }

  export type TenantUpdateWithoutTenantDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    altEmail?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    altPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Lease?: LeaseUpdateManyWithoutTenantNestedInput
    tenantLease?: TenantLeaseUpdateManyWithoutTenantNestedInput
    tenantEmergencyContact?: TenantEmergencyContactUpdateManyWithoutTenantNestedInput
    tenantIncome?: TenantIncomeUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutTenantDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    altEmail?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    altPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Lease?: LeaseUncheckedUpdateManyWithoutTenantNestedInput
    tenantLease?: TenantLeaseUncheckedUpdateManyWithoutTenantNestedInput
    tenantEmergencyContact?: TenantEmergencyContactUncheckedUpdateManyWithoutTenantNestedInput
    tenantIncome?: TenantIncomeUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type LeaseCreateWithoutLeaseDocumentInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    rent: number
    deposit: number
    rentDueCurrency: string
    status: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    unit: UnitCreateNestedOneWithoutLeaseInput
    tenant: TenantCreateNestedOneWithoutLeaseInput
    tenantLease?: TenantLeaseCreateNestedManyWithoutLeaseInput
    property?: PropertyCreateNestedOneWithoutLeaseInput
    invoice?: InvoiceCreateNestedManyWithoutLeaseInput
    transactions?: TransactionsCreateNestedManyWithoutLeaseInput
    maintenanceRequest?: MaintenanceRequestCreateNestedManyWithoutLeaseInput
  }

  export type LeaseUncheckedCreateWithoutLeaseDocumentInput = {
    id?: string
    unitId: string
    tenantId: string
    startDate: Date | string
    endDate: Date | string
    rent: number
    deposit: number
    rentDueCurrency: string
    status: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    propertyId?: string | null
    tenantLease?: TenantLeaseUncheckedCreateNestedManyWithoutLeaseInput
    invoice?: InvoiceUncheckedCreateNestedManyWithoutLeaseInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutLeaseInput
    maintenanceRequest?: MaintenanceRequestUncheckedCreateNestedManyWithoutLeaseInput
  }

  export type LeaseCreateOrConnectWithoutLeaseDocumentInput = {
    where: LeaseWhereUniqueInput
    create: XOR<LeaseCreateWithoutLeaseDocumentInput, LeaseUncheckedCreateWithoutLeaseDocumentInput>
  }

  export type LeaseUpsertWithoutLeaseDocumentInput = {
    update: XOR<LeaseUpdateWithoutLeaseDocumentInput, LeaseUncheckedUpdateWithoutLeaseDocumentInput>
    create: XOR<LeaseCreateWithoutLeaseDocumentInput, LeaseUncheckedCreateWithoutLeaseDocumentInput>
    where?: LeaseWhereInput
  }

  export type LeaseUpdateToOneWithWhereWithoutLeaseDocumentInput = {
    where?: LeaseWhereInput
    data: XOR<LeaseUpdateWithoutLeaseDocumentInput, LeaseUncheckedUpdateWithoutLeaseDocumentInput>
  }

  export type LeaseUpdateWithoutLeaseDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    rentDueCurrency?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitUpdateOneRequiredWithoutLeaseNestedInput
    tenant?: TenantUpdateOneRequiredWithoutLeaseNestedInput
    tenantLease?: TenantLeaseUpdateManyWithoutLeaseNestedInput
    property?: PropertyUpdateOneWithoutLeaseNestedInput
    invoice?: InvoiceUpdateManyWithoutLeaseNestedInput
    transactions?: TransactionsUpdateManyWithoutLeaseNestedInput
    maintenanceRequest?: MaintenanceRequestUpdateManyWithoutLeaseNestedInput
  }

  export type LeaseUncheckedUpdateWithoutLeaseDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    rentDueCurrency?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    tenantLease?: TenantLeaseUncheckedUpdateManyWithoutLeaseNestedInput
    invoice?: InvoiceUncheckedUpdateManyWithoutLeaseNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutLeaseNestedInput
    maintenanceRequest?: MaintenanceRequestUncheckedUpdateManyWithoutLeaseNestedInput
  }

  export type PropertyCreateWithoutPropertyDocumentInput = {
    id?: string
    name: string
    addressLine1: string
    addressLine2?: string | null
    city: string
    state: string
    zip: string
    countryCode?: string
    imageUrl?: string | null
    propertyType?: $Enums.PropertyType
    propertyStatus?: $Enums.PropertyStatus
    bedrooms?: number
    bathrooms?: number
    squareMeters?: number
    marketRent?: number
    deposit?: number
    leaseTerm?: number
    leaseTermType?: $Enums.LeaseTermType
    createdAt?: Date | string
    updatedAt?: Date | string
    sqmt?: number
    features?: PropertyCreatefeaturesInput | string[]
    amenities?: PropertyCreateamenitiesInput | string[]
    test?: string | null
    owner: LandlordCreateNestedOneWithoutPropertyInput
    unit?: UnitCreateNestedManyWithoutPropertyInput
    Lease?: LeaseCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutPropertyDocumentInput = {
    id?: string
    name: string
    addressLine1: string
    addressLine2?: string | null
    city: string
    state: string
    zip: string
    countryCode?: string
    ownerId: string
    imageUrl?: string | null
    propertyType?: $Enums.PropertyType
    propertyStatus?: $Enums.PropertyStatus
    bedrooms?: number
    bathrooms?: number
    squareMeters?: number
    marketRent?: number
    deposit?: number
    leaseTerm?: number
    leaseTermType?: $Enums.LeaseTermType
    createdAt?: Date | string
    updatedAt?: Date | string
    sqmt?: number
    features?: PropertyCreatefeaturesInput | string[]
    amenities?: PropertyCreateamenitiesInput | string[]
    test?: string | null
    unit?: UnitUncheckedCreateNestedManyWithoutPropertyInput
    Lease?: LeaseUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutPropertyDocumentInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutPropertyDocumentInput, PropertyUncheckedCreateWithoutPropertyDocumentInput>
  }

  export type PropertyUpsertWithoutPropertyDocumentInput = {
    update: XOR<PropertyUpdateWithoutPropertyDocumentInput, PropertyUncheckedUpdateWithoutPropertyDocumentInput>
    create: XOR<PropertyCreateWithoutPropertyDocumentInput, PropertyUncheckedCreateWithoutPropertyDocumentInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutPropertyDocumentInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutPropertyDocumentInput, PropertyUncheckedUpdateWithoutPropertyDocumentInput>
  }

  export type PropertyUpdateWithoutPropertyDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    propertyStatus?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: FloatFieldUpdateOperationsInput | number
    squareMeters?: FloatFieldUpdateOperationsInput | number
    marketRent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    leaseTerm?: IntFieldUpdateOperationsInput | number
    leaseTermType?: EnumLeaseTermTypeFieldUpdateOperationsInput | $Enums.LeaseTermType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sqmt?: FloatFieldUpdateOperationsInput | number
    features?: PropertyUpdatefeaturesInput | string[]
    amenities?: PropertyUpdateamenitiesInput | string[]
    test?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: LandlordUpdateOneRequiredWithoutPropertyNestedInput
    unit?: UnitUpdateManyWithoutPropertyNestedInput
    Lease?: LeaseUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutPropertyDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    propertyStatus?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: FloatFieldUpdateOperationsInput | number
    squareMeters?: FloatFieldUpdateOperationsInput | number
    marketRent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    leaseTerm?: IntFieldUpdateOperationsInput | number
    leaseTermType?: EnumLeaseTermTypeFieldUpdateOperationsInput | $Enums.LeaseTermType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sqmt?: FloatFieldUpdateOperationsInput | number
    features?: PropertyUpdatefeaturesInput | string[]
    amenities?: PropertyUpdateamenitiesInput | string[]
    test?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: UnitUncheckedUpdateManyWithoutPropertyNestedInput
    Lease?: LeaseUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type LeaseCreateManyTenantInput = {
    id?: string
    unitId: string
    startDate: Date | string
    endDate: Date | string
    rent: number
    deposit: number
    rentDueCurrency: string
    status: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    propertyId?: string | null
  }

  export type TenantLeaseCreateManyTenantInput = {
    id?: string
    leaseId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantDocumentCreateManyTenantInput = {
    id?: string
    documentType: $Enums.TenantDocumentType
    documentUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantEmergencyContactCreateManyTenantInput = {
    id?: string
    name: string
    phone: string
    email: string
    relationship: $Enums.TenantRelationship
    addressLine1: string
    addressLine2?: string | null
    city: string
    state: string
    zip: string
    countryCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantIncomeCreateManyTenantInput = {
    id?: string
    income: number
    incomeType: $Enums.TenantIncomeType
    position?: string | null
    employer?: string | null
    employerAddressLine1?: string | null
    employerAddressLine2?: string | null
    employerCity?: string | null
    employerState?: string | null
    employerZip?: string | null
    employerCountryCode?: string | null
    startDate: Date | string
    endDate: Date | string
    currentIncome?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaseUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    rentDueCurrency?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitUpdateOneRequiredWithoutLeaseNestedInput
    tenantLease?: TenantLeaseUpdateManyWithoutLeaseNestedInput
    property?: PropertyUpdateOneWithoutLeaseNestedInput
    invoice?: InvoiceUpdateManyWithoutLeaseNestedInput
    transactions?: TransactionsUpdateManyWithoutLeaseNestedInput
    maintenanceRequest?: MaintenanceRequestUpdateManyWithoutLeaseNestedInput
    leaseDocument?: LeaseDocumentUpdateManyWithoutLeaseNestedInput
  }

  export type LeaseUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    rentDueCurrency?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    tenantLease?: TenantLeaseUncheckedUpdateManyWithoutLeaseNestedInput
    invoice?: InvoiceUncheckedUpdateManyWithoutLeaseNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutLeaseNestedInput
    maintenanceRequest?: MaintenanceRequestUncheckedUpdateManyWithoutLeaseNestedInput
    leaseDocument?: LeaseDocumentUncheckedUpdateManyWithoutLeaseNestedInput
  }

  export type LeaseUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    rentDueCurrency?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TenantLeaseUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lease?: LeaseUpdateOneRequiredWithoutTenantLeaseNestedInput
  }

  export type TenantLeaseUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaseId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantLeaseUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaseId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantDocumentUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumTenantDocumentTypeFieldUpdateOperationsInput | $Enums.TenantDocumentType
    documentUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantDocumentUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumTenantDocumentTypeFieldUpdateOperationsInput | $Enums.TenantDocumentType
    documentUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantDocumentUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumTenantDocumentTypeFieldUpdateOperationsInput | $Enums.TenantDocumentType
    documentUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantEmergencyContactUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    relationship?: EnumTenantRelationshipFieldUpdateOperationsInput | $Enums.TenantRelationship
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantEmergencyContactUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    relationship?: EnumTenantRelationshipFieldUpdateOperationsInput | $Enums.TenantRelationship
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantEmergencyContactUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    relationship?: EnumTenantRelationshipFieldUpdateOperationsInput | $Enums.TenantRelationship
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantIncomeUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    income?: FloatFieldUpdateOperationsInput | number
    incomeType?: EnumTenantIncomeTypeFieldUpdateOperationsInput | $Enums.TenantIncomeType
    position?: NullableStringFieldUpdateOperationsInput | string | null
    employer?: NullableStringFieldUpdateOperationsInput | string | null
    employerAddressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    employerAddressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    employerCity?: NullableStringFieldUpdateOperationsInput | string | null
    employerState?: NullableStringFieldUpdateOperationsInput | string | null
    employerZip?: NullableStringFieldUpdateOperationsInput | string | null
    employerCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currentIncome?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantIncomeUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    income?: FloatFieldUpdateOperationsInput | number
    incomeType?: EnumTenantIncomeTypeFieldUpdateOperationsInput | $Enums.TenantIncomeType
    position?: NullableStringFieldUpdateOperationsInput | string | null
    employer?: NullableStringFieldUpdateOperationsInput | string | null
    employerAddressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    employerAddressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    employerCity?: NullableStringFieldUpdateOperationsInput | string | null
    employerState?: NullableStringFieldUpdateOperationsInput | string | null
    employerZip?: NullableStringFieldUpdateOperationsInput | string | null
    employerCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currentIncome?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantIncomeUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    income?: FloatFieldUpdateOperationsInput | number
    incomeType?: EnumTenantIncomeTypeFieldUpdateOperationsInput | $Enums.TenantIncomeType
    position?: NullableStringFieldUpdateOperationsInput | string | null
    employer?: NullableStringFieldUpdateOperationsInput | string | null
    employerAddressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    employerAddressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    employerCity?: NullableStringFieldUpdateOperationsInput | string | null
    employerState?: NullableStringFieldUpdateOperationsInput | string | null
    employerZip?: NullableStringFieldUpdateOperationsInput | string | null
    employerCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currentIncome?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyCreateManyOwnerInput = {
    id?: string
    name: string
    addressLine1: string
    addressLine2?: string | null
    city: string
    state: string
    zip: string
    countryCode?: string
    imageUrl?: string | null
    propertyType?: $Enums.PropertyType
    propertyStatus?: $Enums.PropertyStatus
    bedrooms?: number
    bathrooms?: number
    squareMeters?: number
    marketRent?: number
    deposit?: number
    leaseTerm?: number
    leaseTermType?: $Enums.LeaseTermType
    createdAt?: Date | string
    updatedAt?: Date | string
    sqmt?: number
    features?: PropertyCreatefeaturesInput | string[]
    amenities?: PropertyCreateamenitiesInput | string[]
    test?: string | null
  }

  export type PropertyUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    propertyStatus?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: FloatFieldUpdateOperationsInput | number
    squareMeters?: FloatFieldUpdateOperationsInput | number
    marketRent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    leaseTerm?: IntFieldUpdateOperationsInput | number
    leaseTermType?: EnumLeaseTermTypeFieldUpdateOperationsInput | $Enums.LeaseTermType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sqmt?: FloatFieldUpdateOperationsInput | number
    features?: PropertyUpdatefeaturesInput | string[]
    amenities?: PropertyUpdateamenitiesInput | string[]
    test?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: UnitUpdateManyWithoutPropertyNestedInput
    propertyDocument?: PropertyDocumentUpdateManyWithoutPropertyNestedInput
    Lease?: LeaseUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    propertyStatus?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: FloatFieldUpdateOperationsInput | number
    squareMeters?: FloatFieldUpdateOperationsInput | number
    marketRent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    leaseTerm?: IntFieldUpdateOperationsInput | number
    leaseTermType?: EnumLeaseTermTypeFieldUpdateOperationsInput | $Enums.LeaseTermType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sqmt?: FloatFieldUpdateOperationsInput | number
    features?: PropertyUpdatefeaturesInput | string[]
    amenities?: PropertyUpdateamenitiesInput | string[]
    test?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: UnitUncheckedUpdateManyWithoutPropertyNestedInput
    propertyDocument?: PropertyDocumentUncheckedUpdateManyWithoutPropertyNestedInput
    Lease?: LeaseUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    propertyStatus?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: FloatFieldUpdateOperationsInput | number
    squareMeters?: FloatFieldUpdateOperationsInput | number
    marketRent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    leaseTerm?: IntFieldUpdateOperationsInput | number
    leaseTermType?: EnumLeaseTermTypeFieldUpdateOperationsInput | $Enums.LeaseTermType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sqmt?: FloatFieldUpdateOperationsInput | number
    features?: PropertyUpdatefeaturesInput | string[]
    amenities?: PropertyUpdateamenitiesInput | string[]
    test?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UnitCreateManyPropertyInput = {
    id?: string
    name: string
    bedrooms?: number
    bathrooms?: number
    sqmt?: number
    marketRent?: number
    deposit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyDocumentCreateManyPropertyInput = {
    id?: string
    documentType: $Enums.DocumentType
    documentUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaseCreateManyPropertyInput = {
    id?: string
    unitId: string
    tenantId: string
    startDate: Date | string
    endDate: Date | string
    rent: number
    deposit: number
    rentDueCurrency: string
    status: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: FloatFieldUpdateOperationsInput | number
    sqmt?: FloatFieldUpdateOperationsInput | number
    marketRent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lease?: LeaseUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: FloatFieldUpdateOperationsInput | number
    sqmt?: FloatFieldUpdateOperationsInput | number
    marketRent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lease?: LeaseUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: FloatFieldUpdateOperationsInput | number
    sqmt?: FloatFieldUpdateOperationsInput | number
    marketRent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyDocumentUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    documentUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyDocumentUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    documentUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyDocumentUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    documentUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaseUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    rentDueCurrency?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitUpdateOneRequiredWithoutLeaseNestedInput
    tenant?: TenantUpdateOneRequiredWithoutLeaseNestedInput
    tenantLease?: TenantLeaseUpdateManyWithoutLeaseNestedInput
    invoice?: InvoiceUpdateManyWithoutLeaseNestedInput
    transactions?: TransactionsUpdateManyWithoutLeaseNestedInput
    maintenanceRequest?: MaintenanceRequestUpdateManyWithoutLeaseNestedInput
    leaseDocument?: LeaseDocumentUpdateManyWithoutLeaseNestedInput
  }

  export type LeaseUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    rentDueCurrency?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantLease?: TenantLeaseUncheckedUpdateManyWithoutLeaseNestedInput
    invoice?: InvoiceUncheckedUpdateManyWithoutLeaseNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutLeaseNestedInput
    maintenanceRequest?: MaintenanceRequestUncheckedUpdateManyWithoutLeaseNestedInput
    leaseDocument?: LeaseDocumentUncheckedUpdateManyWithoutLeaseNestedInput
  }

  export type LeaseUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    rentDueCurrency?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaseCreateManyUnitInput = {
    id?: string
    tenantId: string
    startDate: Date | string
    endDate: Date | string
    rent: number
    deposit: number
    rentDueCurrency: string
    status: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    propertyId?: string | null
  }

  export type LeaseUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    rentDueCurrency?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutLeaseNestedInput
    tenantLease?: TenantLeaseUpdateManyWithoutLeaseNestedInput
    property?: PropertyUpdateOneWithoutLeaseNestedInput
    invoice?: InvoiceUpdateManyWithoutLeaseNestedInput
    transactions?: TransactionsUpdateManyWithoutLeaseNestedInput
    maintenanceRequest?: MaintenanceRequestUpdateManyWithoutLeaseNestedInput
    leaseDocument?: LeaseDocumentUpdateManyWithoutLeaseNestedInput
  }

  export type LeaseUncheckedUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    rentDueCurrency?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    tenantLease?: TenantLeaseUncheckedUpdateManyWithoutLeaseNestedInput
    invoice?: InvoiceUncheckedUpdateManyWithoutLeaseNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutLeaseNestedInput
    maintenanceRequest?: MaintenanceRequestUncheckedUpdateManyWithoutLeaseNestedInput
    leaseDocument?: LeaseDocumentUncheckedUpdateManyWithoutLeaseNestedInput
  }

  export type LeaseUncheckedUpdateManyWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rent?: FloatFieldUpdateOperationsInput | number
    deposit?: FloatFieldUpdateOperationsInput | number
    rentDueCurrency?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TenantLeaseCreateManyLeaseInput = {
    id?: string
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateManyLeaseInput = {
    id?: string
    description: string
    dueAmount: number
    dueDate: Date | string
    category: $Enums.InvoiceCategory
    status: $Enums.InvoiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionsCreateManyLeaseInput = {
    id?: string
    description: string
    amountPaid: number
    referenceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceId?: string | null
  }

  export type MaintenanceRequestCreateManyLeaseInput = {
    id?: string
    description: string
    status: $Enums.MaintenanceRequestStatus
    priority: $Enums.MaintenanceRequestPriority
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaseDocumentCreateManyLeaseInput = {
    id?: string
    documentType: $Enums.DocumentType
    documentUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantLeaseUpdateWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutTenantLeaseNestedInput
  }

  export type TenantLeaseUncheckedUpdateWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantLeaseUncheckedUpdateManyWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dueAmount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumInvoiceCategoryFieldUpdateOperationsInput | $Enums.InvoiceCategory
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionsUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dueAmount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumInvoiceCategoryFieldUpdateOperationsInput | $Enums.InvoiceCategory
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionsUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dueAmount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumInvoiceCategoryFieldUpdateOperationsInput | $Enums.InvoiceCategory
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionsUpdateWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionsUncheckedUpdateWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionsUncheckedUpdateManyWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MaintenanceRequestUpdateWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumMaintenanceRequestStatusFieldUpdateOperationsInput | $Enums.MaintenanceRequestStatus
    priority?: EnumMaintenanceRequestPriorityFieldUpdateOperationsInput | $Enums.MaintenanceRequestPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceRequestUncheckedUpdateWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumMaintenanceRequestStatusFieldUpdateOperationsInput | $Enums.MaintenanceRequestStatus
    priority?: EnumMaintenanceRequestPriorityFieldUpdateOperationsInput | $Enums.MaintenanceRequestPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceRequestUncheckedUpdateManyWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumMaintenanceRequestStatusFieldUpdateOperationsInput | $Enums.MaintenanceRequestStatus
    priority?: EnumMaintenanceRequestPriorityFieldUpdateOperationsInput | $Enums.MaintenanceRequestPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaseDocumentUpdateWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    documentUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaseDocumentUncheckedUpdateWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    documentUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaseDocumentUncheckedUpdateManyWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    documentUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionsCreateManyInvoiceInput = {
    id?: string
    leaseId: string
    description: string
    amountPaid: number
    referenceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionsUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lease?: LeaseUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionsUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaseId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionsUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaseId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}